# **3.6** 链表 (**线性表的链式存储结构)**

![[/Untitled 16.png|Untitled 16.png]]

- 单链表不定义表长
- 顺序存储结构不够好的原因，其实也就是**为什么链式存储结构更好**?
    - 顺序存储结构的添加和删除效率很低，这就是因为在内存地址中的存储位置也都是相邻的，导致每一次添加或者删除元素都需要移动大量元素。
- 数据域和指针域
    - **数据域**: 存储数据元素信息的域称为数据域
    - **指针域**: 存储后继位置的域叫做指针域，其中存储的信息叫做指针或链
- 数据域和指针域合在一起的元素ai的存储映像，称为**结点**
- 头指针与头节点的区分
    - 头指针是: 链表中第一个节点的**存储位置**，也就是说它是一个地址。**头指针是链表的必要元素**。头指针是指链表指向第一个结点的指针，如果链表有头结点，则是指向头节点的指针。
    - 头结点: **链表中第一个节点的前面再设置一个节点，叫做头结点**。头结点的指针域存储着指向第一个节点的指针。头结点不一定是链表的必要元素。头结点的指针域存储指向第一个结点的指针。
- `head` 是链表中的一个重要概念，它表示链表的头节点。头节点是链表中的第一个节点，它是链表的起始点。**头节点本身并不存储实际的数据，它通常被用来指示链表的开始**。
    - 在实际的链表实现中，`head` 是一个指向链表第一个节点的指针。它用于在操作链表时定位链表的开头，并通过操作 `head` 来进行链表的插入、删除等操作。具体来说：
        - 在单链表中，`head` 是指向链表的第一个节点。
        - 在双向链表中，通常会有一个 `head` 指针和一个 `tail` 指针，分别指向链表的头部和尾部。
        - 在循环链表中，`head` 仍然指向链表的第一个节点，但是最后一个节点的 `next` 指向头节点，形成一个循环。
        - **`head`** **并不是链表中实际的节点，它是用来引导操作的一个指针**。在链表的插入、删除、查找等操作中，我们通常从 `head` 开始，然后沿着链表的指针逐步操作节点。通过对 `head` 的操作，我们可以影响整个链表的结构和内容。

# 3.7 **单链表的读取**

- 获得链表第i个数据的算法思路
    - 从头往后找，找到第i个元素

![[/Untitled 1 5.png|Untitled 1 5.png]]

  

# **3.8 单链表的插入与删除**

# **3.12 静态链表**

- 概念: 用数组描述的链表叫做静态链表。静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。
- 用数组来代替指针，来描述单链表
    - 让数组的元素都是由两个数据域组成,data和cur
- 静态链表的插入操作
- 静态链表的删除操作

# **3.13 单向循环链表 (约瑟夫环)**

循环链表解决了一个很麻烦的问题: 如何从当中一个结点出发，访问到链表的全部结点。

## 构建单向循环链表思路

1. 先创建第一个节点，让first指向该节点，并形成环形
2. 后面当我们每创建一个节点，就把该节点，加入到已有的环形链表中即可

## 遍历环形链表

1. 先让一个辅助指针 (变量) curBoy，指向first节点
2. 然后通过一个while循环遍历该环形链表即可，`curBoy.next == first;` 结束

## 删除环中的节点

# **3.14 双向链表**

双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱节点的指针域。

双向链表中的节点都有**两个指针域**，一个指向直接后继，另一个指向直接前驱。

![[%E6%88%AA%E5%B1%8F2023-12-17_%E4%B8%8B%E5%8D%8811.16.59.png]]

  

## 增删改查的操作思路

### 查

查的思路和单链表一样，只是可以向前，也可以向后查找。

### 添加节点在尾部

1. 先找到双向链表的最后一个节点
2. `[temp.next](http://temp.next)` `= newHeroNode;`
3. `newHeroNode.pre = temp;`

### 改

和单链表一样

### 删

1. 因为是双向链表，因此我们可以实现自我删除某个节点
2. 直接找到要删除的这个节点，比如temp
3. `[temp.pre.next](http://temp.pre.next)` `= temp.next;`
4. `temp.next.pre = temp.pre;`

将待删除节点的前一个节点的“指向后一个节点”的指针指向待删除节点的后一个节点。

将待删除节点的后一个节点的“指向前一个节点”的指针指向待删除节点的前一个节点。

# 练习题

## 单链表反转

### 思路

1. 先定义一个节点 `reverseHead = new HeroNode();`
2. 从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表`reverseHead`的最前端
3. [原来的链表的](http://原来的链表的head.next) `[head.next](http://原来的链表的head.next)` `= reverseHead.next;`

## 单链表逆序打印

使用栈这种数据结构来实现，先进后出的特点，而且没有破坏原始的链表的结构。

  

[[算法与数据结构/数据结构/链表/练习题/练习题|练习题]]