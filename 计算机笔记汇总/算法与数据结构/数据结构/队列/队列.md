# 队列的定义

  

![[%E6%88%AA%E5%B1%8F2023-09-04_%E4%B8%8A%E5%8D%889.45.06.png]]

  

下面是用数组来模拟队列的实现。

![[%E6%88%AA%E5%B1%8F2023-12-15_%E4%B8%8B%E5%8D%887.42.09.png]]

这个**front指向的是头元素的前面，不是指向的头元素**。而**rear指向的是最后一个元素**。`maxSize`变量的意思就是数组的最大容量。

发现上面这样的实现方式是有缺陷的，因为就会出现下面图里的第三个数组的情况:

![[%E6%88%AA%E5%B1%8F2023-12-15_%E4%B8%8B%E5%8D%887.42.09.png]]

尽管队列的前两个元素都推出了，但是由于front的移动，推出后的元素所占的位置依然无法填入元素，造成浪费，需要改进上面的代码。

**这样就引出循环队列的概念**了:

![[%E6%88%AA%E5%B1%8F2023-09-04_%E4%B8%8A%E5%8D%8810.15.55.png]]

# 数组模拟环形队列

1. front变量调整: **front就指向队列的第一个元素**，`arr[front]`就是队列的第一个元素
2. rear变量调整: **rear指向队列的最后一个元素的后一个位置**，**原则需要在队列中空出一个位置 (不一定是最后一位)**, 像上图4-12-6的index = 1的位置是空的这样也可以。
3. 尾指针位置: `rear = (front+size−1) mod N`
4. 判断队列满: `(rear + 1) % maxSize == front`这样写的原因是因为rear本来就指向最后元素的后一位，只有再+1，取模之后能等于front的位置，说明rear + 1和front位置重合了，所以才是队列满的状况。
5. 队列为空: `rear == front`
6. 队列长度公式 (有效的数据的个数): `(rear + maxSize - front) % maxSize`

## 为什么一定要保证队列中存在一个空位呢？

环形队列保留一个空位是**为了区分队列空和队列满的状态**。

如果不保留一个空位，当队列满时，队尾指针（rear）将与队头指针（front）重合。这种情况下，我们就无法区分队列是空还是满，因为在两种情况下指针的位置都是相同的。因此，为了避免这种混淆，我们约定在队列满时，总是保留至少一个元素的空间。这样，如果队尾指针（rear）与队头指针（front）重合，我们就知道队列是空的；如果队尾指针（rear）在前进时与队头指针（front）之间只有一个空位，我们就知道队列已满。

# 队列的链式存储结构

其实就是单链表的队列形式

# 单向队列与循环队列设置front和rear

在实现队列时，`front` 和 `rear` 变量的初始值取决于队列的类型（单向队列或循环队列）以及你如何定义这些变量的含义。下面解释为什么在单向队列和循环队列中，`front` 和 `rear` 的初始值有所不同。

## 单向队列

对于单向队列（非循环），通常会将 `front` 和 `rear` 初始化为 -1，原因如下：

- **初始状态为空**：当 `front` 和 `rear` 都为 -1 时，表示队列为空。这是一种约定，用于检测队列是否为空。
- `**front**` **表示队列头前一个位置**：在单向队列中，`front` 通常用来指向队列头部的前一个位置。当进行出队操作时，`front` 会增加。初始化为 -1 意味着队列的第一个元素将在数组的 0 位置。
- `**rear**` **表示队列尾部位置**：`rear` 用于指示队列尾部元素的位置。当队列为空时（即 `front` 等于 `rear`），`rear` 也应该表示一个不存在的位置，因此初始化为 -1。

## 循环队列

在循环队列中，`front` 和 `rear` 的初始化为 0，原因包括：

- **循环利用数组空间**：循环队列的设计允许在数组的末尾到达上限后循环回数组的开始，有效利用数组空间。初始化 `front` 和 `rear` 为 0 是表示队列起始于数组的开始位置。
- **避免 -1 的边界问题**：如果在循环队列中使用 -1 作为初始值，你需要更复杂的逻辑来处理索引的循环。例如，当 `rear` 为 -1 且需要循环回数组开始时，你需要特殊逻辑来将其设置为 0。使用 0 作为起始点简化了这些逻辑。
- **统一空队列和满队列的判定**：在循环队列中，通常使用 `(rear + 1) % size == front` 来判断队列是否已满，其中 `size` 是数组的大小。如果 `front` 和 `rear` 初始化为 -1，这个公式就不再适用。

综上所述，初始化 `front` 和 `rear` 为 -1 在单向队列中是有意义的，因为它们代表的是队列中实际元素的前一个和最后一个位置。而在循环队列中，将它们初始化为 0 更有利于简化索引的管理和循环逻辑。

# 队列和广度优先搜索

广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。

与树的层序遍历类似，`越是接近根结点的结点将越早地遍历`。如果在第 k 轮中将结点 `X` 添加到队列中，则根结点与 `X` 之间的最短路径的长度恰好是 `k`。也就是说，第一次找到目标结点时，你已经处于最短路径中。

结点的处理顺序与它们`添加`到队列的顺序是`完全相同的顺序`，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。

  

  

[[算法与数据结构/数据结构/队列/练习题/练习题|练习题]]