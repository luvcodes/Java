# 概念

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710673817061-890e7088-8379-441f-b539-9a1a6b115402.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710673817061-890e7088-8379-441f-b539-9a1a6b115402.png)

二叉排序树（Binary Search Tree，简称BST），也被称为二叉查找树或者二叉搜索树。这是一种特殊的二叉树，具有以下特点：

1. **节点的排序规则**：在二叉排序树中，每个节点都有一个键值，且每个节点的键值都不相同。**对于树中的任意一个节点，其左子树中的所有节点的键值都小于该节点的键值，而其右子树中的所有节点的键值都大于该节点的键值。**
2. **动态数据结构**：二叉排序树是一个动态的数据结构，可以在维持其排序特性的同时，动态地插入或删除节点。
3. **查找效率**：在二叉排序树中查找一个键值的效率通常比在链表等其他数据结构中高，特别是在树比较平衡的情况下。**理想情况**下（树完全平衡），**查找的时间复杂度是O(log n)**，其中n是树中节点的数量。但在**最坏的情况**下（树完全不平衡，形成一个链），查找的时间复杂度会退化到**O(n)**。
4. **中序遍历有序**：对二叉排序树进行中序遍历（先访问左子树，再访问当前节点，最后访问右子树），可以得到一个升序排列的节点序列。
5. **用途广泛**：二叉排序树是很多高级数据结构（如红黑树、AVL树）的基础，也广泛用于各种场景，如数据库索引、集合和映射的实现等。

需要注意的是，二叉排序树的性能很大程度上依赖于树的形状（平衡与否）。当树趋于不平衡时，其性能可能不如其他更平衡的数据结构。因此，有许多二叉排序树的变体（如AVL树、红黑树）专门用来保持树的平衡，以优化性能。

让我们通过一个示例来了解如何在二叉排序树（BST）中查找和添加节点。

假设我们有以下BST：

```Plain
				15
       /  \
      10   20
     / \    \
    8  12   25
```

## 查找节点

假设我们要查找值为12的节点。查找过程如下：

1. 从根节点开始（值为15）。
2. 由于12小于15，我们向左移动。
3. 在左子节点（值为10）处，12大于10，所以我们向右移动。
4. 在右子节点（值为12）处，我们找到了我们的目标节点。

## 添加节点

现在，假设我们要添加一个值为17的节点。添加过程如下：

1. 从根节点开始（值为15）。
2. 由于17大于15，我们向右移动。
3. 在右子节点（值为20）处，17小于20，所以我们向左移动。
4. 该节点（20）的左子节点为空，所以我们在这里插入新的节点（值为17）。

添加节点17后，BST变成了：

```Plain
        15
       /  \
      10   20
     /  \  / \
    8  12  17 25
```

通过这个例子，你可以看到在二叉排序树中查找和添加节点的过程是如何遵循树的排序规则的。在查找时，我们根据值的大小决定是向左还是向右移动；在添加新节点时，我们也是按照同样的规则找到合适的位置。

# BST的创建与遍历

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138367176-c66c1ee6-4ccb-470d-861e-8ddcd89caf0d.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138367176-c66c1ee6-4ccb-470d-861e-8ddcd89caf0d.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138381859-24c49e1d-bd31-4c34-943b-48b6266669cf.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138381859-24c49e1d-bd31-4c34-943b-48b6266669cf.png)

## 前序遍历

```Java
class ArrayBinaryTree {
    private int[] arr; // 存储数据节点的数组
    public ArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }

    // 编写一个方法，完成顺序存储二叉树的前序遍历
    public void preOrder(int index) {
        // 如果数组为空，或者arr.length = 0
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }
        // 输出当前这个元素
        System.out.println(arr[index]);
        // 向左递归遍历
        if (2 * index + 1 < arr.length) {
            preOrder(2 * index + 1);
        }
        // 向右递归遍历
        if (2 * index + 2 < arr.length) {
            preOrder(2 * index + 2);  // 向右递归遍历，就是二叉树的后序遍历
        }

        return;  // 递归结束，返回到上一层，继续遍历上一层节点
    }
}
```

## 中序遍历

```Java
public void inOrder() {
        this.inOrder(0);
    }

    private void inOrder(int index) {
        if (index >= arr.length) {
            return;
        }
        if (2 * index + 1 < arr.length) {
            inOrder(2 * index + 1);
        }
        System.out.println(arr[index]);
        if (2 * index + 2 < arr.length) {
            inOrder(2 * index + 2);
        }
    }
```

## 后序遍历

```Java
public void postOrder() {
        this.postOrder(0);
    }

    private void postOrder(int index) {
        if (index >= arr.length) {
            return;
        }
        if (2 * index + 1 < arr.length) {
            postOrder(2 * index + 1);
        }
        if (2 * index + 2 < arr.length) {
            postOrder(2 * index + 2);
        }
        System.out.println(arr[index]);
    }
```

# BST的节点删除

## 3种情况

### 删除叶子节点

1. 先找到要删除的节点 (targetNode)
2. 找到targetNode的父节点 parent
3. 确定targetNode是父节点的左子节点还是右子节点
4. 根据(3)的情况来具体分析

### 删除只有一棵子树的节点

### 删除有两棵子树的节点

```Java
// 删除有两颗子树的节点
            else if (targetNode.left != null && targetNode.right != null) {
                // 这里是举例实现如果要删除的目标节点恰好是在右面的子树
                int minVal = delRightTreeMin(targetNode.right);
                // 最小节点的值替换. 将 targetNode 的值替换为它的中序后继的值，因为它的值已经被delRightTreeMin方法里替换掉了
                targetNode.value = minVal;
                // 使用中序后继或中序前驱
                // int minVal = delRightTreeMin(targetNode.right); // 使用中序后继
                // int maxVal = delLeftTreeMax(targetNode.left); // 使用中序前驱
                // targetNode.value = maxVal; // 或者使用minVal，取决于使用哪种方式
            }
```

```Java
// 编写方法:
    // 1. 删除node 为根结点的二叉排序树的最小结点
    /**
     * @param node 传入的结点(当做二叉排序树的根结点)
     * @return 返回的 以node 为根结点的二叉排序树的最小结点的值
     * 使用 delRightTreeMin(targetNode.right) 是为了找到 targetNode 的中序后继节点，即它右子树中的最小节点。
     * delRightTreeMin 方法不仅返回这个最小值 minVal，而且还从树中删除了包含这个最小值的节点。
     */
    public int delRightTreeMin(Node node) {
        Node target = node;
        //循环的查找左子节点，就会找到最小值
        while(target.left != null) {
            target = target.left;
        }
        // 这时 target就指向了最小结点
        // 删除最小结点
        delNode(target.value);
        return target.value;
    }

    /**
     * 删除node为根节点的二叉排序树的最大节点
     *
     * @param node 传入的节点（当做二叉排序树的根节点）
     * @return 返回以node为根节点的二叉排序树的最大节点的值
     */
    public int delLeftTreeMax(Node node) {
        Node target = node;
        // 循环查找右子节点，就会找到最大值
        while (target.right != null) {
            target = target.right;
        }
        // 这时target就指向了最大节点
        // 删除最大节点
        delNode(target.value);
        return target.value;
    }
```

当需要删除的节点既有左子树又有右子树时，**一般的处理策略是用其“中序前驱”或“中序后继”来替换它**，**然后删除那个中序前驱或中序后继节点**。

**中序前驱**是指**该节点左子树中的最大节点**，而**中序后继**是指**其右子树中的最小节点**。由于中序前驱和中序后继都最多只有一个子节点，因此它们可以按照“删除叶子节点”或“删除只有一个子树的节点”的方法来删除。

这里以使用中序后继节点来替换要删除的节点为例，具体步骤如下：

1. **找到中序后继**：首先，找到要删除的节点的右子树中的最小节点，即中序后继节点。这个节点可以通过从要删除的节点的右子树开始，不断向左子树移动直到找到一个没有左子树的节点。
2. **替换节点**：将要删除的节点的值替换为其中序后继节点的值。这样，问题就转换成了如何删除那个中序后继节点。
3. **删除中序后继节点**：由于中序后继节点不会有左子树（如果有，那就不是最小的节点了），所以它最多只有一个右子树。这时，可以按照“删除叶子节点”或“删除只有一个子树的节点”的方法来删除它。

例如，考虑以下BST，我们要删除值为15的节点：

```Plain
        15
       /  \\
      10   20
     / \\ 	/ \\
    8  12 17  25
```

步骤如下：

1. 找到15的中序后继，即其右子树中的最小值。在这个例子中，中序后继是17。
2. 将15替换为17。
3. 删除原来的17节点。由于17是一个叶子节点，可以直接删除。

删除后，树变成了：

```Plain
        17
       /  \\
      10   20
     / \\   \\
    8  12   25
```

这种方法保持了BST的所有性质，同时有效地处理了有两个子树的节点的删除问题。

在这段代码中，targetNode.value = minVal; 这一行确实是在执行替换操作。

**当您要删除一个有两个子树的节点时（即 targetNode），直接移除它会破坏二叉排序树的结构**。因此，我们采用了一种间接的方法：先找到一个可以“替代”它的节点，然后删除那个替代节点。这个替代节点通常是：

- 中序后继（右子树中的最小节点）。
- 或者中序前驱（左子树中的最大节点）。

使用 delRightTreeMin(targetNode.right) 是为了找到 targetNode 的中序后继节点，即它右子树中的最小节点。delRightTreeMin 方法不仅返回这个最小值 minVal，而且还从树中删除了包含这个最小值的节点。

接着，代码中的 targetNode.value = minVal; 这一行是将 targetNode 的值替换为它的中序后继的值。这样做的目的是保留二叉排序树的结构和性质，同时实际上是删除了 targetNode 的值（因为它的值已经被替换掉了）。

通过这种方法，**targetNode 本身虽然仍在树中，但它的值已经被移除，并被它的中序后继的值所替代**。这样，二叉排序树的结构得以保持，同时也实现了删除操作的目的。

# BST的弊端

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710675058529-84356a1d-011a-48e5-b87c-c2fa1360c73f.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710675058529-84356a1d-011a-48e5-b87c-c2fa1360c73f.png)

出现这样的情况，就形成了单链表，查询效率大大降低，引出平衡二叉树。