[https://juejin.cn/post/7035513034491576334](https://juejin.cn/post/7035513034491576334)

# 概念

1. 树有很多种，**每个节点最多只能有两个子节点的一种形式称为二叉树**。
2. 二叉树的子节点分为左节点和右节点
3. 每个节点最多有两棵子树，二叉树中不存在度大于2的节点。注意: **不是只有两棵子树，而是最多有**。没有子树或者有一棵子树都是可以的。
4. 左子树和右子树是有顺序的，次序不能任意颠倒。
5. 即使树中某节点只有一棵子树，也要区分它是左子树还是右子树。

# 二叉树节点的内部结构

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710674614471-cd9197e0-cac5-4544-aa91-f81e8ce5a8eb.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710674614471-cd9197e0-cac5-4544-aa91-f81e8ce5a8eb.png)

# 满二叉树

如果该二叉树的所有叶子节点都在最后一层，并且节点总数 = 2^n - 1, n为层数，则我们称为**满二叉树**。

一个二叉树**所有的非叶子节点都存在左右两个孩子**，并且**所有叶子节点都在同一层级上**，这样的树被称为满二叉树。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710137997745-59fa20f9-9be5-494b-aa8c-612845b74b71.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710137997745-59fa20f9-9be5-494b-aa8c-612845b74b71.png)

# 完全二叉树

如果该二叉树的**所有叶子节点都在最后一层或者倒数第二层**，而且**最后一层的叶子节点在左边连续**，**倒数第二层**的**叶子节点在右边连续**，我们称为**完全二叉树**。

完全二叉树（Complete Binary Tree）是一种特殊的二叉树，其特点是除了最后一层外，每一层都是完全填满的，并且**最后一层的节点都尽可能地向左排列**。在完全二叉树中，如果有 n 个节点，那么每个节点都有一个从 0 到 n-1 的唯一索引，就像它们在数组中的位置一样。这种属性使得完全二叉树特别适合用数组来表示。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138052915-4b1bb7b4-098e-4492-8641-2649727b1ff3.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138052915-4b1bb7b4-098e-4492-8641-2649727b1ff3.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138087988-a03882fb-8573-425e-8b81-02589d1f2b10.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138087988-a03882fb-8573-425e-8b81-02589d1f2b10.png)

完全二叉树的特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。

需要注意的是，**满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树**。

# 遍历二叉树

## **前序遍历**

若二叉树为空，则空操作返回，否则**先访问根节点**，然后前序**遍历左子树**，再前序**遍历右子树**。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138113963-e795f22a-5882-486d-979f-2d3ea94b2e64.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138113963-e795f22a-5882-486d-979f-2d3ea94b2e64.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710674076142-e327d3cf-678f-4288-856c-cce8fa7cfd81.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710674076142-e327d3cf-678f-4288-856c-cce8fa7cfd81.png)

## **中序遍历**

若树为空，则空操作返回，否则遍历根节点的**左子树**，然后是访问**根节点**，最后遍历**右子树**。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138198286-972c2404-cf45-46cc-bf07-98553bb15e74.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138198286-972c2404-cf45-46cc-bf07-98553bb15e74.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710674177142-d1af07e9-a088-4850-8598-863175de01ad.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710674177142-d1af07e9-a088-4850-8598-863175de01ad.png)

## **后序遍历**

若树为空，则空操作返回，否则从左到右先叶子后节点的方式**遍历左右子树**，**最后是访问根节点**。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138232951-40927591-3b7c-4e99-9354-22ec8279a680.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138232951-40927591-3b7c-4e99-9354-22ec8279a680.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710674297837-844e732e-5d10-4369-a0e8-88b9ede0e942.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710674297837-844e732e-5d10-4369-a0e8-88b9ede0e942.png)

## **层序遍历**

若树为空，则空操作返回，否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历;

在同一层中，按从左到右的顺序对节点逐个访问。

层序遍历（Level Order Traversal）是一种树的遍历方式，它从树的根节点开始，逐层遍历树的节点，首先访问根节点，然后依次访问第一层、第二层，以此类推。使用队列可以很方便地实现层序遍历。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138271720-0dd6652b-6f3f-4a9c-aa1d-62cd9c45a858.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138271720-0dd6652b-6f3f-4a9c-aa1d-62cd9c45a858.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710674384464-9071b1ff-91d9-4081-b6a1-e6b6186516e9.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710674384464-9071b1ff-91d9-4081-b6a1-e6b6186516e9.png)

## 二叉树遍历的两个性质

- 已知前序遍历序列和中序遍历序列，可以确定唯一的一棵二叉树
- 已知后序遍历序列和中序遍历序列，可以确定唯一的一棵二叉树

但是已知前序遍历序列和后序遍历序列，是不能确定一棵二叉树的。

# 二叉树查找指定节点

## 举例

```Plain
    1
   / \
  2   3
     / \
    5   4
```

## 前序遍历查找

1. 先判断当前节点的id是否等于要查找的
2. 如果相等，则返回当前节点
3. 如果不等，则判断当前节点的左子节点是否为空。如果不为空，则递归前序查找
4. 如果左递归前序查找，找到节点，则返回。否则继续判断，当前节点的右子节点是否为空。如果不空，则向右递归前序查找。

## 中序遍历查找

1. 先判断当前节点的左子节点是否为空，如果不为空，则递归中序查找。如果找到，则返回。
2. 如果没有找到，就和当前节点进行比较，相等则返回当前节点。不相等，则继续进行右递归中序查找
3. 如果在右递归中序查找找到了，就返回，否则返回空

## 后序遍历查找

1. 先判断当前节点的左子节点是否为空，如果不为空，则递归后序查找。如果找到，则返回。
2. 如果没找到，就判断右子节点是否为空，不为空，就进行右递归后序查找，找到，就返回。
3. 如果右递归后序查找也没有找到，就和当前节点进行比较，是则返回，否则返回nul

# 二叉树删除节点

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138328622-77f4c942-d622-4590-95e9-ec66a6fd5029.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138328622-77f4c942-d622-4590-95e9-ec66a6fd5029.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138337144-b20f6fcd-1413-405a-b868-4010b0a27ba4.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138337144-b20f6fcd-1413-405a-b868-4010b0a27ba4.png)

# 顺序存储二叉树

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138367176-c66c1ee6-4ccb-470d-861e-8ddcd89caf0d.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138367176-c66c1ee6-4ccb-470d-861e-8ddcd89caf0d.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138381859-24c49e1d-bd31-4c34-943b-48b6266669cf.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710138381859-24c49e1d-bd31-4c34-943b-48b6266669cf.png)

## 前序遍历

```Java
class ArrayBinaryTree {
    private int[] arr; // 存储数据节点的数组
    public ArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }

    // 编写一个方法，完成顺序存储二叉树的前序遍历
    public void preOrder(int index) {
        // 如果数组为空，或者arr.length = 0
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }
        // 输出当前这个元素
        System.out.println(arr[index]);
        // 向左递归遍历
        if (2 * index + 1 < arr.length) {
            preOrder(2 * index + 1);
        }
        // 向右递归遍历
        if (2 * index + 2 < arr.length) {
            preOrder(2 * index + 2);  // 向右递归遍历，就是二叉树的后序遍历
        }

        return;  // 递归结束，返回到上一层，继续遍历上一层节点
    }
}
```

## 中序遍历

```Java
public void inOrder() {
        this.inOrder(0);
    }

    private void inOrder(int index) {
        if (index >= arr.length) {
            return;
        }
        if (2 * index + 1 < arr.length) {
            inOrder(2 * index + 1);
        }
        System.out.println(arr[index]);
        if (2 * index + 2 < arr.length) {
            inOrder(2 * index + 2);
        }
    }
```

## 后序遍历

```Java
public void postOrder() {
        this.postOrder(0);
    }

    private void postOrder(int index) {
        if (index >= arr.length) {
            return;
        }
        if (2 * index + 1 < arr.length) {
            postOrder(2 * index + 1);
        }
        if (2 * index + 2 < arr.length) {
            postOrder(2 * index + 2);
        }
        System.out.println(arr[index]);
    }
```

# 线索化二叉树

## 目标

线索化二叉树（Threaded Binary Tree）是为了提高二叉树遍历的效率而提出的数据结构。在传统的二叉树中，遍历（如中序、前序或后序遍历）通常通过递归或栈来实现，这在某些情况下可能不够高效，尤其是当树中存在大量空指针时。线索化的目的是利用这些空指针来存储指向某种遍历顺序下的前驱节点和后继节点的指针，从而使遍历过程更加高效。

"线索"是指原本为空的左右子指针被用来指向某种特定顺序下的前驱或后继节点的指针。**这种利用空指针域存储额外信息的技术称为“线索化”**，而**这些额外的指针**（即指向前驱或后继的指针）**被称为“线索”**。

**这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。**根据线索性质的不同，可分为前序线索二叉树、中序线索二叉树和后续线索二叉树。

- **前驱（Predecessor）**：在某种遍历顺序下，一个节点的前一个节点称为其前驱。
- **后继（Successor）**：在某种遍历顺序下，一个节点的下一个节点称为其后继。

例如，在中序线索化二叉树中，一个节点的空左指针会指向它的中序前驱，而空右指针会指向它的中序后继。

通过这种方式，线索化二叉树可以更快地进行遍历操作，因为不再需要递归或栈来跟踪访问路径。

对于一个给定的节点，以下是判断其是否可以被线索化的标准：

1. **左指针线索化**：

- 如果节点的左指针为空（即该节点没有左子节点），则这个左指针可以被线索化。
- 在这种情况下，左指针可以指向该节点的中序遍历前驱。

1. **右指针线索化**：

- 如果节点的右指针为空（即该节点没有右子节点），则这个右指针可以被线索化。
- 在这种情况下，右指针可以指向该节点的中序遍历后继。

## 如何确定前驱和后继

- **前驱（Inorder Predecessor）**：
- 在中序遍历中，一个节点的前驱是其左子树中最右下的节点。如果左子树不存在，那么前驱可能是该节点的某个祖先节点，或者该节点没有前驱（即它是遍历的第一个节点）。
- **后继（Inorder Successor）**：
- 在中序遍历中，一个节点的后继是其右子树中最左下的节点。如果右子树不存在，那么后继可能是该节点的某个祖先节点，或者该节点没有后继（即它是遍历的最后一个节点）。

### 示例：

考虑以下二叉树：

```Plain
     A
    / \\
   B   C
```

- 节点B没有左子节点，因此B的左指针可以线索化，指向其中序遍历的前驱（如果存在）。
- 节点B没有右子节点，因此B的右指针可以线索化，指向其中序遍历的后继，即节点A。
- 节点A和C的左右指针都连接到子节点，所以这些指针不被线索化。

## 注意

线索化过程通常发生在对树进行特定遍历方式（如中序遍历）的过程中。这意味着在遍历树的同时，我们根据当前遍历的规则（前序、中序、后序）来确定并设置线索。因此，一个节点是否可以被线索化取决于它在遍历中的位置以及它的左右子节点的存在性。