# 数组

## 数组的概念



## 操作数组

### 读取元素

读取数组中的元素，是通过访问索引的方式来读取的，索引一般从 0 开始。

在计算机中，内存可以看成一些已经排列好的格子，每个格子对应一个内存地址。一般情况下，数据会分散地存储在不同的格子中。

而对于数组，计算机会在内存中为其申请一段 连续 的空间，并且会记下索引为 0 处的内存地址。以数组 ["C", "O", "D", "E", "R"] 为例，它的各元素对应的索引及内存地址如下图所示。

<img src="https://pic.leetcode-cn.com/273ac74bdd7a19d72c2bf60d84ddd66f09b45de4d8c36333bf5f1fee2c7a8330-%E5%9B%BE%E7%89%872.png" alt="2.png" style="zoom: 33%;" />

假如我们想要访问索引为 2 处的元素 "D" 时，计算机会进行以下计算：

- 找到该数组的索引 0 的内存地址： 2008；

- 将内存地址加上索引值，作为目标元素的地址，即 2008 + 2 = 2010，对应的元素为 "D"，这时便找到了目标元素。

我们知道，计算内存地址这个过程是很快的，而我们一旦知道了内存地址就可以立即访问到该元素，因此它的时间复杂度是常数级别，为 
O(1)。

### 查找元素

与读取元素类似，由于我们只保存了索引为 0 处的内存地址，因此在查找元素时，只需从数组开头逐步向后查找就可以了。如果数组中的某个元素为目标元素，则停止查找；否则继续搜索直到到达数组的末尾。

<img src="https://pic.leetcode-cn.com/3d9c20552e0e9c4650f4a267f4066aa71338ad0013514559b57a1bf786d662ba-4.gif" alt="4.gif" style="zoom:50%;" />

我们发现，最坏情况下，搜索的元素为 "R"，或者数组中不包含目标元素时，我们需要查找 n 次，n 为数组的长度，因此查找元素的时间复杂度为𝑂(𝑁)，𝑁为数组的长度。

### 插入元素

假如我们想在原有的数组中再插入一个元素 "S" 呢？

如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。

然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置 腾出 空间，然后进行插入操作。比如，我们想要在索引 2 处插入 "S"。

<img src="https://pic.leetcode-cn.com/22ce7dbf8cd441fd7425499cd8154d1c4211a6a42ec3f3995520ee76ce7183c7-7.gif" alt="7.gif" style="zoom: 50%;" />

如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。

### 删除元素

删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 空缺 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 填补 操作。

以删除索引 1 中的元素 "O" 为例，具体过程如图所示。

![6.gif](https://pic.leetcode-cn.com/4df7a5a75e5f76b6e7e4540f9403c7c2fee5197a1f30421b4f5d32fdca2cf360-8.gif)

当数组的长度为 n 时，最坏情况下，我们删除第一个元素，共需要的步骤数为 1 + (n - 1) = n 步，其中，1 为删除操作，n - 1 为移动其余元素的步骤数。删除操作具有线性时间复杂度，即时间复杂度为𝑂(𝑁)，N 为数组的长度。

<img src="https://pic.leetcode-cn.com/1617108025-oQRoDO-%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C.jpg" alt="数组的操作.jpg" style="zoom: 50%;" />





# 稀疏数组 (sparsearray)

## 基本介绍

如果一个数组中大部分的元素是0，或者为同一个值的数组的时候，就可以用稀疏数组来保存该数组。

## 示例

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1702595563428-26a68cb1-5576-49de-a166-98c831b8e65f.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1702595563428-26a68cb1-5576-49de-a166-98c831b8e65f.png)

第一行，也就是[0]行，体现行、列、值。

6，7，8分别代表原始的二维数组有6行数据，7列数据，不是0的元素总共有8个。

从[1]开始就是说明，第0行，第3列有一个数据，值为22; 第[2]行代表，第0行，第[6]列有一个数据，值为15.

## 二维数组转稀疏数组的思路

1. 遍历原始的二维数组，得到有效数据的个数sum
2. 根据sum就可以创建稀疏数组sparseArr int[sum + 1][3]
3. 将二维数组的有效数据存入到稀疏数组

## 稀疏数组还原二维数组的思路

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可

# 3.4 一维数组 (**线性表的顺序结构)**

- 顺序存储: 用**一段地址连续的存储单元**依次存储线性表的数据元素。
    - 描述顺序存储结构需要三个属性
        - 存储空间的起始位置
        - 线性表的最大存储容量: 数组长度MaxSize
        - 线性表的当前长度: length
    - 区分数组长度MaxSize和线性表长度length
        - 数组长度是存放线性表的存储空间的长度，**存储分配后这个量一般是不变的**。
        - 线性表的长度是线性表中数据元素的个数，这个量是变化的。
        - 在任一时刻，线性表的长度应该小于等于数组的长度。用数组存储顺序表意味着分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于档案线性表的长度。

# **3.5 线性表顺序存储结构的插入与删除**

- 顺序存储结构的优势就在于它的读和存的效率很高，但是插入和删除效率很低，因为每次插入和删除都需要移动大量的元素。
    - 为什么每次插入和删除都需要移动大量的元素呢？
        - 因为相邻两个元素的存储位置也有邻居关系(内存地址相邻)
- 插入算法的思路:
    - 如果插入位置不合理，抛出异常
    - 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
    - 从最后一个元素向前遍历到第i个位置，分别将它们都向后移动一个位置
    - 将要插入元素填入位置i处
    - 表长 + 1
- 删除算法的思路:
    - 如果删除位置不合理，抛出异常
    - 取出删除元素
    - 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
    - 表长 - 1

顺序存储：

在一块连续的存储区域一个接着一个的存放数据。

顺序存储方式把逻辑上相邻的节点存储在物理位置放在相邻的存储单元里，节点间的逻辑关系由存储单元的邻接关系来体现。

顺序存储方式也称为顺序存储结构，一般采用数组或结构数组来描述。

- 优点： 在结点等长时可以随机存取 存储密度高节省存储空间 用结点的物理次序反映结点之间的逻辑关系
- 缺点： 插入和删除结点时要移动大量的结点 必须静态分配连续空间

链接存储：链接存储方式比较灵活，不要求逻辑上相邻的节点在物理位置上相邻，节点间的逻辑关系由附加的引用字段来表示。

一个节点的引用字段往往指向下一个节点的存放位置。

链接存储方式也成为链式存储结构。

- 优点： 插入和删除比较灵活，不需要大量移动结点 动态分配空间比较灵活，不需要预先申请最大的连续空间
- 缺点： 增加指针的空间开销 检索必须沿链进行，不能随机存取 因此D不是顺序存储的优点，而是链接存储的优点。

# 链式存储

链接存储：链接存储方式比较灵活，不要求逻辑上相邻的节点在物理位置上相邻，节点间的逻辑关系由附加的引用字段来表示。

**一个节点的引用字段往往指向下一个节点的存放位置。**

链接存储方式也成为链式存储结构。

- 优点： 插入和删除比较灵活，不需要大量移动结点 动态分配空间比较灵活，不需要预先申请最大的连续空间
- 缺点： 增加指针的空间开销 检索必须沿链进行，不能随机存取 因此D不是顺序存储的优点，而是链接存储的优点。