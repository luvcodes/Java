
# 数组的知识点

读取数组中的元素，是通过访问索引的方式来读取的，索引一般从 0 开始。

在计算机中，内存可以看成一些已经排列好的格子，每个格子对应一个内存地址。一般情况下，数据会分散地存储在不同的格子中。

而对于数组，计算机会在内存中为其申请一段连续的空间，并且会记下索引为 0 处的内存地址。以数组 ["C", "O", "D", "E", "R"] 为例，它的各元素对应的索引及内存地址如下图所示。

![[Pasted image 20240424232631.png]]

假如我们想要访问索引为 2 处的元素 "D" 时，计算机会进行以下计算：
找到该数组的索引 0 的内存地址： 2008；
将内存地址加上索引值，作为目标元素的地址，即 2008 + 2 = 2010，对应的元素为 "D"，这时便找到了目标元素。
我们知道，计算内存地址这个过程是很快的，而我们一旦知道了内存地址就可以立即访问到该元素，因此它的时间复杂度是常数级别，为 𝑂(1)

## 读取元素

## 查找元素

## 插入元素

## 删除元素

# 二维数组

二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。
![[Pasted image 20240424232854.png|450]]

所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 `0` 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。

## 示例

类似一维数组，对于一个二维数组 A = `[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]`，计算机同样会在内存中申请一段连续的空间，并记录第一行数组的索引位置，即 `A0` 的内存地址，它的索引与内存地址的关系如下图所示。

![[Pasted image 20240424233105.png]]

注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值可能不为 1。

实际题目中，往往使用二维数组处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。

# 稀疏数组 (sparsearray)

## 基本介绍

如果一个数组中大部分的元素是0，或者为同一个值的数组的时候，就可以用稀疏数组来保存该数组。

## 示例:

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1702595563428-26a68cb1-5576-49de-a166-98c831b8e65f.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1702595563428-26a68cb1-5576-49de-a166-98c831b8e65f.png)

第一行，也就是[0]行，体现行、列、值。

6，7，8分别代表原始的二维数组有6行数据，7列数据，不是0的元素总共有8个。

从[1]开始就是说明，第0行，第3列有一个数据，值为22; 第[2]行代表，第0行，第[6]列有一个数据，值为15.

## 二维数组转稀疏数组的思路

1. 遍历原始的二维数组，得到有效数据的个数sum
2. 根据sum就可以创建稀疏数组sparseArr int[sum + 1][3]
3. 将二维数组的有效数据存入到稀疏数组

## 稀疏数组还原二维数组的思路

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可

# 一维数组 (线性表的顺序结构)

- 顺序存储: 用**一段地址连续的存储单元**依次存储线性表的数据元素。
    - 描述顺序存储结构需要三个属性
        - 存储空间的起始位置
        - 线性表的最大存储容量: 数组长度MaxSize
        - 线性表的当前长度: length
    - 区分数组长度MaxSize和线性表长度length
        - 数组长度是存放线性表的存储空间的长度，**存储分配后这个量一般是不变的**。
        - 线性表的长度是线性表中数据元素的个数，这个量是变化的。
        - 在任一时刻，线性表的长度应该小于等于数组的长度。用数组存储顺序表意味着分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于档案线性表的长度。

# 线性表顺序存储结构的插入与删除

- 顺序存储结构的优势就在于它的读和存的效率很高，但是插入和删除效率很低，因为每次插入和删除都需要移动大量的元素。
    - 为什么每次插入和删除都需要移动大量的元素呢？
        - 因为相邻两个元素的存储位置也有邻居关系(内存地址相邻)
- 插入算法的思路:
    - 如果插入位置不合理，抛出异常
    - 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
    - 从最后一个元素向前遍历到第i个位置，分别将它们都向后移动一个位置
    - 将要插入元素填入位置i处
    - 表长 + 1
- 删除算法的思路:
    - 如果删除位置不合理，抛出异常
    - 取出删除元素
    - 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
    - 表长 - 1

顺序存储：

在一块连续的存储区域一个接着一个的存放数据。

顺序存储方式把逻辑上相邻的节点存储在物理位置放在相邻的存储单元里，节点间的逻辑关系由存储单元的邻接关系来体现。

顺序存储方式也称为顺序存储结构，一般采用数组或结构数组来描述。

- 优点： 在结点等长时可以随机存取 存储密度高节省存储空间 用结点的物理次序反映结点之间的逻辑关系
- 缺点： 插入和删除结点时要移动大量的结点 必须静态分配连续空间

链接存储：链接存储方式比较灵活，不要求逻辑上相邻的节点在物理位置上相邻，节点间的逻辑关系由附加的引用字段来表示。

一个节点的引用字段往往指向下一个节点的存放位置。

链接存储方式也成为链式存储结构。

- 优点： 插入和删除比较灵活，不需要大量移动结点 动态分配空间比较灵活，不需要预先申请最大的连续空间
- 缺点： 增加指针的空间开销 检索必须沿链进行，不能随机存取 因此D不是顺序存储的优点，而是链接存储的优点。

# 链式存储

链接存储：链接存储方式比较灵活，不要求逻辑上相邻的节点在物理位置上相邻，节点间的逻辑关系由附加的引用字段来表示。

**一个节点的引用字段往往指向下一个节点的存放位置。**

链接存储方式也成为链式存储结构。

- 优点： 插入和删除比较灵活，不需要大量移动结点 动态分配空间比较灵活，不需要预先申请最大的连续空间
- 缺点： 增加指针的空间开销 检索必须沿链进行，不能随机存取 因此D不是顺序存储的优点，而是链接存储的优点。