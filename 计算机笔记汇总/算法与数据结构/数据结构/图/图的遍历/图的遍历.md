从图中的某个节点出发，访问一遍图中其余顶点，且使每个顶点仅被访问一次，这就叫做图的遍历。

# 深度优先遍历 (DFS)

> [!info] 01. 图的深度优先搜索知识  
> 1.  
> [https://algo.itcharge.cn/08.Graph/02.Graph-Traversal/01.Graph-DFS/#_1-深度优先搜索简介](https://algo.itcharge.cn/08.Graph/02.Graph-Traversal/01.Graph-DFS/#_1-深度优先搜索简介)  

## 概念

从图中的某顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发，深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。

深度优先搜索算法中所谓的深度优先，就是说优先沿着一条路径走到底，直到无法继续深入时再回头。

## 算法步骤

1. 选择起始节点 u，并将其标记为已访问。
2. 检查当前节点是否为目标节点（看具体题目要求）。
3. 如果当前节点 u 是目标节点，则直接返回结果。
4. 如果当前节点 u 不是目标节点，则遍历当前节点 u 的所有未访问邻接节点。
5. 对每个未访问的邻接节点 v，从节点 v 出发继续进行深度优先搜索（递归）。这里要根据原始数组的存储顺序来确定访问哪一个邻接节点。
6. 如果节点 u 没有未访问的相邻节点，回溯到上一个节点，继续搜索其他路径。
7. 重复 2∼6 步骤，直到遍历完整个图或找到目标节点为止。

# 广度优先搜索（BFS）

> [!info] 图的广度优先和深度优先遍历（BFS和DFS） - 掘金  
> 图是一种灵活的数据结构，一般作为一种模型用来定义对象之间的关系或联系。对象由顶点（V）表示，而对象之间的关系或者关联则通过图的边（E）来表示。 图可以分为有向图和无向图，一般用G=(V,E)来表示图。经常用邻接矩阵或者邻接表来描述一副图。 在图的基本算法中，最初需要接触的就是图…  
> [https://juejin.cn/post/6844903533372768263](https://juejin.cn/post/6844903533372768263)  

> [!info] 9.3   图的遍历 - Hello 算法  
> 动画图解、一键运行的数据结构与算法教程  
> [https://www.hello-algo.com/chapter_graph/graph_traversal/#__tabbed_2_3](https://www.hello-algo.com/chapter_graph/graph_traversal/#__tabbed_2_3)  

广度优先搜索（BFS, Breadth-First Search）是图论中的另一种基本搜索算法，用于遍历或搜索树或图的结构。与深度优先搜索不同，广度优先搜索按照“层级”逐层遍历图。

1. **选择起点**：选择一个顶点作为搜索的起始点，并将其标记为已访问。
2. **初始化队列**：将起始顶点加入到一个**队列**中。
3. **队列非空时循环**：只要队列不为空，就继续执行下面的步骤。
4. **访问队首顶点**：从队列中取出一个顶点，并访问它。
5. **遍历邻接顶点**：查找刚才访问的顶点的所有邻接顶点。对于每一个未访问过的邻接顶点，将其标记为已访问，并加入队列。
6. **重复步骤**：重复步骤 4 和 5，直到队列为空。
7. **所有顶点访问完成**：当队列为空时，表明图中所有与起始顶点连通的顶点都已被访问过。

**广度优先搜索的特点是逐层遍历**，首先访问起始顶点的所有直接邻接点，然后再访问这些邻接点的未访问邻接点，以此类推。这种方法非常适合于寻找最短路径或者检查图的连通性。

在实际应用中，**BFS 通常使用队列来实现**。每次从队列中取出一个顶点，并探索它的所有邻接点，然后将这些未被访问的邻接点加入队列。这样，队列总是按照顶点被访问的顺序排列。

现在，请考虑这样一个问题：在广度优先搜索中，队列的使用有何重要性？这和深度优先搜索的栈或递归方法有何不同？

## 为什么使用队列？

队列在广度优先搜索（BFS）中扮演着至关重要的角色，原因主要在于其特殊的数据结构特性 —— 先进先出（FIFO, First-In-First-Out）。这个特性使得队列成为实现 BFS 的理想选择，原因如下：

1. **层级顺序遍历**：广度优先搜索需要按照从近到远的顺序遍历顶点，先访问起始点的直接邻接点，再访问这些邻接点的邻接点，依此类推。队列的先进先出特性确保了顶点按照它们被添加到队列的顺序被访问，这正是 BFS 所需要的。
2. **记录待访问顶点**：在 BFS 过程中，当访问一个顶点的时候，可能会发现多个未访问的邻接点。这些邻接点需要稍后访问，队列提供了一种方便的方式来记录这些待访问的顶点。
3. **简化控制流程**：使用队列可以简化算法的控制流程。只要队列不为空，就从队列中取出一个顶点来访问，然后将其未访问的邻接点加入队列。这样的过程很容易实现且逻辑清晰。
4. **保证公平性**：队列确保了每个顶点被访问的“公平性”。无论一个顶点的邻接点有多少，每个顶点都会按照它们被发现的顺序来进行探索。
5. **实现最短路径搜索**：在某些特定的图中（如无权图），BFS 可以用来找到两点之间的最短路径。队列的使用确保了路径的长度逐渐增加，第一次到达任一顶点的路径都是最短的。

综上所述，队列在 BFS 中的使用对于实现按层级顺序的顶点访问和维护探索过程的有序性至关重要。这与深度优先搜索使用的栈（后进先出）或递归（通过调用栈实现）形成了鲜明的对比。

# 对比DFS和BFS

## 广度优先搜索（BFS）

1. **特点**：按层遍历图，先访问起始顶点的所有邻接点，然后再访问这些邻接点的邻接点，依此类推。
2. **数据结构**：**使用队列来实现**。队列遵循先进先出（FIFO）的原则。
3. **过程**：从一个顶点开始，探索其所有邻接顶点，然后逐层向外扩展。
4. **应用**：用于找到两点之间的最短路径（在无权图中），适合于层级较少的场景或需要按层级排序的情况。

## 深度优先搜索（DFS）

1. **特点**：深入到每个分支的最深处，直到找不到新的未访问顶点，然后回溯并尝试其他路线。
2. **数据结构**：可以使用栈来实现，但更常见的是使用递归。
3. **过程**：从一个顶点开始，深入探索其一个邻接点，然后继续深入下去，直到无法再深入，再回溯到之前的顶点，探索其他路径。
4. **应用**：适用于需要探索所有可能路径的问题，如迷宫求解、拓扑排序、寻找图中的环等。

## BFS 与 DFS 的比较

- **顺序**：BFS 是按层级顺序，而 DFS 是尽可能深地探索每个分支。
- **实现**：BFS 通常使用队列，而 DFS 通常使用递归或栈。
- **效率**：在密集图中，BFS 可能需要更多的内存，因为队列可能在同一时间保存大量顶点。DFS 通常内存占用更少，但可能会陷入深层递归。
- **用途**：BFS 适合寻找最短路径或检查图的连通性；DFS 适合需要遍历所有路径的问题，如解决迷宫问题或寻找所有可能的解决方案。

![[%E6%88%AA%E5%B1%8F2024-01-12_%E4%B8%8A%E5%8D%8811.42.59.png]]