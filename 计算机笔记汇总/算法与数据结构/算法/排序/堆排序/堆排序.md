图解说明 - [《堆排序》堆排序详解-CSDN博客](https://blog.csdn.net/Look_star/article/details/120220415#:~:text=%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E6%98%AF%EF%BC%9A%E5%B0%86%E5%BE%85%E6%8E%92%E5%BA%8F%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E6%88%90%E4%B8%80%E4%B8%AA%E5%A4%A7%E9%A1%B6%E5%A0%86%EF%BC%8C%E6%AD%A4%E6%97%B6%EF%BC%8C%E6%95%B4%E4%B8%AA%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%B0%B1%E6%98%AF%E5%A0%86%E9%A1%B6%E7%9A%84%E6%A0%B9%E8%8A%82%E7%82%B9%E3%80%82,%E5%B0%86%E5%85%B6%E4%B8%8E%E6%9C%AB%E5%B0%BE%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E4%BA%A4%E6%8D%A2%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%9C%AB%E5%B0%BE%E5%B0%B1%E4%B8%BA%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%82%20%E7%84%B6%E5%90%8E%E5%B0%86%E5%89%A9%E4%BD%99n-1%E4%B8%AA%E5%85%83%E7%B4%A0%E9%87%8D%E6%96%B0%E6%9E%84%E9%80%A0%E6%88%90%E4%B8%80%E4%B8%AA%E5%A0%86%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%BC%9A%E5%BE%97%E5%88%B0n%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%AC%A1%E5%B0%8F%E5%80%BC%E3%80%82)

  

> [!info] 图解排序算法(三)之堆排序 - dreamcatcher-cx - 博客园  
> 预备知识 堆排序 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。 堆 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于  
> [https://www.cnblogs.com/chengxiao/p/6129630.html](https://www.cnblogs.com/chengxiao/p/6129630.html)  

# 堆排序介绍

堆排序是一种选择排序，最坏，最好，平均时间复杂度均为O(nlogn), 它也是不稳定排序。

堆是具有以下性质的完全二叉树:

- 分为两种堆
    - 大顶堆: 每个节点的值都大于或等于其左右孩子节点的值
    - 小顶堆: 每个节点的值都小于或等于其左右孩子节点的值

**升序采用大顶堆**

**降序采用小顶堆**

![[/Untitled 32.png|Untitled 32.png]]

  

# 堆排序基本思想

1. 初始化:将无序数组构建成一个大顶堆(最大堆)。
2. 将堆顶元素(最大元素)与末尾元素交换位置。
3. 将长度减1,重新构造大顶堆。
4. 重复步骤2,3,直到堆长度为1。

堆排序利用了大顶堆(最大堆)这个数据结构进行排序。它的时间复杂度为O(nlogn),空间复杂度为O(1),是一种原地排序算法。相比快速排序,堆排序有更好的 worst-case性能。

# 示例说明

将一个数组转换成最大堆的过程涉及重新排列数组中的元素，使得每个父节点都大于或等于其子节点。这个过程通常通过一种称为“堆化”（heapify）的操作实现，具体步骤如下：

## 步骤 1: 理解完全二叉树的数组表示

在堆排序中，堆通常被视为一个完全二叉树，并用数组来表示。在数组中：

- 父节点 `i` 的左子节点是 `2*i + 1`（如果存在）。
- 父节点 `i` 的右子节点是 `2*i + 2`（如果存在）。
- 子节点 `i` 的父节点是 `(i-1)/2`。

## 步骤 2: 从最后一个非叶子节点开始堆化

1. **找到最后一个非叶子节点**：最后一个非叶子节点是数组中最后一个元素的父节点。在数组长度为 `n` 的情况下，最后一个非叶子节点的索引是 `(n/2) - 1`。
2. **向下堆化**：从最后一个非叶子节点开始，向上遍历每个节点，对每个节点执行堆化操作。这个操作包括：
    - 比较节点与其左右子节点的值。
    - 如果节点的值小于其子节点中的任何一个，则将其与最大的子节点交换。
    - 递归地对交换后的子节点进行堆化操作，直到当前节点大于其子节点或成为叶子节点。

## 步骤 3: 遍历所有非叶子节点

重复步骤 2，直到处理了数组中的每个非叶子节点。最终，数组将被重新排列成最大堆。

## 示例

假设有一个数组 `[5, 3, 8, 4, 2]`。转换成最大堆的步骤是：

1. 最后一个非叶子节点是索引 `(5/2) - 1 = 1`（值为 3）。
2. 从索引 1 开始向下堆化。3 比其子节点 4 和 2 小，所以与较大的子节点 4 交换位置，得到 `[5, 4, 8, 3, 2]`。
3. 接下来处理根节点（索引 0，值为 5）。虽然 5 比左子节点 4 大，但小于右子节点 8，所以与 8 交换位置，得到 `[8, 4, 5, 3, 2]`。

此时，数组 `[8, 4, 5, 3, 2]` 表示的二叉树是一个最大堆。您可以看到，每个父节点都大于或等于其子节点。

# 堆排序添加、删除节点

## 在最大堆中添加或删除节点

### 添加节点

1. **插入新节点**：在堆的末尾添加新节点（即数组的末尾）。
2. **向上堆化**：将新添加的节点与其父节点比较。如果新节点的值大于父节点的值，则交换这两个节点的位置。重复这个过程，直到新节点小于其父节点或者新节点成为根节点。

### 删除节点

1. **删除堆顶节点**：在最大堆中，通常删除的是堆顶节点（即数组的第一个元素），因为它是堆中的最大值。
2. **用最后一个节点替换堆顶节点**：将堆的最后一个节点移动到堆顶位置。
3. **向下堆化**：将新的堆顶节点与其子节点比较。如果它小于任一子节点，则与最大的子节点交换位置。重复这个过程，直到新节点大于其所有子节点或者成为叶子节点。

### 示例

假设在最大堆 `[8, 4, 5, 3, 2]` 中添加一个新节点 `6`。

1. **添加节点**：将 `6` 添加到数组末尾，得到 `[8, 4, 5, 3, 2, 6]`。
2. **向上堆化**：比较 `6` 和其父节点 `4`（索引为 `(5-1)/2 = 2`）。由于 `6 > 4`，交换 `6` 和 `4`，得到 `[8, 6, 5, 3, 2, 4]`。

删除堆顶节点 `8` 的过程是：

1. **删除堆顶节点**：移除 `8`。
2. **替换堆顶节点**：用最后一个节点 `4` 替换堆顶节点，得到 `[4, 6, 5, 3, 2]`。
3. **向下堆化**：比较 `4` 和其子节点 `6` 和 `5`。`6` 是最大的，所以 `4` 和 `6` 交换位置，得到 `[6, 4, 5, 3, 2]`。

希望这些信息能够帮助您更好地理解完全二叉树、平衡二叉树以及如何在最大堆中添加或删除节点。如果您有任何其他问题，欢迎继续提问！