# 公交站问题

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8A%E5%8D%8810.48.49.png]]

  

# 介绍

涉及到最小生成树, 引出两个概念

- 最小: 所有边权值加起来最小
- 树: 没有环
- 包含所有顶点

克鲁斯卡尔算法（Kruskal's Algorithm）是一种用于在**无向加权图**中寻找**最小生成树**的算法。

**最小生成树**是指一棵**包含图中所有顶点的树**，且**树上所有边的权重之和最小**。这个算法在各种网络设计、如电信网络、计算机网络、交通运输网络等领域都非常有用。

1. **初始化**：开始时，算法将图中的每个顶点视为一个独立的树（即每个顶点是一个最小生成树）。
2. **排序**：**将图中的所有边按照权重从小到大排序**。如果边的权重相同，可以任意排序。
3. **选择边**：按排序后的顺序选择边，如果这条边连接的两个顶点属于不同的树，则添加这条边，否则忽略。添加边的操作实际上是将两棵树合并为一棵树。
4. **重复**：重复步骤3，直到所有的顶点都在同一棵树上，或者已经选择了`n-1`条边（`n`是顶点的数量）。
5. **完成**：最后得到的树就是最小生成树。

简单来说，克鲁斯卡尔算法的核心思想是：在不形成环的前提下，每次选择最小的边，通过这种方式逐步构建出最小生成树。这个算法的效率取决于边的排序方法，通常使用诸如快速排序或堆排序等高效排序算法来实现。

# 解法

确实，`kruskal()` 方法是实现克鲁斯卡尔算法的核心部分。我会逐步解释这个方法的关键步骤：

### 1. 初始化

- **索引** `**index**`：用于追踪最小生成树中边的数量。
- **数组** `**ends[]**`：存储最小生成树中每个顶点的终点。这对检测新添加的边是否会形成环非常关键。
- **数组** `**rets[]**`：存储最终的最小生成树中的边。

### 2. 获取图的所有边

- 使用 `getEdges()` 方法从邻接矩阵中提取所有边，并存储在 `EData[] edges` 数组中。

### 3. 边的排序

- 通过 `sortEdges()` 方法对所有边按照权重进行排序。这确保了算法能够首先考虑权重最小的边。

### 4. 选择边构建最小生成树

- 遍历排序后的边数组 `edges`。
- 对于每条边：
    - 使用 `getPosition()` 方法找到边两端顶点在顶点数组中的索引。
    - 使用 `getEnd()` 方法找到这两个顶点在已经形成的最小生成树中的终点。
- **关键检查**：判断这两个终点是否相同。如果不同，则表示添加这条边不会形成环。
    - 如果终点不同，将这条边加入到 `rets[]`，并更新 `ends[]` 数组，记录这条边的终点信息。

### 5. 输出最小生成树

- 遍历 `rets[]` 数组，打印出构成最小生成树的边。

### 具体实现细节

- **环的检测**：核心在于环的检测。通过不断更新每个顶点的终点，算法可以确保添加的每条边不会与已经选择的边形成环。
- **性能考量**：虽然这个方法在理论上是高效的，但它的性能也取决于边的数量和图的大小。对于非常大的图，边的排序和环的检测可能会成为性能瓶颈。

总体来说，`kruskal()` 方法通过精心设计的步骤高效地实现了克鲁斯卡尔算法，确保了能够从给定的图中找到权重最小的生成树。