# 递归的概念

# 递归调用规则

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703137082936-d2dd363f-d2c3-4b55-b456-f8a5bc6a5862.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703137082936-d2dd363f-d2c3-4b55-b456-f8a5bc6a5862.png)

1. 当程序执行到一个方法时，就会开辟一个独立的空间 (栈)
2. 每个空间的数据即局部变量，是独立的。就像上面的栈区里的每一个栈帧里面的n都是独立的。
3. 如果方法中使用的是引用类型变量，就会共享改引用类型的数据
4. 递归必须向推出递归的条件逼近，否则就是无限递归 (StackOverflowError)。
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁。

# 迷宫问题

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703156312401-6c2ac34a-d79e-4c84-827e-0fae5edcec0b.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703156312401-6c2ac34a-d79e-4c84-827e-0fae5edcec0b.png)

实际上重要的点就是两个:

- 一旦递归实例返回 false，控制权就回到了进行这次递归调用的那个递归实例。这个“前一个递归调用”的点是调用当前递归实例的那个地方。
- 每走一个格子，都是上下左右判断一次，直到找到走哪个方向能走得通

代码演示中先是下右上左，第二种方法是上右下左。

# 最短路径

### 穷举法

这样效率比较低。思路: 找出来所有的方法，然后把这些方法存在一个数组里。分别按照每一种方法走一遍，统计每种方法所产生的2的数量，哪个方法生成的2最少，哪个就是最短路径。

# 8皇后问题