# 暴力匹配算法

暴力匹配算法（Brute Force Algorithm）是一种简单直接的字符串匹配方法，其核心思想是检**查主字符串（**`**str1**`**）中的所有可能的开始位置，看它们是否与模式字符串（**`**str2**`**）匹配**。

## 初始设置

- `str1 = "ABCDABD"`
- `str2 = "ABD"`
- `i = 0` (指向 `str1` 的起始位置)
- `j = 0` (指向 `str2` 的起始位置)

## 匹配步骤

1. **第一轮尝试**:
    - `str1[i] = A`, `str2[j] = A` -> 匹配。`i = 1`, `j = 1`.
    - `str1[i] = B`, `str2[j] = B` -> 匹配。`i = 2`, `j = 2`.
    - `str1[i] = C`, `str2[j] = D` -> 不匹配。此时重置 `j = 0`, `i = i - (j - 1) = 1`.
2. **第二轮尝试** (从 `str1` 的第二个字符开始):
    - `str1[1] = B`, `str2[0] = A` -> 不匹配。重置 `j = 0`, `i = 2`.
3. **第三轮尝试** (从 `str1` 的第三个字符开始):
    - `str1[2] = C`, `str2[0] = A` -> 不匹配。重置 `j = 0`, `i = 3`.
4. **第四轮尝试** (从 `str1` 的第四个字符开始):
    - `str1[3] = D`, `str2[0] = A` -> 不匹配。重置 `j = 0`, `i = 4`.
5. **第五轮尝试** (从 `str1` 的第五个字符开始):
    - `str1[4] = A`, `str2[0] = A` -> 匹配。`i = 5`, `j = 1`.
    - `str1[5] = B`, `str2[1] = B` -> 匹配。`i = 6`, `j = 2`.
    - `str1[6] = D`, `str2[2] = D` -> 匹配。`i = 7`, `j = 3`.
6. **完成匹配**:
    - 此时 `j = 3`，等于 `str2` 的长度 (`s2Len`)，表明已经在 `str1` 中找到了与 `str2` 完全匹配的子串。
7. **返回结果**:
    - 匹配的起始索引是 `i - j = 7 - 3 = 4`，即从 `str1` 的第五个字符 `A` 开始。

  

# KMP算法

> [!info] 帮你把KMP算法学个通透！（理论篇）_哔哩哔哩_bilibili  
> 我已经陆续将算法专题整理成了pdf供大家学习，pdf中不仅有刷题大纲、刷题顺序，还有详细图解，每一本pdf发布之后都广受好评，在公众号「代码随想录」后台回复：333，就可以获取了，赶快下载看看吧！, 视频播放量 251293、弹幕量 1801、点赞数 9232、投硬币枚数 8421、收藏人数 4027、转发人数 817, 视频作者 代码随想录, 作者简介 我是Carl，哈工大师兄，先后在腾讯和百度从事一线技术研发的程序员，公众号「代码随想录」，相关视频：帮你把KMP算法学个通透！（求next数组代码篇），最浅显易懂的 KMP 算法讲解，听说C++ primer 太厚了 看不进去？，「六分钟速通」KMP算法求解流程，科软学长在原神两小时后顿悟kmp秒杀大法，难在去重和剪枝！| LeetCode：18.  
> [https://www.bilibili.com/video/BV1PD4y1o7nd/?vd_source=638cc86179a132cc986508a1d8c81526](https://www.bilibili.com/video/BV1PD4y1o7nd/?vd_source=638cc86179a132cc986508a1d8c81526)  

> [!info] 最浅显易懂的 KMP 算法讲解_哔哩哔哩_bilibili  
> 最浅显易懂的 KMP 算法讲解, 视频播放量 249063、弹幕量 751、点赞数 9308、投硬币枚数 5945、收藏人数 8344、转发人数 2442, 视频作者 奇乐编程学院, 作者简介 ，相关视频：kmp算法-求next和nextval的值，简单做题方法，「六分钟速通」KMP算法求解流程，【天勤考研】KMP算法易懂版，KMP算法与改进后的KMP算法讲解（自留），『教程』什么是递归？，KMP算法时间复杂度分析，KMP算法讲解+代码实现，Kubernetes (k8s) 10分钟快速入门，串的模式匹配算法概念（BF和KMP），408考研kmp算法，看这个应该就够了  
> [https://www.bilibili.com/video/BV1AY4y157yL/?vd_source=638cc86179a132cc986508a1d8c81526](https://www.bilibili.com/video/BV1AY4y157yL/?vd_source=638cc86179a132cc986508a1d8c81526)  

  
这两个查找方法的部分匹配表 找到对应位置的前一位的数字都是‘2’，但是第一组就直接跳过了3位数字，第二组却只跳过了两位数字，这是因为什么原因呢？  

## 第一组: str1: "aabaabaaf", str2: "aabaaf"

- **部分匹配表**: 我们需要先为 "aabaaf" 生成部分匹配表。对于 `str2: "aabaaf"`，部分匹配表是 `[0, 1, 0, 1, 2, 0]`。

匹配过程的每一步：

1. 比较 `str1[0]` (`a`) 与 `str2[0]` (`a`)：匹配。
2. 比较 `str1[1]` (`a`) 与 `str2[1]` (`a`)：匹配。
3. 比较 `str1[2]` (`b`) 与 `str2[2]` (`b`)：匹配。
4. 比较 `str1[3]` (`a`) 与 `str2[3]` (`a`)：匹配。
5. 比较 `str1[4]` (`a`) 与 `str2[4]` (`a`)：匹配。
6. 比较 `str1[5]` (`b`) 与 `str2[5]` (`f`)：不匹配。根据KMP表，模式向右滑动3位（从索引5滑动到2）。
7. 比较 `str1[5]` (`b`) 与 `str2[2]` (`b`)：匹配。
8. 比较 `str1[6]` (`a`) 与 `str2[3]` (`a`)：匹配。
9. 比较 `str1[7]` (`a`) 与 `str2[4]` (`a`)：匹配。
10. 比较 `str1[8]` (`f`) 与 `str2[5]` (`f`)：匹配。完整匹配在索引3处找到。

## 第二组: str1: "abababcaa", str2: "ababc"

- **部分匹配表**: 同样，我们为 "ababc" 生成部分匹配表。对于 `str2: "ababc"`，部分匹配表是 `[0, 0, 1, 2, 0]`。

1. 比较 `str1[0]` (`a`) 与 `str2[0]` (`a`)：匹配。
2. 比较 `str1[1]` (`b`) 与 `str2[1]` (`b`)：匹配。
3. 比较 `str1[2]` (`a`) 与 `str2[2]` (`a`)：匹配。
4. 比较 `str1[3]` (`b`) 与 `str2[3]` (`b`)：匹配。
5. 比较 `str1[4]` (`a`) 与 `str2[4]` (`c`)：不匹配。根据KMP表，模式向右滑动2位（从索引4滑动到2）。
6. 比较 `str1[4]` (`a`) 与 `str2[2]` (`a`)：匹配。
7. 比较 `str1[5]` (`b`) 与 `str2[3]` (`b`)：匹配。
8. 比较 `str1[6]` (`a`) 与 `str2[4]` (`c`)：匹配。完整匹配在索引2处找到。

## 分析

在KMP算法中，当**遇到不匹配的情况时**，我们利用部分匹配表来决定“跳过”多少个字符。

- 当 `str2` 中的某个位置字符与 `str1` 中的字符不匹配时，我们查看部分匹配表中该位置**之前**的值。**这个值告诉我们** **`str2`** **中有多长的相同前缀和后缀。**
- 重要的是，这个值指示的是在不匹配发生之前，`str2` 中已经匹配的部分中最长的相同前缀和后缀的长度。因此，我们可以将 `str2` 向右移动到这个最长相同前缀的下一个字符处开始比较。

例如，如果部分匹配值是2，而我们在 `str2` 的第6个字符处遇到不匹配，这意味着在前5个字符中有一个长度为2的相同前缀和后缀。我们不需要重新检查这个已经匹配的前缀，因此可以将 `str2` 向右移动一定的位置。但这个“跳过”的具体数量还取决于不匹配的位置和已经匹配的字符数量。

## 结论

因此，**尽管在两个例子中部分匹配表中的数字可能相同**，但由于**不匹配发生的位置不同，跳过的实际字符数量也会不同**。这是KMP算法优化匹配过程、避免不必要的比较的关键所在。

## “跳过”计算的具体方式

1. **已匹配的字符数 (**`**j**`**)**: 当发生不匹配时，你已经匹配了 `str2` 中的前 `j` 个字符。这意味着你已经检查了 `str1` 和 `str2` 中相对应的这 `j` 个字符。
2. **部分匹配表的值 (**`**kmp_table[j - 1]**`**)**: 这个值表示在 `str2` 中，直到第 `j` 个字符为止，最长的相同前缀和后缀的长度。
3. **“跳过”的数量**: 当第 `j` 个字符不匹配时，你可以在 `str2` 中跳过 `j - kmp_table[j - 1]` 个字符。这是因为你已经知道在 `str2` 的前 `j` 个字符中，有一个长度为 `kmp_table[j - 1]` 的前缀，它与后缀相匹配。因此，你可以安全地将 `str2` 向右滑动，使得这个已知的匹配前缀对齐到 `str1` 中的当前位置。

这意味着算法会“跳过”一些比较，因为它已经知道这些位置的字符是匹配的。这就是KMP算法的核心优势，它减少了不必要的比较，从而加快了搜索速度。

  

真正的移动长度应该是 `j - kmp_table[j - 1]`