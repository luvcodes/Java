# 核心思想

将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法。

动态规划（Dynamic Programming, DP）算法和分治算法都是解决复杂问题的有效方法，它们通过分解问题为更小的子问题来简化和解决原问题。然而，这两种算法在处理子问题的方式和应用场景上存在明显的不同。

# 与分治算法的相同与不同

## 相同点

1. **分解为子问题**：动态规划和分治算法都是通过将原问题分解为较小的子问题来解决的。
2. **减少问题规模**：这两种方法都通过处理更小的子问题，简化原问题的复杂性。

## 不同点

1. **子问题的重叠性**：
    - **动态规划**：动态规划用于解决具有重叠子问题的情况。在动态规划中，相同的子问题会在解决过程中多次出现，因此，算法会存储这些子问题的解决方案，避免重复计算。
    - **分治算法**：分治算法用于解决子问题相互独立的情况。在分治算法中，各个子问题是独立的，即子问题不会重叠。
2. **存储子问题的解**：
    - **动态规划**：存储子问题的解（通常在表格中），以便之后可以重用，这是为了避免重复计算。
    - **分治算法**：通常不需要存储子问题的解，因为子问题是独立的，不会重复出现。
3. **应用场景**：
    - **动态规划**：常用于优化问题，如最短路径、最大子数组和等，特别是当问题可以通过考虑较小规模问题的最优解来构建更大规模问题的最优解时。
    - **分治算法**：常用于快速排序、归并排序、二分搜索等，适用于可以递归地将问题分解成两个或多个较小独立问题的情况。
4. **算法复杂性**：
    - **动态规划**：通常更关注于减少计算重复子问题的时间复杂性。
    - **分治算法**：更多关注于将问题分解成更易于管理和解决的部分。

  

# 背包问题

动态规划中的背包问题是一类经典的优化问题，它可以分为几种不同的类型，但最常见的是0-1背包问题和无限背包问题。

1. **0-1背包问题**：
    - **问题描述**：假设有一个背包，它能承受一定的最大重量W。同时有N个物品，每个物品有自己的重量和价值。目标是选择一些物品装入背包，使得背包中物品的总价值最大，但不能超过背包的承重限制。
    - **解决方法**：使用动态规划。我们创建一个二维数组dp，其中dp[i][w]表示在考虑前i个物品，且背包承重为w时可以获得的最大价值。对于每个物品，我们可以选择“放入背包”或者“不放入背包”，然后根据这些选择更新dp数组。
2. **无限背包问题（完全背包问题）**：
    - **问题描述**：与0-1背包问题类似，不同之处在于每种物品可以选择无限次。
    - **解决方法**：动态规划的方法类似，但在更新dp数组时，我们需要考虑每种物品可以被多次选择的情况。

对于这两种背包问题，关键点在于理解动态规划的状态转移方程和初始化条件。

## 0-1背包问题

在动态规划的解法中，我们通常使**用一个二维数组**来存储中间结果。在这个数组中，**每一行代表考虑到的物品数量**，**每一列代表不同的背包容量**。例如，`dp[i][j]` 会表示在考虑前 `i` 个物品时，背包容量为 `j` 的情况下能获得的最大价值。

因此，在代码或算法中，当我们提到变量 `j` 时，它就是指在某一特定情况下背包的当前容量。动态规划的过程就是遍历不同的 `i`（物品数量）和 `j`（背包容量）的组合，以找出最优的物品组合。

### 代码实现

```Java
        for(int i = 1; i < v.length; i++) {
            for(int j = 1; j < v[0].length; j++) {
                //公式
                if(w[i - 1] > j) { 
                    v[i][j] = v[i - 1][j];
                } else {

                    if(v[i - 1][j] < val[i - 1] + v[i - 1][j - w[i - 1]]) {
                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];
                        //把当前的情况记录到path
                        path[i][j] = 1;
                    } else {
                        v[i][j] = v[i - 1][j];
                    }
                }
            }
        }
```

  

这个表达式 `v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]])` 是0-1背包问题动态规划解法的核心部分。它**用于在两种情况下选择最大值**：不放当前物品和放入当前物品。下面我会逐一解释这个表达式的每个部分：

1. `v[i - 1][j]`：
    - 这部分代表的是“不放入当前考虑的第 `i` 个物品时”的最大价值。这里，我们看的是前 `i-1` 个物品在背包容量为 `j` 时的最大价值。也可以理解成是上一个单元格的值。
2. `val[i - 1] + v[i - 1][j - w[i - 1]]`：
    - `val[i - 1]`：这是当前考虑的第 `i` 个物品的价值。
    - `v[i - 1][j - w[i - 1]]`：这里的 `j - w[i - 1]` 表示如果你放入第 `i` 个物品后，背包**剩余的容量**。`v[i - 1][j - w[i - 1]]` 则是在这个剩余容量下，前 `i-1` 个物品可以达到的最大价值。
    - 将这两者相加，就得到了“如果放入当前考虑的第 `i` 个物品”时的总价值。
3. `Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]])`：
    - 这个函数是在两种情况下选择最大价值。如果放入第 `i` 个物品得到的价值 (`val[i - 1] + v[i - 1][j - w[i - 1]]`) 大于不放入该物品的价值 (`v[i - 1][j]`)，那么我们选择放入该物品。反之，则不放入。

总结起来，这个表达式是在对于每个物品和每种背包容量，比较放入这个物品与不放入这个物品时可以获得的最大价值，并选择价值更大的那个选项。

  

理解 `j - w[i - 1]` 这部分的关键在于理解动态规划在解决0-1背包问题时如何处理每个物品的选择。让我进一步解释这个概念。

在0-1背包问题中，我们的目标是在不超过背包最大容量 `j` 的前提下，选择物品以最大化背包中物品的总价值。当我们考虑是否将第 `i` 个物品放入背包时，我们需要考虑两种情况：

1. **不放入第** `**i**` **个物品**：这种情况下，我们维持当前背包的价值不变，即 `v[i - 1][j]`。
2. **放入第** `**i**` **个物品**：这是更复杂的情况。假设我们决定将第 `i` 个物品放入背包，这个物品有自己的重量 `w[i - 1]` 和价值 `val[i - 1]`。放入这个物品后，背包的剩余容量就会减少，具体减少的量是这个物品的重量 `w[i - 1]`。因此，剩余容量就是 `j - w[i - 1]`。
    
    在这种情况下，我们需要考虑在剩余容量 `j - w[i - 1]` 下，之前的 `i-1` 个物品可以达到的最大价值，即 `v[i - 1][j - w[i - 1]]`。然后，我们将这个价值与当前物品的价值 `val[i - 1]` 相加，得到如果选择放入第 `i` 个物品时背包的总价值。
    

所以，`j - w[i - 1]` 实际上表示的是在决定放入第 `i` 个物品后，背包剩下的容量。这是理解如何更新动态规划表中每个元素的关键部分，因为它帮助我们确定在每个不同容量限制下，选择不同物品组合时能达到的最大价值。