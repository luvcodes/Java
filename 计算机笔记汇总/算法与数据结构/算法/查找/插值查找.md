# 原理

插值查找算法估计值在数组中位置的过程，本质上是根据要查找的值与数组中已知的最大值和最小值之间的关系来进行的。这个过程类似于我们在生活中根据比例进行估算。让我们通过一个例子来更详细地解释这个过程。

假设你有一个已经排好序的数组，你要在这个数组中查找一个特定的值。在插值查找中，我们首先考虑数组的最小索引（`low`）和最大索引（`high`）。然后我们使用以下公式来估计目标值可能存在的位置（`pos`）：

[![](https://cdn.nlark.com/yuque/__latex/faa50c98cfd962cc65005a5ca4bde2e6.svg)](https://cdn.nlark.com/yuque/__latex/faa50c98cfd962cc65005a5ca4bde2e6.svg)

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1704022931573-1f678920-6427-445c-a34a-5e923c19a074.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1704022931573-1f678920-6427-445c-a34a-5e923c19a074.png)

这个公式的组成部分包括：

- `key`：这是你想在数组中找到的值。
- `arr[low]`：数组中最小索引处的值。
- `arr[high]`：数组中最大索引处的值。
- `low` 和 `high`：数组的最小和最大索引。

公式的核心思想是根据`key`值与数组最小和最大值之间的关系，来估算`key`在数组中的大致位置。想象你有一本按页码顺序排列的书，现在你要找一个特定的页码。插值查找算法类似于二分查找，但它更聪明一点。它会先估算一下你要找的页码大概在书的哪个部分。比如，如果你要找的是靠近书末的页码，它就会直接跳到书的后面部分开始查找，而不是从中间开始。这种估算是基于你要找的页码值和书的总页数。

例如，如果`key`非常接近`arr[low]`，那么`pos`将会非常接近`low`；相反，如果`key`非常接近`arr[high]`，那么`pos`将会非常接近`high`。通过这种方式，插值查找算法可以快速地定位到目标值可能所在的区域，从而减少搜索次数。

总之，插值查找算法通过使用目标值与数组中已知值的比例关系，智能地估算目标值可能的位置，从而加速查找过程。这种方法在数组元素分布均匀时特别有效。

# 使用场景

1. 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快。
2. 关键字分布不均匀的情况下，该方法不一定比折半查找要好。

# 比较二分查找和插值查找

为了比较二分查找和插值查找算法在值分布不均匀的情况下的表现，我们可以考虑两种场景：一种是值大部分集中在数组的某一端，另一种是值的分布极其不规则。下面我们分别分析这两种情况。

### 1. 值大部分集中在数组的某一端

假设我们有一个数组，其元素大部分集中在数组的一端。例如，一个数组可能包含很多较小的数和少量极大的数。

- **二分查找**：在这种情况下，二分查找仍然会表现得相当好。二分查找不考虑值的具体分布，只是简单地每次将查找范围减半。因此，即使值的分布不均匀，二分查找也能保持相对稳定的性能。
- **插值查找**：插值查找在这种情况下可能不那么有效。由于它是基于被查找值与数组中最大和最小值之间的比例关系来预测查找位置的，如果大部分值集中在数组的一端，这个预测可能会导致查找位置经常偏离目标值，从而需要更多的查找步骤。

### 2. 值的分布极其不规则

在这种情况下，数组中的值分布极其不规则，没有明显的规律。

- **二分查找**：即使在这种极端情况下，二分查找的表现也是稳定的。它不依赖于值的分布，仅仅依赖于数组的有序性。因此，它的查找效率不会受到值分布不均的影响。
- **插值查找**：对于分布极不规则的数组，插值查找可能表现得很差。**由于它依赖于值的分布来预测查找位置**，如果这个分布非常不均匀或不规则，**算法可能会花费更多时间在数组的错误部分进行查找**。

### 总结

在值分布均匀的情况下，插值查找通常能提供更高的效率，因为它能更准确地预测目标值的位置。然而，当面对值分布不均匀的情况时，二分查找因其稳定性和对分布无依赖性通常是更好的选择。插值查找在这种情况下可能会导致更多的查找步骤和更低的效率。

# 代码实现

```Java
import java.util.Arrays;

public class InsertValueSearch {
    public static void main(String[] args) {
        int[] arr = new int[100];
        for (int i = 0; i < 100; i++) {
            arr[i] = i + 1;
        }

        int index = insertValueSearch(arr, 0, arr.length - 1, 100);
        System.out.println("index = " + index);
    }

    /**
     * 插值查找算法的使用前提是有序数组
     * findVal < arr[0]和findVal > arr[arr.length - 1] 必须需要
     * 否则我们得到的mid可能越界
     * */
    public static int insertValueSearch(int[] arr, int left, int right, int findVal) {
        System.out.println("查找次数"); // 判断查找了多少次
        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]) {
            return -1;
        }
        // 求出mid值，自适应
        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
        if (findVal > midVal) { // 说明应该向右边递归
            return insertValueSearch(arr, mid + 1, right, findVal);
        } else if (findVal < midVal) { // 说明应该向左边递归
            return insertValueSearch(arr, left, mid - 1, findVal);
        } else { // 相等
            return mid; // 找到了就返回下标，找不到就返回-1
        }

    }
}
```