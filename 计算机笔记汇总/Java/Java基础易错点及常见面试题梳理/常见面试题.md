1. 为什么重写 equals 还要重写 hashcode？
2. == 和 equals 比较的区别

```Java
class A{
    public A(String str){
         
    }
}
public class Test{
    public static void main(String[] args) {
        A classa=new A("he");
        A classb=new A("he");
        System.out.println(classa==classb);
    }
}

// 问输出结果是什么？
// false
/**

*/
```

因为== 表示的是否指向的是同一个内存。`System.out.println(classa.equals(classb));`  
如果这这样输出 答案也是错误的因为子类没有覆盖Object 的equals()方法, 而默认调用==的这个方法。  
判断两个对象是否相等需要覆盖equals()方法和hashcaode()方法  

  

1. 为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？
2. final 关键字的作用
    - final修饰变量，则等同于常量
    - final修饰方法中的参数，称为最终参数。
    - final修饰类，则类不能被继承
    - final修饰方法，则方法不能被重写。
    - final 不能修饰抽象类
    - final修饰的方法可以被重载 但不能被重写
    - **重载和重写的区别**:
        - **重载 (Overloading)**
            - 发生在**同一个类**中。
            - 方法名称必须**相同**。
            - 参数列表**必须不同**（可以是参数数量不同、参数类型不同或参数顺序不同）。
            - 返回类型、访问修饰符等可以不同。
            - 在调用时，Java 虚拟机通过参数列表的不同来区分同名的重载方法。
            
        - **重写 (Overriding)**
            - 发生在父类与子类之间。
            - 子类重写父类的方法时，方法名称、参数列表都必须**完全相同**。
            - 返回类型必须是父类被重写方法的返回类型或其子类型。
            - 访问权限不能比父类中被重写的方法更严格。
            - 重写的方法不能抛出新的或更广泛的已检查异常。
            - 使用 `**@Override**` 注解可以告知编译器你打算重写一个父类方法，这样如果你违反了重写的规则，编译器会报错。
            - 如果父类被重写的方法没有使用 `**final**`、`**static**` 修饰符且不是构造方法，子类中的方法才能被重写。
3. 介绍 Java 的集合类
4. ArrayList 和 LinkedList 的区别
5. java 8 有哪些新特性？
6. HashMap 在 jdk 1.7 和 1.8 的区别？