# Setter注入引用类型

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696288082333-fe7ee4a4-e2cd-471c-aa4b-71452ef5ec0c.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696288082333-fe7ee4a4-e2cd-471c-aa4b-71452ef5ec0c.png)

# Setter注入简单类型

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696289699836-b35d2a19-0f75-4d6e-b70f-62ad39f3759a.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696289699836-b35d2a19-0f75-4d6e-b70f-62ad39f3759a.png)

# 构造器注入引用类型

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696290960123-d879566d-c966-4651-a260-d7ffd8dd1e3b.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696290960123-d879566d-c966-4651-a260-d7ffd8dd1e3b.png)

# 构造器注入简单类型

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696291020338-419ef372-1475-4bc8-844a-5dea60b0173b.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696291020338-419ef372-1475-4bc8-844a-5dea60b0173b.png)

### 构造器参数适配

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696291131258-fccf8409-52c9-4ac3-b535-a39197355753.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696291131258-fccf8409-52c9-4ac3-b535-a39197355753.png)

# 方式选择

1. 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现
2. 可选依赖使用setter注入进行，灵活性强
3. Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨
4. 如果有必要可以两者同时使用
5. 如果受控对象没有提供setter方法就必须使用构造器注入
6. **自己开发的模块推荐使用setter注入**

引用类型的依赖注入确实是一种有效的方式，尤其是在某些场景下。通过引用类型的依赖注入，你可以在对象创建后通过公开的 setter 方法或其他途径来注入依赖。

然而，构造器注入与引用类型的依赖注入相比，具有一些优势：

1. **不可变性：** 构造器注入可以使对象的状态在创建后变得不可变。因为一旦对象被构造出来，它的依赖关系就被确定了，后续不能再修改。这有助于提高线程安全性和避免意外的状态变化。
2. **清晰明了：** 构造器注入使得依赖关系在对象的构造过程中就被显式地声明和设置，使代码更加清晰和易于理解。这有助于降低代码的复杂度和提高可读性。
3. **一致性：** 构造器注入在对象创建时就传递了必要的依赖关系，确保对象在使用时处于一致的状态。相比之下，引用类型的依赖注入可能会在对象创建后的某个时刻才进行注入，存在一定的时间窗口。
4. **测试容易：** 构造器注入使得在单元测试中更容易替换依赖的对象。你可以简单地通过传入不同的构造器参数来模拟不同的依赖情境，而无需通过 setter 方法或其他手段来修改对象的状态。

总的来说，选择构造器注入还是引用类型的依赖注入取决于具体的需求和场景。在很多情况下，构造器注入是一个推荐的做法，特别是在追求不可变性、清晰性和一致性的时候。然而，对于某些场景，引用类型的依赖注入也可能更合适。