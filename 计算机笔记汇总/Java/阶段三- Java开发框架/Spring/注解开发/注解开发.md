# 注解开发定义bean

```Java
@Component
public class BookServiceImpl implements BookService {}
```

```Java
@Component("bookDao")
public class BookDaoImpl implements BookDao {}
```

核心配置文件通过组件扫描component

在BookDaoImpl中写了@Component，就代表创建了一个Bean

```XML
<context:component-scan base-package="com.itheima" />
```

# 三个衍生注解

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696460511883-d41ec65e-9b6a-43bf-94c9-502d77061b01.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696460511883-d41ec65e-9b6a-43bf-94c9-502d77061b01.png)

# 三个衍生注解有什么区别

- @Controller:用于定义控制层组件(如MVC中的Controller)
- @Service:用于定义服务层组件(如业务逻辑Service)
- @Repository:用于定义数据层组件(如数据访问DAO)

这些注解的作用都是将类标识为Spring管理的bean,**功能上没有区别**。区分它们的目的是为了让代码更具有语义化,一眼就能看出这个类的角色。

这样可以避免都使用Component时无法区分一个bean是什么角色的问题。但是即便都使用Component也可以正常工作。衍生注解是为了让代码语义化,但最终都会转换成基本的@Component注解,功能上没有区别。

# 纯注解开发

**SpringConfig类替代了Spring核心配置文件 (applicationContext.xml)**

```Java
@Configuration
@ComponentScan("com.itheima")
public class SpringConfig {}
```

**这里面的@Configuration实际就是替代了配置文件中的附带代码。@ComponentScan代表的是第8行的代码**

这里有一个点要注意，如果需要**引入多个component**，那么就**用数组的形式**引入

```Java
@ComponentScan({com.itheima.service}, {com.itheima.dao});
```

**做完上面的部份之后，在App文件中不再使用applicationContext，而是改成**`**AnnotationConfigApplicationContext**`:

加载bean**下面两种方式都是一样的**:

- bookDao
- BookService.class

```Java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);

    BookDao bookDao = (BookDao) ctx.getBean("bookDao");
    System.out.println(bookDao);

    BookService bookService = ctx.getBean(BookService.class);
    System.out.println(bookService);
}
```

**两种方式有什么区别？**

这两种方法的区别在于类型安全性和对Bean名称的依赖。

1. 使用 `getBean(String name)` 方法:

```Java
BookDao bookDao = (BookDao) ctx.getBean("bookDao");
```

这种方法通过 Bean 的名称（在这个例子中是 `"bookDao"`）来获取 Bean。返回的是一个 `Object` 类型，因此需要进行类型转换以匹配 `BookDao` 类型。这种方法的主要**缺点**是它不是类型安全的。如果Bean名称错误或者类型转换不正确，那么在运行时会抛出异常。

1. 使用 `getBean(Class<T> requiredType)` 方法:

```Java
BookService bookService = ctx.getBean(BookService.class);
```

这里直接通过所需类型的类对象来获取 Bean，这是类型安全的方式。这意味着如果 Bean 不存在或者无法转换为指定的类型，编译器可以提前发现这些问题。这种方法还有一个优点是它不依赖于字符串名称，减少了因名称错误而引发的错误。

**在实际开发中，推荐尽可能使用第二种方法**，以提高代码的安全性和可维护性。

# 为什么注解是放在接口的实现类，而不是接口本身上呢？

```Java
public interface BookDao {
    void save();
}
```

```Java
@Repository("bookDao")
public class BookDaoImpl implements BookDao {
    @Override
    public void save() {
        System.out.println("book dao save...");
    }
}
```

@Repository注解在Spring中应该定义在实现类上，而不是直接定义在接口上，主要有以下几个原因：

- **接口是契约，实现类是具体的实现。** 接口定义了对外提供的行为，而实现类负责实现这些行为。@Repository注解的作用是将一个类声明为Spring容器中的Bean，并将其归类为持久层。将@Repository注解定义在接口上，就相当于将接口声明为Spring容器中的Bean，这与接口的定义不符。
- **@Repository注解可以标注实现类，也可以标注接口。** 但是，如果将@Repository注解定义在接口上，那么Spring容器将会扫描所有实现了该接口的类，并将它们都注册为Spring容器中的Bean。这会导致Spring容器中的Bean数量过多，增加了系统的复杂度和维护成本。
- **将@Repository注解定义在接口上，会导致Spring容器无法识别实现类的具体实现。** 这会影响Spring容器对实现类的AOP增强等功能。

在您提供的代码示例中，如果将@Repository注解定义在接口BookDao上，那么Spring容器将会扫描所有实现了BookDao接口的类，并将它们都注册为Spring容器中的Bean。如果存在多个实现类，那么Spring容器将无法识别具体使用哪个实现类。

如果将@Repository注解定义在BookDaoImpl类上，那么Spring容器将只会扫描BookDaoImpl类，并将其注册为Spring容器中的Bean。这符合Spring的设计理念，也符合实际的开发需求。

# Bean管理

[Bean管理](https://www.yuque.com/chuangshiji-poapl/epb8vm/paoif4ta936368x1)

# 依赖自动装配

[Autowired依赖自动装配](https://www.yuque.com/chuangshiji-poapl/epb8vm/kh3dtg1q5i28og2u)

# 值类型注入

[值类型注入](https://www.yuque.com/chuangshiji-poapl/epb8vm/pgg6p3nl4s6eyfst)

# 外部Property配置文件注入

[外部Property配置文件注入](https://www.yuque.com/chuangshiji-poapl/epb8vm/aaha2c6nivbw8af5)

# 第三方Bean管理

[第三方Bean管理](https://www.yuque.com/chuangshiji-poapl/epb8vm/yy4o9f0k2c40ipw0)

  

[[Bean管理]]

[[Autowired依赖自动装配]]

[[值类型注入]]

[[外部Property配置文件注入]]

[[第三方bean管理]]