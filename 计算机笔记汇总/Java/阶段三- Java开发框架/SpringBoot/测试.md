# 加载测试专用属性

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1701945226142-c0d64733-af8b-44db-8f8d-a0aec37c1030.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1701945226142-c0d64733-af8b-44db-8f8d-a0aec37c1030.png)

仅对当前测试类有效

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1701945269350-8412a5b0-3d4f-4ed8-bcf1-3eb68de89423.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1701945269350-8412a5b0-3d4f-4ed8-bcf1-3eb68de89423.png)

这个是源码级的，可以在其他软件或者设备上运行可以保留下来，而不是在 idea 内部 edit configuration 之后，换了 idea (设备), 配置就没有了。这样就可以跨设备、软件都能运行。

# 加载测试专用配置

上面是加载了项目的配置，但是如果想要加载自定义的Bean如何实现呢？比如说像自定义了MP的拦截器。

使用@Import注解加载当前测试类专用的配置

```Java
@Configuration
public class MsgConfig {
    @Bean
    public String msg(){
        return "bean msg";
    }
}
```

```Java
@SpringBootTest
@Import(MsgConfig.class)
public class ConfigurationTest {
    @Autowired
    private String msg;

    @Test
    void testConfiguration() {
        System.out.println(msg);
    }
}
```

# Web环境模拟测试

主要包括三个步骤

- 设置测试端口
- 模拟测试启动
- 模拟测试匹配 (各组成部分信息均可匹配)

# 模拟Web的测试环境

```Java
package com.itheima;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
public class WebTest {
    @Test
    void test() {}
}
```

这里SpringBootTest.WebEnvironment后面的选项有4种选择

# 虚拟请求测试

先定义controller这个表现层

```Java
@RestController
@RequestMapping("/books")
public class BookController {
    @GetMapping
    public String getById(){
        System.out.println("getbyid is running");
        return "springboot";
    }
}
```

然后模拟虚拟请求

```Java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
// 开启MVC虚拟调用
@AutoConfigureMockMvc
public class WebTest {
    @Autowired
    private MockMvc mvc;

    @Test
    void test() {}

    @Test
    void testWeb() throws Exception {
        // http://localhost:8080/books
        // 创建虚拟请求，当前访问的是/books
        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");
        // 然后执行对应的请求
        mvc.perform(builder);
    }
}
```

接下来就是验证当前的运行结果和预期值之间是不是真的匹配

# 虚拟请求状态匹配

```Java
@Test
void testStatus() throws Exception {
    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");
    ResultActions action = mvc.perform(builder);

    // 设定预期值，与真实值进行比较，成功测试通过，失败测试失败
    // 定义本次调用的预期值
    StatusResultMatchers status = MockMvcResultMatchers.status();
    // 预计本次调用成功的: 状态200
    ResultMatcher ok = status.isOk();

    // 使用本次真实执行结果与预期结果进行比对
    action.andExpect(ok);
}
```

# 虚拟请求体匹配

```Java
/**
     * 如果想验证是否失败，就更改/books这里，改成/books1即可
     * 目标: 匹配执行结果 (是否为预期值)。设定预期值，与真实值进行比较，成功 测试通过，失败 测试失败
     * */
@Test
void testBody() throws Exception {
    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");
    ResultActions action = mvc.perform(builder); // 实际值

    // 定义执行结果匹配器
    ContentResultMatchers content = MockMvcResultMatchers.content();
    // 定义预期执行结果
    // 这里是查看预期值的请求体的内容是否与实际值匹配。在BookController里返回的是Springboot
    ResultMatcher result = content.string("springboot");

    // 使用本次真实执行结果与预期结果进行比对
    action.andExpect(result);
}
```

### 虚拟请求体 (json)

```Java
@Test
void testJson() throws Exception {
    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");
    ResultActions action = mvc.perform(builder); // 实际值

    // 定义执行结果匹配器
    ContentResultMatchers content = MockMvcResultMatchers.content();
    // 定义预期执行结果
    ResultMatcher json = content.json("{\"id\":1,\"name\":\"Spring Boot\",\"type\":\"IT\",\"description\":\"SpringBoot开发\"}");

    // 使用本次真实执行结果与预期结果进行比对
    action.andExpect(json);
}
```

# 虚拟请求头匹配

```Java
@Test
void testContetType() throws Exception {
    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");
    ResultActions action = mvc.perform(builder); // 实际值

    HeaderResultMatchers header = MockMvcResultMatchers.header();
    ResultMatcher contentType = header.string("Content-Type", "application/json");

    action.andExpect(contentType);
}
```

# 数据层测试回滚

为测试用例添加事务，SpringBoot就会对测试用例对应的事务提交操作进行回滚。

需要这样做的原因是因为在做测试的时候，不希望测试数据这种脏数据添加到DB中，那么开启事务之后，SpringBoot就会控制事务 不进行测试数据的commit这个操作，也就不会添加测试数据到数据库中了。

使用`@Transactional`来实现这个目标

```Java
@SpringBootTest
@Transactional
public class ServiceTest {
    @Autowired
    private BookService bookService;

    @Test
    void testSave() {
        Book book = new Book();
        book.setName("Spring Boot2");
        book.setType("IT2");
        book.setDescription("SpringBoot开发2");

        bookService.save(book);
    }
}
```

这里其实是隐藏了一个注解就是`@Rollback`。这个注解的参数默认是true，也就是支持回滚。可以自己**设置成false**，那么就**相当于没有开启事务**，那么**数据就会正常提交到DB中**。

```Java
@SpringBootTest
@Transactional
@Rollback(false)
public class ServiceTest {
    @Autowired
    private BookService bookService;

    @Test
    void testSave() {
        Book book = new Book();
        book.setName("Spring Boot2");
        book.setType("IT2");
        book.setDescription("SpringBoot开发2");

        bookService.save(book);
    }
}
```

# 测试用例数据设定

想上面这样直接在测试用例中写死数据不是一个很好的做法，所以通常采用随机值进行测试，使用SpringBoot提供的随机数为其赋值

```YAML
testcase:
  book:
    id: ${random.int}
    id2: ${random.int(10)}
    id3: ${random.int(5,10)}
    name: 后端${random.value}
    uuid: ${random.uuid}
    publishTime: ${random.long}
```