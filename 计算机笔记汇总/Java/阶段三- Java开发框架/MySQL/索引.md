# 什么是索引

索引是在表中的字段上添加的，为了提高查询效率存在的一种机制。

在MySQL中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引中，索引存储在一个.MXI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace当中。

# **索引的原理**

- 没有索引为什么查询会慢？因为没有索引的查询是全表扫描。
- 使用索引为什么查询会快？形成一个索引的数据结构，比如二叉树。索引通过使用二叉树的结构就可以快速找到目标字段 (节点), 缩小扫描范围，快速定位。
- 索引的代价:
- 磁盘占用
- 对update、delete、insert语句的效率影响
- 建议不要随意添加索引，因为索引也是需要维护的，太多的话降低系统性能。建议通过主键查询，建议通过unique

## 哪些关键词会默认加索引？

在MySQL中,有以下几种情况下会自动或默认为某些字段或关键字添加索引:

1. **PRIMARY KEY(主键)**主键约束自动添加唯一索引,用于保证主键值的唯一性和快速查找。
2. **UNIQUE KEY(唯一键约束)**唯一键约束会自动添加唯一索引,确保该字段的值不重复出现。
3. **AUTO_INCREMENT(自增字段)**设置为AUTO_INCREMENT的字段会默认创建一个非唯一索引,用于加速按主键顺序插入新记录。
4. **FOREIGN KEY(外键约束)**外键约束会在参考字段(子表字段)上添加索引,加快外键检查的速度。
5. **ADD FULLTEXT(全文索引)**为char、varchar和text字段类型的列添加全文索引,用于全文搜索。
6. **ADD SPATIAL(空间索引)**为存储地理数据的字段创建空间索引,用于空间数据的检索。
7. **CLUSTER(聚簇索引)**InnoDB引擎使用聚簇索引对数据进行存放,其中主键就是聚簇索引。没有主键时InnoDB会使用第一个唯一非空索引代替。

# 索引的结构

MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。在没有了解B+Tree结构前，我们先回顾下之前所学习的树结构：

二叉查找树：左边的子节点比父节点小，右边的子节点比父节点大

当我们向二叉查找树保存数据时，是按照从大到小(或从小到大)的顺序保存的，此时就会形成一个单向链表，搜索性能会打折扣。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712368365620-935469d0-c2e4-4625-9f52-48d87d8d09c8.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712368365620-935469d0-c2e4-4625-9f52-48d87d8d09c8.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712368368333-c18b6c3b-5a95-4bba-9888-cd216daa8d2c.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712368368333-c18b6c3b-5a95-4bba-9888-cd216daa8d2c.png)

可以选择平衡二叉树或者是红黑树来解决上述问题。（红黑树也是一棵平衡的二叉树）

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712368385868-9bb87493-5f4b-4e05-8a52-9efdac938f5a.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712368385868-9bb87493-5f4b-4e05-8a52-9efdac938f5a.png)

思考：采用二叉搜索树或者是红黑树来作为索引的结构有什么问题？

- 最大的问题就是在**数据量大**的情况下，**树的层级比较深**，会**影响检索速度**。因为不管是二叉搜索数还是红黑数，一个节点下面只能有两个子节点。此时在数据量大的情况下，就会**造成树的高度比较高**，树的高度一旦高了，**检索速度就会降低**。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712368565238-04ba0cb8-1b18-473c-bd2b-c0e4273df6fb.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712368565238-04ba0cb8-1b18-473c-bd2b-c0e4273df6fb.png)

## B+树

B+Tree结构：

- 每一个节点，可以存储多个key（有n个key，就有n个指针）
- 节点分为：叶子节点、非叶子节点
- 叶子节点，就是最后一层子节点，所有的数据都存储在叶子节点上
- 非叶子节点，不是树结构最下面的节点，用于索引数据，存储的的是：key+指针
- 为了提高范围查询效率，叶子节点形成了一个双向链表，便于数据的排序及区间范围查询

# 索引的语法

## **创建索引**

### 使用create index添加索引

`create [ unique ] index 索引名 on 表名 (字段名,... ) ;`

案例：为tb_emp表的name字段建立一个索引

`create index idx_emp_name on tb_emp(name);`

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712373176383-acbda340-80f3-4700-9595-7977cb214230.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712373176383-acbda340-80f3-4700-9595-7977cb214230.png)

### 使用unique关键字添加索引

在MySQL中，当你**在一个字段上定义了**`**UNIQUE**`**约束**，**数据库会自动为该字段创建一个索引**。这样做的**目的是为了保证字段值的唯一性，提高查询效率，并优化数据的存储**。

`UNIQUE`约束用于确保表中的所有记录在该字段上的值都是不同的，不允许有重复。为了维护这一约束，MySQL需要一种机制来快速检查新插入或更新的数据是否违反了唯一性规则。通过为`UNIQUE`字段创建索引，数据库可以高效地执行这种检查，因为索引提供了快速查找和比较数据的手段。

```SQL
CREATE TABLE example (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    UNIQUE (username)
);
```

在这个例子中，`username`字段被定义为`UNIQUE`。MySQL会自动为`username`字段创建一个索引，以确保可以快速验证新记录的`username`值是否唯一。

```SQL
SHOW INDEX FROM example;
```

执行这个命令后，你将看到`example`表的所有索引列表，其中应该包括为`username`字段创建的`UNIQUE`索引。这个索引通常是一个BTREE类型的索引，适用于处理等值查询和范围查询。

## **查看索引**

`show index from 表名;`

案例：查询 tb_emp 表的索引信息

`show index from tb_emp;`

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712374048605-682676ac-71e0-4fb4-9e1d-208a7dfc1ca9.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1712374048605-682676ac-71e0-4fb4-9e1d-208a7dfc1ca9.png)

## **删除索引**

`drop index 索引名 on 表名;`

案例：删除 tb_emp 表中name字段的索引

`drop index idx_emp_name on tb_emp;`

注意事项：

- 主键字段，在建表时，会自动创建主键索引
- 添加唯一约束时，数据库实际上会添加唯一索引

# 哪些列上适合使用索引？

在数据库中**加索引是一个重要的性能优化手段**，但同时也**需要谨慎处理**，因为**不恰当的索引可能会导致性能下降**。以下是一些判断应该在哪些字段上加索引的指导原则：

1. **频繁作为查询条件的字段**：如果某个字段经常用于`WHERE`子句中，为该字段创建索引可以加快查询速度。例如，经常根据用户名、邮箱地址或ID来查询用户信息时，这些字段就是良好的索引候选。
2. **参与联接操作的字段**：在多表联接查询中，联接条件中涉及的字段也适合创建索引，这样可以加快联接操作的速度。
3. **经常用于排序的字段**：当一个字段经常用于`ORDER BY`子句中时，为其创建索引可以提高排序操作的效率。
4. **在分组和聚合操作中使用的字段**：如果一个字段经常用于`GROUP BY`子句或聚合函数（如`COUNT`、`SUM`等）中，为其创建索引可以加快分组和计算的速度。
5. **经常用于搜索的字段**：对于全文搜索或模糊搜索，可以使用特定的全文索引引擎，如MySQL的InnoDB存储引擎支持全文索引。
6. **多字段组合查询**：如果经常有查询涉及到多个字段的组合，可以考虑创建一个组合索引（多列索引），这样可以提高这类查询的效率。
7. **考虑查询的写入比例**：如果一个表主要是只读的，那么增加索引可以提高查询性能。但如果表的写入操作非常频繁，那么索引的维护成本可能会成为问题，因为每次插入、更新或删除操作都可能需要更新索引。
8. **考虑数据的分布和选择性**：如果字段中的值非常集中（如性别字段只有“男”和“女”两个值），索引可能不会带来太大的性能提升，因为选择性不高。选择性高的字段（即值分布广泛的字段）更适合创建索引。
9. **监控查询性能**：使用慢查询日志和性能分析工具来监控和分析查询性能，找出瓶颈，并根据这些信息来决定是否需要加索引。
10. **测试和评估**：在实际创建索引之前，可以在测试环境中模拟查询操作，并评估加索引前后的性能变化。这有助于做出更加合理的决策。

# 索引失效

索引什么时候失效？

- 失效的第一种情况
- select * from emp where ename like ‘%T’;
- ename上即使添加了索引，也不会走索引，为什么？
- 原因是因为模糊匹配当中以“%”开头了！因为查找的时候不知道第一个字母是什么，一味只有知道了，才能进行比对。
- 尽量避免模糊查询的时候以“%”开始。
- 失效的第二种情况
- 使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有索引，才会走索引。如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效。
- explain select * from emp where ename = ‘KING’ or job = ‘MANAGER’
- 这个例子里面因为ename上面有索引，但是job上面没有索引，所以如果想要使用索引，可以将ename = ‘KING’包含前面的语句当作一个独立的sql语句，然后使用union连接搜索job = ‘MANAGER’
- 失效的第三种情况
- 使用复合索引的时候，没有使用**左侧的列查找**，索引失效。
- 什么是复合索引？
- 两个字段，或者更多的字段联合起来添加一个索引
- create index emp_job sal_index on emp(job, sal);select * from emp where job = ‘MANAGER’; 这种是索引生效的explain select * from emp where sal = 800; 这种是索引失效的，因为sal是右边的列。
- 失效的第四种情况
- 在where当中索引列参加了运算，索引失效
- create index emp_sal_index on emp(sal);
- explain select * from emp where sal = 800;
- explain select * from emp where sal + 1 = 800;这种就会出现索引失效
- 失效的第5种情况
- 在where当中索引列使用了函数

# 索引的分类

- 单一索引
- 复合索引
- 主键索引
- 唯一性索引
- 普通索引
- 全文索引