# 代码生成器

[baomidou.com/pages/779a6...](https://baomidou.com/pages/779a6e/#%E9%85%8D%E7%BD%AE)

MyBatis Plus 是一个持久层框架，提供了代码生成器来帮助开发人员快速生成 Entity、Mapper、Mapper XML、Service、Controller 等模块的代码。根据搜索结果，MyBatis Plus 的代码生成器有新旧两种方式，新版支持两套生成方式，一套使用 SQL 查询的方式，另一套使用驱动规范来读取元数据的方式。推荐使用新的元数据查询方式来生成代码。你可以通过配置数据源、全局配置、包配置、模板配置等来定制生成代码的行为和结果。官方文档中提供了详细的配置说明和示例[1][2][3]。

在使用MybatisPlus以后，基础的`Mapper`、`Service`、`PO`代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成`PO`、`Mapper`、`Service`等相关代码。只不过代码生成器同样要编码使用，也很麻烦。

## 使用

刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。首先需要配置数据库地址，在Idea顶部菜单中，找到 `other`，选择 `Config Database`：

![[Pasted image 20240428091806.png]]

在弹出的窗口中填写数据库连接的基本信息：

![[Pasted image 20240428091819.png|400]]

点击OK保存。

然后再次点击Idea顶部菜单中的other，然后选择 `Code Generator`:

![[Pasted image 20240428093017.png]]

在弹出的表单中填写信息：

![[Pasted image 20240428093027.png]]

最终，代码自动生成到指定的位置了。

# 静态工具

有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：`Db`，其中的一些静态方法与 `IService` 中方法签名基本一致，也可以帮助我们实现CRUD功能：

![[Pasted image 20240428093111.png]]

示例：

```Java
@Test
void testDbGet() {
    User user = Db.getById(1L, User.class);
    System.out.println(user);
}

@Test
void testDbList() {
    // 利用Db实现复杂条件查询
    List<User> list = Db.lambdaQuery(User.class)
            .like(User::getUsername, "o")
            .ge(User::getBalance, 1000)
            .list();
    list.forEach(System.out::println);
}

@Test
void testDbUpdate() {
    Db.lambdaUpdate(User.class)
            .set(User::getBalance, 2000)
            .eq(User::getUsername, "Rose");
}
```

需求：改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表

首先，我们要添加一个收货地址的VO对象：

```Java
package com.itheima.mp.domain.vo;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = "收货地址VO")
public class AddressVO{

    @ApiModelProperty("id")
    private Long id;

    @ApiModelProperty("用户ID")
    private Long userId;

    @ApiModelProperty("省")
    private String province;

    @ApiModelProperty("市")
    private String city;

    @ApiModelProperty("县/区")
    private String town;

    @ApiModelProperty("手机")
    private String mobile;

    @ApiModelProperty("详细地址")
    private String street;

    @ApiModelProperty("联系人")
    private String contact;

    @ApiModelProperty("是否是默认 1默认 0否")
    private Boolean isDefault;

    @ApiModelProperty("备注")
    private String notes;
}
```

然后，改造原来的UserVO，添加一个地址属性：

# 逻辑删除

对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：
- 在表中添加一个字段标记数据是否被删除
- 当删除数据时把标记置为true
- 查询时过滤掉标记为true的数据
一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。

为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。

**注意**，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。

例如，我们给`address`表添加一个逻辑删除字段：

```SQL
alter table address add deleted bit default b'0' null comment '逻辑删除';
```

然后给 `Address` 实体添加 `deleted` 字段：

![[Pasted image 20240428165013.png|450]]

接下来，我们要在`application.yml`中配置逻辑删除字段：

```YAML
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
      logic-delete-value: 1 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
```

测试： 首先，我们执行一个删除操作：

```Java
@Test
void testDeleteByLogic() {
    // 删除方法与以前没有区别
    addressService.removeById(59L);
}
```

方法与普通删除一模一样，但是底层的SQL逻辑变了：

![[Pasted image 20240428165034.png]]

查询一下试试：

```Java
@Test
void testQuery() {
    List<Address> list = addressService.list();
    list.forEach(System.out::println);
}
```

会发现id为59的确实没有查询出来，而且SQL中也对逻辑删除字段做了判断：

![[Pasted image 20240428165047.png]]

综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。

**注意**： 逻辑删除本身也有自己的问题，比如：
- 会导致数据库表垃圾数据越来越多，从而影响查询效率
- SQL中全都需要对逻辑删除字段做判断，影响查询效率

因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。


# 通用枚举



# JSON 类型处理器



# 配置加密



