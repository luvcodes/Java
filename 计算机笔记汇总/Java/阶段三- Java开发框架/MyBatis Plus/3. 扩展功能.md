# 代码生成器

[baomidou.com/pages/779a6...](https://baomidou.com/pages/779a6e/#%E9%85%8D%E7%BD%AE)

MyBatis Plus 是一个持久层框架，提供了代码生成器来帮助开发人员快速生成 Entity、Mapper、Mapper XML、Service、Controller 等模块的代码。根据搜索结果，MyBatis Plus 的代码生成器有新旧两种方式，新版支持两套生成方式，一套使用 SQL 查询的方式，另一套使用驱动规范来读取元数据的方式。推荐使用新的元数据查询方式来生成代码。你可以通过配置数据源、全局配置、包配置、模板配置等来定制生成代码的行为和结果。官方文档中提供了详细的配置说明和示例[1][2][3]。

在使用MybatisPlus以后，基础的`Mapper`、`Service`、`PO`代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成`PO`、`Mapper`、`Service`等相关代码。只不过代码生成器同样要编码使用，也很麻烦。

## 使用

刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。首先需要配置数据库地址，在Idea顶部菜单中，找到 `other`，选择 `Config Database`：

![[Pasted image 20240428091806.png]]

在弹出的窗口中填写数据库连接的基本信息：

![[Pasted image 20240428091819.png|400]]

点击OK保存。

然后再次点击Idea顶部菜单中的other，然后选择 `Code Generator`:

![[Pasted image 20240428093017.png]]

在弹出的表单中填写信息：

![[Pasted image 20240428093027.png]]

最终，代码自动生成到指定的位置了。

# 静态工具

有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：`Db`，其中的一些静态方法与 `IService` 中方法签名基本一致，也可以帮助我们实现CRUD功能：

![[Pasted image 20240428093111.png]]

示例：

```Java
@Test
void testDbGet() {
    User user = Db.getById(1L, User.class);
    System.out.println(user);
}

@Test
void testDbList() {
    // 利用Db实现复杂条件查询
    List<User> list = Db.lambdaQuery(User.class)
            .like(User::getUsername, "o")
            .ge(User::getBalance, 1000)
            .list();
    list.forEach(System.out::println);
}

@Test
void testDbUpdate() {
    Db.lambdaUpdate(User.class)
            .set(User::getBalance, 2000)
            .eq(User::getUsername, "Rose");
}
```

需求：改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表

首先，我们要添加一个收货地址的VO对象：

```Java
package com.itheima.mp.domain.vo;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = "收货地址VO")
public class AddressVO{

    @ApiModelProperty("id")
    private Long id;

    @ApiModelProperty("用户ID")
    private Long userId;

    @ApiModelProperty("省")
    private String province;

    @ApiModelProperty("市")
    private String city;

    @ApiModelProperty("县/区")
    private String town;

    @ApiModelProperty("手机")
    private String mobile;

    @ApiModelProperty("详细地址")
    private String street;

    @ApiModelProperty("联系人")
    private String contact;

    @ApiModelProperty("是否是默认 1默认 0否")
    private Boolean isDefault;

    @ApiModelProperty("备注")
    private String notes;
}
```

然后，改造原来的UserVO，添加一个地址属性：

# 逻辑删除

对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：
- 在表中添加一个字段标记数据是否被删除
- 当删除数据时把标记置为true
- 查询时过滤掉标记为true的数据
一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。

为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。

**注意**，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。

例如，我们给`address`表添加一个逻辑删除字段：

```SQL
alter table address add deleted bit default b'0' null comment '逻辑删除';
```

然后给 `Address` 实体添加 `deleted` 字段：

![[Pasted image 20240428165013.png|450]]

接下来，我们要在`application.yml`中配置逻辑删除字段：

```YAML
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
      logic-delete-value: 1 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
```

测试： 首先，我们执行一个删除操作：

```Java
@Test
void testDeleteByLogic() {
    // 删除方法与以前没有区别
    addressService.removeById(59L);
}
```

方法与普通删除一模一样，但是底层的SQL逻辑变了：

![[Pasted image 20240428165034.png]]

查询一下试试：

```Java
@Test
void testQuery() {
    List<Address> list = addressService.list();
    list.forEach(System.out::println);
}
```

会发现id为59的确实没有查询出来，而且SQL中也对逻辑删除字段做了判断：

![[Pasted image 20240428165047.png]]

综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。

**注意**： 逻辑删除本身也有自己的问题，比如：
- 会导致数据库表垃圾数据越来越多，从而影响查询效率
- SQL中全都需要对逻辑删除字段做判断，影响查询效率

因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。


# 通用枚举

User类中有一个用户状态字段：

![[Pasted image 20240429094619.png|375]]

像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是`int`类型，对应的PO也是`Integer`。因此业务操作时必须手动把`枚举`与`Integer`转换，非常麻烦。

因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们**把枚举类型与数据库类型自动转换**。

## 定义枚举

我们定义一个用户状态的枚举：

![[Pasted image 20240429094652.png|500]]

代码如下：

```Java
package com.itheima.mp.enums;

import com.baomidou.mybatisplus.annotation.EnumValue;
import lombok.Getter;

@Getter
public enum UserStatus {
    NORMAL(1, "正常"),
    FREEZE(2, "冻结")
    ;
    private final int value;
    private final String desc;

    UserStatus(int value, String desc) {
        this.value = value;
        this.desc = desc;
    }
}
```

然后把 `User` 类中的 `status` 字段改为 `UserStatus` 类型：

![[Pasted image 20240429094727.png|475]]

要让 `MybatisPlus` 处理枚举与数据库类型自动转换，我们必须告诉 `MybatisPlus`，枚举中的哪个字段的值作为数据库值。 `MybatisPlus` 提供了 `@EnumValue` 注解来标记枚举属性：

![[Pasted image 20240429094800.png|500]]

## 配置枚举处理器

在application.yaml文件中添加配置：

```YAML
mybatis-plus:
  configuration:
    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
```

## 测试

```Java
@Test
void testService() {
    List<User> list = userService.list();
    list.forEach(System.out::println);
}
```

最终，查询出的 `User` 类的 `status` 字段会是枚举类型：

![[Pasted image 20240429094838.png|450]]

同时，为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性：

![[Pasted image 20240429094856.png|575]]

并且，在UserStatus枚举中通过 `@JsonValue` 注解标记JSON序列化时展示的字段：

![[Pasted image 20240429094921.png|575]]

最后，在页面查询，结果如下：

![[Pasted image 20240429094941.png|575]]

# JSON 类型处理器

数据库的user表中有一个 `info` 字段，是JSON类型：

![[Pasted image 20240429095022.png]]

格式像这样：

```JSON
{"age": 20, "intro": "佛系青年", "gender": "male"}
```

而目前 `User` 实体类中却是 `String` 类型：

![[Pasted image 20240429095041.png|475]]

这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个`Map`或者实体类。

而一旦我们把`info`改为`对象`类型，就需要在写入数据库时手动转为`String`，再读取数据库时，手动转换为`对象`，这会非常麻烦。

因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用`JacksonTypeHandler`处理器。

接下来，我们就来看看这个处理器该如何使用。

## 

# 配置加密



