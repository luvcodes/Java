
# 常用注解总结

## @TableField 注解

```Java
@TableField(value = "pwd", exist = true)
private String password;
```

在 MyBatis-Plus 中，@TableField 注解用于**指定实体类属性与数据库表中列的映射关系**。这个注解在实体类的字段上使用，以告诉 MyBatis-Plus 如何将该字段映射到数据库表的特定列。

这行代码中的注解 @TableField 有两个参数：`value` 和 `exist`。
1. Value:
    - Value = "pwd" 表示该实体类属性 password 映射到数据库表中名为 "pwd" 的列。这是当实体类的**字段名称与数据库表中的列名称不一致**时非常有用的。在这个例子中，即使 Java 实体类中的属性名为 password，MyBatis-Plus 会将它映射到数据库表中的 pwd 列。
2. Exist:
    - `exist = true` **指示这个字段在数据库表中确实存在**。这个参数通常用于告知 MyBatis-Plus 这个字段是否是数据库表的一个列。
    - 如果设置为 false，则 MyBatis-Plus 在构建 SQL 语句时不会包含这个字段。通常，如果字段确实**存在于数据库表中**，你**可以不设置** exist 参数，因为**默认值就是 true**。

### 表字段与编码属性设计不同步
![[Untitled 12.png]]

解决方法:
![[Untitled 1 4.png]]

### `exist=""` 编码中添加了数据库中未定义的属性

![[Untitled 2 5.png]]
解决方法:

![[Untitled 3 4.png]]

### `exist=false` 采用默认查询开放了更多的字段查看权限

![[Untitled 4 2.png]]

![[Untitled 5 2.png]]

### 什么情况下把 exist 设置为 false？

在实际应用中，将 @TableField (exist = false) 用于一个实体类字段的情况通常出现在以下几种场景：

1. 计算属性:
    - 假设你有一个实体类 Employee，其中包含两个字段：firstName 和 lastName。你可能想要在应用中使用一个完整的姓名，但数据库中并没有这样一个列。你可以在实体类中添加一个不映射到数据库的计算属性 fullName，并用 @TableField (exist = false) 标注：
        
        ```Java
        @TableField(exist = false)
        private String fullName;
        
        public String getFullName() {
            return firstName + " " + lastName;
        }
        ```
        
2. 临时存储:
    - 如果你需要在实体类中临时存储一些数据，这些数据用于应用的逻辑处理，但不需要持久化到数据库中。例如，一个 Order 实体可能需要存储一个临时的折扣率，用于计算订单总额：
        
        ```Java
        @TableField(exist = false)
        private BigDecimal temporaryDiscount;
        ```
        
3. DTO (Data Transfer Object) 混用:
    - 有时，为了简便，可能会在实体类中混用一些 DTO（数据传输对象）特有的字段。这些字段可能只在特定的业务逻辑或 API 传输中有用，而不需要映射到数据库的任何列。
4. 安全或权限字段:
    - 在某些情况下，你可能不希望将某些敏感信息或基于权限的字段持久化到数据库，但这些信息在业务逻辑中是必需的。例如，用户的某些权限标记可能只在运行时进行检查，而不存储在数据库中。

在所有这些情况下，@TableField (exist = false) 告诉 MyBatis-Plus，即使这个字段存在于实体类中，也不应将其视为数据库表的一部分。因此，在生成 SQL 语句时，MyBatis-Plus 会忽略这些字段。这使得实体类可以灵活地包含非数据库字段，用于满足应用程序的特定需求。

### `select=false` - 不查询特定的字段

`select = false` 参数在这个注解中的作用是指明在执行查询操作时，默认不会选择（即不查询）这个特定的字段。
这意味着当你使用 MyBatis Plus 的通用方法（如 selectById、selectList 等）来执行查询时，标有 `@TableField(select = false)` 的字段不会被包含在生成的 SQL 语句的 SELECT 部分中。

例如，考虑以下实体类属性：

```Java
@TableField(value = "pwd", select = false)
private String password;
```

这里，value = "pwd" 表示实体类的 password 属性映射到数据库表中的 pwd 字段。Select = false 指定在查询时不包括 pwd 字段，所以即使数据库表中 pwd 字段有值，使用 MyBatis Plus 的查询方法返回的实体对象中 password 属性也会是 null。

使用 select = false 的场景包括但不限于：

- 提高性能：如果某个字段很大（例如，一个大文本字段或 BLOB），在列表查询时排除这个字段可以提高查询效率。
- 安全性：对于一些敏感信息，如密码、个人信息等，在通用查询中默认不返回这些字段可以提高应用程序的安全性。

如果需要查询这些字段，你需要使用自定义查询方法，并显式指定包含这些字段的 SQL 语句。

## @TableName 注解

在 MyBatis-Plus 中，@TableName 注解用于**指定一个实体类与数据库中对应表的关系**。通过这个注解，你可以明确告诉 MyBatis-Plus 实体类应该映射到哪个数据库表。这在实体类的名称与数据库表名不直接对应的情况下尤其有用。

```Java
@TableName("tbl_user")
public class User {}
```

`@TableName("tbl_user")` 表明了这个实体类 User 应该映射到数据库中名为 tbl_user 的表。这意味着当你对 User 实体进行数据库操作时（如查询、插入、更新、删除），MyBatis-Plus 会自动将这些操作映射到 tbl_user 表。当使用 MyBatis-Plus 提供的方法（如 userMapper.Insert (user)）插入一个 User 实例时，实际上是在数据库的 tbl_user 表中插入一行数据。

这个注解非常有用，因为它允许 Java 实体类名与数据库表名不完全一致，从而可以遵循各自的命名习惯。


![[Untitled 6 2.png]]

![[Untitled 7 2.png]]

## @TableId
用来指定表中的主键字段信息。`@TableId` 是 MyBatis Plus（一个增强 MyBatis 的框架）中的一个注解，用于指定一个实体类属性为数据库表的主键字段。这个注解非常重要，因为它**帮助 MyBatis Plus 识别并正确处理数据库表的主键**。

### 使用方式

`@TableId` 可以**放在实体类的属性上**，**标记该属性为数据库表的主键列**。它主要有两个参数：`value` 和 `type`。

- **value**: 指定映射到数据库表的主键列名。如果实体属性名与表中主键列名相同，可以省略这个参数。
- **type**: 指定主键生成策略，是一个枚举 `IdType`。常用的类型包括：
  - `AUTO`（默认）: 数据库 ID 自增
  - `NONE`: 无状态，该类型为未设置主键 ID
  - `INPUT`: 需要手动输入
  - `ASSIGN_ID`: 分配 ID（主键类型为数字类型或其包装类）
  - `ASSIGN_UUID`: 分配全局唯一标识（主键类型为字符串）

### 示例

下面是一个简单的示例，展示如何在实体类中使用 `@TableId` 注解：

```java
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

@TableName("user")
public class User {
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;
    private String name;
    private Integer age;
    
    // getters and setters
}
```

在这个例子中，我们有一个名为 `User` 的实体类，它映射到数据库中的 `user` 表。`id` 属性被标记为主键，并且使用数据库自增的方式生成。

### 主键策略的选择

选择哪种主键策略取决于具体的应用需求和数据库设计：
- 如果你的表设计允许数据库自动管理主键（如自增主键），可以选择 `IdType.AUTO`。
- 如果希望应用程序中生成 ID（如使用 UUID 或某种算法生成 ID），则可以选择 `IdType.INPUT` 或其他适合的类型，并在插入数据前设置实体的 ID 值。

`@TableId` 通过这种方式减少了配置和代码的复杂性，使得 MyBatis Plus 在操作数据库时更加高效和简洁。

## Id 生成策略控制

![[Untitled 8 2.png]]

这里面所有的 TableName 和 IdType 都可以提取出来

![[Untitled 9 2.png]]

转换成全局配置

![[Untitled 10 2.png]]

在 MyBatis Plus 中，@TableId 注解用于标识实体类的属性映射到数据库表的主键字段。Type 属性用于指定主键的生成策略。您的代码段中展示了三种不同的主键生成策略的注释示例，但没有明确启用任何一种。下面是对这三种主键生成策略的简要说明：

1. IdType. AUTO：
    - 自增主键。数据库会自动为新插入的记录生成一个唯一的主键值，通常是数字类型并且每次递增。这要求数据库表的主键列被设置为自增（AUTO_INCREMENT）。
    - 示例：@TableId (type = IdType. AUTO)
2. IdType. INPUT：
    - 手动输入。这意味着在插入数据时，主键的值需要你在应用层面提供，MyBatis Plus 不会自动生成它。
    - 示例：@TableId (type = IdType. INPUT)
3. IdType. ASSIGN_ID：
    - 分配 ID（默认策略）。当实体的主键类型为 Long 或 String 时，如果没有指定主键的值，MyBatis Plus 会使用雪花算法（Snowflake）或 UUID 生成一个主键值。这适用于分布式系统中生成唯一标识符的场景。
    - 示例：@TableId (type = IdType. ASSIGN_ID)

要激活其中一种策略，你需要取消对应行的注释，并确保你的实体类中只有一个字段使用了 @TableId 注解，因为每个实体类只能有一个主键字段。选择哪种主键生成策略取决于你的具体需求和数据库表的配置。

例如，如果你希望数据库自动为每条新记录分配一个唯一的数字 ID，你可以使用 IdType. AUTO。如果你的应用或服务生成了主键值，并希望直接插入这个值，那么 IdType. INPUT 会是合适的选择。对于分布式系统，IdType. ASSIGN_ID 可以自动生成一个全局唯一的 ID，无需依赖数据库的特定特性。

# 常见配置

MyBatisPlus 的配置项继承了 MyBatis 原生配置和一些自己特有的配置。例如：

![[Pasted image 20240426112758.png|575]]

