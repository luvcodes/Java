# 条件构造器

除了新增以外，修改、删除、查询的 SQL 语句都需要指定 where 条件。因此 BaseMapper 中提供的相关方法除了以 `id` 作为 `where` 条件以外，还支持更加复杂的 `where` 条件。

参数中的 `Wrapper` 就是条件构造的抽象类，其下有很多默认实现，继承关系如图：
![[Pasted image 20240426132624.png|575]]

`Wrapper` 的子类 `AbstractWrapper` 提供了 where 中包含的所有条件构造方法：

![[Pasted image 20240426132647.png|525]]

而 QueryWrapper 在 AbstractWrapper 的基础上拓展了一个 select 方法，允许指定查询字段：

![[Pasted image 20240426132735.png|550]]

而 UpdateWrapper 在 AbstractWrapper 的基础上拓展了一个 set 方法，允许指定 SQL 中的 SET 部分：

![[Pasted image 20240426132750.png|550]]

接下来，我们就来看看如何利用 `Wrapper` 实现复杂查询。

[[2.1 条件构造器]]

## 设置查询条件

### 格式一: 常规格式

```Java
@Autowired
    private UserDao userDao;

@Test
void testGetAll() {
        /*QueryWrapper wrapper = new QueryWrapper();
        // age小于20岁
        wrapper.lt("age", 20);
        List<User> list = userDao.selectList(wrapper);
        System.out.println(list);*/

        QueryWrapper<User> wrapper = new QueryWrapper<User>();
        // age大于20岁
        wrapper.gt("age", 20);
        List<User> userList = userDao.selectList(wrapper);
        System.out.println(userList);
}
```

查询年龄大于等于 10 岁，小于 30 岁的用户

```Java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {
    @Autowired
    private UserDao userDao;

    @Test
    void testGetAll() {
        // 多条件
        QueryWrapper<User> qw = new QueryWrapper<User>();
        qw.lt("age", 30);
        qw.gt("age", 10);
        List<User> userList = userDao.selectList(qw);
        System.out.println(userList);
    }
}
```

### 格式二: 链式编程格式

```Java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {
    @Autowired
    private UserDao userDao;
    @Test
    void testGetAll() {
        QueryWrapper<User> qw = new QueryWrapper<User>();
        qw.lt("age", 30).qw.gt("age", 10);
        List<User> userList = userDao.selectList(qw);
        System.out.println(userList);
    }
}
```

### 格式三: 使用 lambda () 函数链式编程

使用 `lambda ()` 函数。通过 `wrapper.Lambda ()` 获取了一个 `LambdaQueryWrapper` 实例。`LambdaQueryWrapper` 允许您使用 Java 8 的 Lambda 表达式来构建查询条件，这使得代码更加简洁和类型安全。

```Java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {
    @Autowired
    private UserDao userDao;

    @Test
    void testGetAll() {
        // lambda按条件查询
        QueryWrapper<User> wrapper = new QueryWrapper<User>();
        wrapper.lambda().lt(User::getAge, 10).gt(User::getAge, 10);
        List<User> userList = userDao.selectList(wrapper);
        System.out.println(userList);
    }
}
```

### 格式四: LambdaQueryWrapper 链式编程

```Java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {
    @Autowired
    private UserDao userDao;

    @Test
    void testGetAll() {
        LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>();
        lqw.lt(User::getAge, 30).gt(User::getAge, 10);
        List<User> userList = userDao.selectList(lqw);
        System.out.println(userList);
    }
}
```

### 格式五: 使用 or () 函数

```Java
@SpringBootTest
class Mybatisplus02DqlApplicationTests {
    @Autowired
    private UserDao userDao;

    @Test
    void testGetAll() {
        LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>();
        lqw.lt(User::getAge, 30).or().gt(User::getAge, 10);
        List<User> userList = userDao.selectList(lqw);
        System.out.println(userList);
    }
}
```

## Null 值处理

### If 语句控制条件追加

在 `userQuery.getAge2()` 不为 null 的情况下，查找年龄在 10 到 20 之间的 User 对象。

```Java
    @Test
    void testGetAll3() {
        // 设置模拟数据
        UserQuery userQuery = new UserQuery();
        userQuery.setAge2(20);
        userQuery.setAge(10);

        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        // if语句控制条件追加
        if (null != userQuery.getAge2()) {
            wrapper.lt(User::getAge, userQuery.getAge());
        }
        if (null != userQuery.getAge2()) {
            wrapper.gt(User::getAge, userQuery.getAge2());
        }
        List<User> list = userDao.selectList(wrapper);
        System.out.println(list);
    }
```

### 条件参数控制

在 `userQuery.getAge2()` 不为 null 的情况下，查找年龄在 10 到 20 之间的 User 对象。

```Java
// 处理null值
@Test
void testGetAll2() {
    // 模拟页面传递过来的查询数据
    UserQuery uq = new UserQuery();
    uq.setAge(10);
    uq.setAge2(30);

    // null判定
    LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>();
    // 先判定第一个参数是否为true，如果为true连接当前条件
    lqw.lt(null != uq.getAge2(), User::getAge, uq.getAge2());
    lqw.gt(null != uq.getAge2(), User::getAge, uq.getAge());
    List<User> userList = userDao.selectList(lqw);
    System.out.println(userList);
}
```

### 条件参数控制 (链式编程)

在 `userQuery.getAge2()` 不为 null 的情况下，查找年龄在 10 到 20 之间的 User 对象。

```Java
    @Test
    void testGetAll2() {
        // 设置模拟数据
        UserQuery userQuery = new UserQuery();
        userQuery.setAge2(20);
        userQuery.setAge(10);

        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        // 链式编程实现null值处理
        wrapper.lt(null != userQuery.getAge2(), User::getAge, userQuery.getAge2())
                .gt(null !=  userQuery.getAge(), User::getAge, userQuery.getAge());
        List<User> list = userDao.selectList(wrapper);
        System.out.println(list);
    }
```

## 查询投影

查询出来看到的结果，叫做查询投影。

在 MyBatis Plus 中实现查询投影的常用方法是使用 `QueryWrapper` 或者 `LambdaQueryWrapper` 的 select 方法。这可以让你精确地指定需要查询的字段，而不是返回所有字段的数据。

请注意，`selectList` 方法返回的是一个包含完整 User 对象的列表，但是只有你在 select 方法中指定的字段会被填充数据，其他的字段都会是 null 或者其基本类型的默认值。这可能对后续逻辑造成影响，所以使用时应谨慎考虑。

### 查询结果部分属性

```Java
    @Test
    void testGetAll() {
        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        wrapper.select(User::getId, User::getName, User::getAge);
        List<User> users = userDao.selectList(wrapper);
        System.out.println(users);
    }
```

查询结果:

```Java
[User(id=1, name=update, password=null, age=3, tel=null), User(id=2, name=Jerry, password=null, age=4, tel=null)]
```

查询结果中出现大量 null 值的原因可能是由于：
选择的字段：在您的查询中，您使用了 wrapper.Select (User:: getId, User:: getName, User::getAge) 来指定查询时只选择 id、name 和 age 字段。这意味着查询结果中只会包含这三个字段的值，而其他字段（如 password 和 tel）默认不会被查询出来，因此在对象中会被设置为 null。

### 查询结果包含未定义的属性

```Java
    @Test
    void testGetAll3() {
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        // 统计有多少个数据
        queryWrapper.select("count (*) as count, tel");
        queryWrapper.groupBy("tel");
        List<Map<String, Object>> userList = userDao.selectMaps(queryWrapper);
        System.out.println(userList);
    }
```

SelectMaps 会返回一个 Map 列表，其中每个 Map 包含字段名和对应的值，这是一个非常灵活的方式，尤其是当你不需要映射结果到一个完整的实体类时。

## 查询条件

### Eq 匹配 (用户登录)

```Java
    // eq方法查询
    @Test
    void testGetAll4() {
        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        // eq方法 就是 =
        wrapper.eq(User::getName, "Jerry").eq(User::getPassword, "jerry");
        User loginUser = userDao.selectOne(wrapper);
        System.out.println(loginUser);
    }
```

### Le、ge、between (设定区间)

```Java
    // 范围查询 lt le gt ge eq between
    @Test
    void testGetAll5() {
        // 设置模拟数据
        UserQuery userQuery = new UserQuery();
        userQuery.setAge2(20);
        userQuery.setAge(10);


        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        // 方案一: 设定上限下限
        wrapper.le(User::getAge, userQuery.getAge2()).ge(User::getAge, userQuery.getAge());
        // 方案二: 设定范围
        /*wrapper.between(User::getAge, userQuery.getAge(), userQuery.getAge2());*/
        List<User> loginUser = userDao.selectList(wrapper);
        System.out.println(loginUser);
    }
```

### Like 匹配 (非全文检索版，查信息，搜索新闻)

```Java
    // like查询
    @Test
    void testGetAll6() {
        LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>();
        // 模糊匹配 like
        lqw.like(User::getName, "J");

        // 这个是%J的意思，Left就是百分号在左边
        // 这个匹配不上是因为，%J的意思是字符串最后结尾是J
        lqw.likeLeft(User::getName, "J");

        // 这个是J%的意思，Right就是百分号在右边
        // 这个能够匹配成功是因为，J%的意思是字符串开头是J
        lqw.likeRight(User::getName, "J");

        List<User> loginUser = userDao.selectList(lqw);
        System.out.println(loginUser);
    }
```

### Group (分组查询聚合函数，统计报表)

```Java
    // group分组查询
    @Test
    void testGetAll7() {
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        // 统计有多少个数据
        queryWrapper.select("count (*) as count, tel");
        queryWrapper.groupBy("tel");
        List<Map<String, Object>> userList = userDao.selectMaps(queryWrapper);
        System.out.println(userList);
    }
```

## 讲解重点知识点

LambdaQueryWrapper 和通过 QueryWrapper 调用 .lambda () 方法得到的 LambdaQueryWrapper，实例本质上是相同的。

### 不能使用 LambdaQueryWrapper 的情况

存在一些特定情况下你不得不使用 QueryWrapper 而不是 LambdaQueryWrapper：

1. 动态字段名：如果你需要构建的查询依赖于动态生成的或者运行时才知道的字段名，那么你可能需要用到 QueryWrapper，因为 LambdaQueryWrapper 需要在编译时就确定属性的方法引用。
2. 复杂的 SQL 操作：虽然 LambdaQueryWrapper 提供了很多强大的功能，但可能在某些非常复杂的 SQL 操作中不够用。例如，当你需要执行非常特定的 SQL 函数或操作时，可能需要使用 QueryWrapper 以字符串形式精确地控制 SQL 语句。
3. 旧代码的兼容性：如果你在维护一个已经广泛使用 QueryWrapper 的旧项目，那么继续使用 QueryWrapper 可能更加合适，因为转换到 LambdaQueryWrapper 可能需要大量的重构工作。
4. 自定义 SQL：有时，你可能需要在查询中使用非标准的 SQL 片段或子查询，这在 LambdaQueryWrapper 中可能不那么直观，而 QueryWrapper 可能更容易表达这些自定义 SQL 片段。
5. MyBatis Plus 版本兼容性：如果你使用的是 MyBatis Plus 的早期版本，它可能不支持 LambdaQueryWrapper 或者其支持不够完全。这种情况下，你需要使用 QueryWrapper。

[[2.1 条件构造器]]

[[2.2 自定义SQL]]

[[2.3 Service接口]]

