上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？

# 负载均衡原理

SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。

![[image2.png]]

# 负载均衡源码跟踪

基本流程如下：

- 拦截我们的RestTemplate请求http://userservice/user/1
- RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service
- DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表
- eureka返回列表，localhost:8081、localhost:8082
- IRule利用内置负载均衡规则 (比如`RoundRobinRule`)，从列表中选择一个，例如localhost:8081
- RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到http://localhost:8081/user/1，发起真实请求

![[image3.png]]

# 负载均衡策略

负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：

![[image4.png]]


| **内置负载均衡规则类**             | **规则描述**                                                                                                                                                                                                              |
| ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| RoundRobinRule            | 简单**轮询**服务列表来选择服务器。它是Ribbon默认的负载均衡规则。                                                                                                                                                                                 |
| AvailabilityFilteringRule | 对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的..ActiveConnectionsLimit属性进行配置。 |
| WeightedResponseTimeRule  | 为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。                                                                                                                                                     |
| **ZoneAvoidanceRule**     | 以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。                                                                                                                                          |
| BestAvailableRule         | 忽略那些短路的服务器，并选择并发数较低的服务器。                                                                                                                                                                                              |
| RandomRule                | 随机选择一个可用的服务器。                                                                                                                                                                                                         |
| RetryRule                 | 重试机制的选择逻辑                                                                                                                                                                                                             |
默认的实现就是ZoneAvoidanceRule，是一种轮询方案。

## 自定义负载均衡策略

通过定义IRule实现可以修改负载均衡规则，有两种方式：

1. 代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：

```java
@Bean
public IRule randomRule(){
    return new RandomRule();
}
```

2. 配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：

```yaml
userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则
```

这个**第二种方案是针对某个微服务而言的**，在这里就是在order-service中针对userservice中而言的。而**第一种的作用范围是针对所有的微服务而言的**。

注意，一般用默认的负载均衡规则，不做修改。

# 饥饿加载

Ribbon默认是采用懒加载，即**第一次访问时才会去创建LoadBalanceClient，请求时间会很长**。可以在浏览器的devTools的Network部分看到加载时间，第一次时间长，刷新一次时间就变短。

而**饥饿加载则会在项目启动时创建**，降低第一次访问的耗时，通过下面配置开启饥饿加载：

```yaml
ribbon:
  eager-load:
    enabled: true # 开启饥饿加载
    clients: # 指定接加载的服务名称
      - userservice
```

这样再去浏览器中测试一下，发现第一次加载时间快了一些。