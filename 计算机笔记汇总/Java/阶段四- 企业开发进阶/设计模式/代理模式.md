# 概念

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707637457749-ae6fc85e-3a89-4333-bb6c-1351d9f4487e.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707637457749-ae6fc85e-3a89-4333-bb6c-1351d9f4487e.png)

代理模式是一种结构型设计模式，它通过提供一个代理对象来代表实际对象，控制对这个实际对象的访问。它可以用于延迟处理操作或者在访问对象时添加其他操作。代理模式主要用于控制对某个对象的访问，可以添加一些额外的处理，如安全控制、延迟初始化等，而不需要改变原有对象的代码。

代理模式分为三种类型：静态代理、动态代理和虚拟代理。

在《大话设计模式》中提到，代理模式允许我们在不修改被代理对象的代码的情况下，通过引入代理对象来间接访问该对象。

而《图解设计模式》中提到，代理模式可以在不改变原有类的基础上，通过引入代理以控制对这个对象的访问，常用于延迟对象的加载或访问控制。

# 代码实现

```Java
public interface Printable {
    public abstract void setPrinterName(String name);
    public abstract String getPrinterName();
    public abstract void print(String string);
}
```

```Java
public class Printer implements Printable{
    private String name;
    public Printer(String name) {
        this.name = name;
        heavyJob("正在生成Printer的实例 (" + name + ")");
    }

    @Override
    public String getPrinterName() {
        return name;
    }

    @Override
    public void setPrinterName(String name) {
        this.name = name;
    }

    // 显示带打印机名字的文字
    @Override
    public void print(String string) {
        System.out.println("====" + name + "====");
        System.out.println(string);
    }

    // 重活
    private void heavyJob(String msg) {
        System.out.println(msg);
        // 干五秒钟重活
        for (int i = 0; i < 5; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(".");
        }
        System.out.println("结束");
    }
}
```

```Java
public class PrinterProxy implements Printable{
    // 打印机代理的名字
    private String name;
    // 本人
    private Printer real;

    public PrinterProxy() {
    }

    public PrinterProxy(String name) {
        this.name = name;
    }

    // 设置名字
    @Override
    public synchronized void setPrinterName(String name) {
        if (real != null) {
            // 设置本人名字
            real.setPrinterName(name);
        }
        this.name = name;
    }

    @Override
    public String getPrinterName() {
        return name;
    }

    @Override
    public void print(String string) {
        realize();
        real.print(string);
    }

    private synchronized void realize() {
        if (real == null) {
            real = new Printer(name);
        }
    }
}
```

```Java
public class Main {
    public static void main(String[] args) {
        Printable p = new PrinterProxy("Alice");
        System.out.println("Current name is: " + p.getPrinterName());
        p.setPrinterName("Bob");
        System.out.println("Update name is: " + p.getPrinterName());
        p.print("Hello, World");
    }
}
```