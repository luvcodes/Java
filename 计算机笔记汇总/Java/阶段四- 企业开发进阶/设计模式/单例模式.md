# 概念

单例模式是一种设计模式，它确保一个类只有一个实例，并提供一个全局访问点来获取该实例。这个模式经常用于控制对某些共享资源的访问，比如数据库连接或文件系统。

单例模式的关键点包括：

1. **私有的构造方法**：单例类的构造方法必须是私有的，这样就防止了外部代码使用`new`运算符直接实例化对象。
2. **一个保存实例的静态成员变量**：单例类内部会有一个静态变量来保存唯一实例，这个变量通常是私有的。
3. **一个公共的静态方法**：这个方法返回单例对象，如果对象不存在，则在内部创建它。这是获取单例对象的唯一方式。

单例模式有几种实现方式，以下是两种最常见的实现方式：

## 懒汉式（线程不安全）

这种实现方式在类加载时不会创建实例，而是在需要时才创建。这种实现方式的问题是它在多线程环境下是不安全的。

```Java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 验证多线程访问的问题

要演示两个线程同时访问懒汉式单例模式中的`getInstance()`方法时可能出现的问题，我们可以编写一个简单的测试程序。这个程序将启动两个线程，它们都尝试获取`Singleton`类的实例。如果出现问题，那么将有可能打印出“生成了一个实例。”两次，这表明创建了两个实例。

先给出懒汉式单例的代码：

```Java
public class Singleton {
    private static Singleton singleton = null;

    private Singleton() {
        System.out.println("生成了一个实例。");
    }

    public static Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

现在，我们编写一个测试程序：

```Java
public class SingletonTest {
    public static void main(String[] args) {
        Thread threadOne = new Thread(new Runnable() {
            @Override
            public void run() {
                Singleton singleton = Singleton.getInstance();
            }
        });

        Thread threadTwo = new Thread(new Runnable() {
            @Override
            public void run() {
                Singleton singleton = Singleton.getInstance();
            }
        });

        // 启动两个线程
        threadOne.start();
        threadTwo.start();
    }
}
```

当你运行这个测试程序时，理论上可能会看到以下两种输出之一：

**输出1（无问题）：**

```Plain
生成了一个实例。
```

**输出2（出现问题，两个实例被创建）：**

```Plain
生成了一个实例。
生成了一个实例。
```

在单处理器系统或者多处理器系统上，由于线程调度的不确定性，第二种输出（出现问题）可能发生。如果两个线程几乎同时检查`singleton == null`，并且都发现它为`null`，那么它们都会进入`if`块，并且都会创建一个`Singleton`实例。

这就是为什么我们通常需要对`getInstance()`方法进行同步处理，以避免这种情况的发生。通过使用`synchronized`关键字或其他同步机制，我们可以确保在任何时刻只有一个线程能执行实例创建逻辑，从而保证单例模式的线程安全。

  

## 饿汉式（线程安全）

这种实现方式在类加载时就立即创建实例，由于类加载过程是线程安全的，这种实现方式自然是线程安全的。

```Java
public class Singleton {
    private static Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```

## 线程安全的懒汉式

如果要实现一个线程安全的懒汉式单例，你可以使用`synchronized`关键字。这会影响性能，因此一种更好的方式是使用双重检查锁定（double-checked locking）。

```Java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

## 使用枚举（Effective Java推荐）

Joshua Bloch在《Effective Java》中推荐了使用枚举的方式实现单例模式，这种方式不仅自动支持序列化机制，而且由JVM保证防止多次实例化。

```Java
public enum Singleton {
    INSTANCE;

    public void someMethod() {
        // some class method
    }
}
```

  

# 实例代码

```Java
public class Singleton {
    // 创建实例对象
    public static Singleton singleton = new Singleton();

    // 设置私有的构造器
    private Singleton() {
        System.out.println("生成了一个实例");
    }

    // 提供对外获取实例对象的方法
    public static Singleton getInstance() {
        return singleton;
    }
}
```

  

```Java
public class Main {
    public static void main(String[] args) {
        System.out.println("Start.");
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        if (singleton1 == singleton2) {
            System.out.println("singleton1和singleton2是相同的实例");
        } else {
            System.out.println("singleton1和singleton2是不同的实例");
        }
        System.out.println("End.");
    }
}
```

  

# 对比懒汉式和饿汉式

## 懒汉式单例（线程不安全）

```Java
public class LazySingleton {
    private static LazySingleton instance;

    private LazySingleton() {}

    public static LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

这个版本的懒汉式单例非常简单，但它不是线程安全的。如果两个线程同时通过`getInstance()`检查到`instance`为`null`，它们都将创建一个实例，这违反了单例模式的原则。

## 懒汉式单例（线程安全）

为了使懒汉式单例线程安全，可以通过加锁来实现：

```Java
public class LazySingleton {
    private static LazySingleton instance;

    private LazySingleton() {}

    public static synchronized LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

现在，由于`getInstance()`方法是同步的，同一时刻只有一个线程能够执行这个方法，这确保了单例的唯一性。但是，同步操作相对耗时，会影响性能。

## 饿汉式单例

```Java
public class EagerSingleton {
    private static final EagerSingleton instance = new EagerSingleton();

    private EagerSingleton() {}

    public static EagerSingleton getInstance() {
        return instance;
    }
}
```

在饿汉式单例中，单例的实例被声明为`static final`变量，并且在类加载时立即初始化。这种方式是线程安全的，因为JVM保证了`static`变量的初始化只会发生一次。

## 对比

**初始化时机：**

- 懒汉式：第一次引用时初始化。
- 饿汉式：类加载时初始化。

**性能考虑：**

- 懒汉式：可以延迟初始化，但获取实例时可能需要同步，影响性能。
- 饿汉式：获取实例时性能好，但可能会增加应用启动时间，并且不使用时也占用资源。

**线程安全：**

- 懒汉式：需要正确实现同步才能保证线程安全。
- 饿汉式：由于在类加载时就完成了初始化，所以天生线程安全。

**资源利用：**

- 懒汉式：不使用时不会初始化实例，节省资源。
- 饿汉式：无论是否使用，实例都会被创建。

**复杂性：**

- 懒汉式：实现线程安全的版本比较复杂，需要考虑双重检查锁定等高级技巧。
- 饿汉式：实现简单。

你应该根据实际情况选择适合的模式。

- 如果单例类占用资源较多或初始化耗时，并且不是每次应用启动都需要立即使用，那么懒汉式可能更适合。
- 相反，如果单例类占用资源少并且确保在应用启动时就需要使用，或者对获取实例的性能要求很高，那么饿汉式可能更合适。