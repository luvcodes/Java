# 2. Redis主从

## 2.1.搭建主从架构

单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。

![[Pasted image 20240513180039.png]]

共包含三个节点，一个主节点，两个从节点。

这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下：

|IP|PORT|角色|
|---|---|---|
|192.168.150.101|7001|master|
|192.168.150.101|7002|slave|
|192.168.150.101|7003|slave|

### 2.1.1 开启主从关系

现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。

有临时和永久两种模式：

- 修改配置文件（永久生效）
    - 在redis.conf中添加一行配置：`slaveof <masterip> <masterport>`
        
- 使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：
    `slaveof <masterip> <masterport>`

**注意**：在5.0以后新增命令replicaof，与salveof效果一致。

这里我们为了演示方便，使用方式二。通过redis-cli命令连接7002，执行下面命令：

```shell
# 连接 7002  
redis-cli -p 7002  
# 执行slaveof  
slaveof 192.168.150.101 7001
```

通过redis-cli命令连接7003，执行下面命令：

```shell
# 连接 7001
redis-cli -p 7001
# 查看状态
info replication
```

结果：

![[Pasted image 20240514104616.png]]

### 2.1.2 测试

执行下列操作以测试：

- 利用redis-cli连接7001，执行`set num 123`
    
- 利用redis-cli连接7002，执行`get num`，再执行`set num 666`
    
- 利用redis-cli连接7003，执行`get num`，再执行`set num 888`

可以发现，**只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作**。

## 2.2. 主从数据同步原理

### 2.2.1. 全量同步

主从第一次建立连接时，会执行**全量同步**，将master节点的所有数据都拷贝给slave节点，流程：

![[Pasted image 20240514101737.png]]

这里有一个问题，master如何得知salve是第一次来连接呢？？

有几个概念，可以作为判断依据：

- **Replication Id**：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid
    
- **offset**：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。

因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。

因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。

master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。

master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。

因此，**master判断一个节点是否是第一次同步的依据，就是看replid是否一致**。

如图：

![[Pasted image 20240514104106.png]]

完整流程描述：

- slave节点请求增量同步
    
- master节点判断replid，发现不一致，拒绝增量同步
    
- master将完整内存数据生成RDB，发送RDB到slave
    
- slave清空本地数据，加载master的RDB
    
- master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave
    
- slave执行接收到的命令，保持与master之间的同步

