# 3. Redis哨兵

Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。

## 3.1. 哨兵原理

### 3.1.1. 集群结构和作用

哨兵的结构如图：

![[Pasted image 20240514161455.png|400]]

哨兵的作用如下：

- **监控**：Sentinel 会不断检查每一个master和slave 节点是否按预期工作。
    
- **自动故障恢复**：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。
    
- **通知**：Sentinel充当Redis客户端的服务发现来源，当 Redis集群发生故障转移时，会将最新信息推送给Redis的客户端。告诉客户端哪个节点是主，哪个节点是从。

### 3.1.2. 集群监控原理

Sentinel基于**心跳机制**监测服务状态，**每隔1秒向集群的每个实例发送ping命令**：

- 主观下线：如果某sentinel节点发现某 Redis 实例未在规定时间响应，则认为该实例**主观下线**。

- 客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例**客观下线**。quorum值最好超过Sentinel实例数量的一半。

![[Pasted image 20240514161548.png|400]]

### 3.1.3. 集群故障恢复原理

**一旦发现master故障，sentinel需要在salve中选择一个作为新的master**，选择依据是这样的：

#### 选择新 master 的依据

- 首先会判断slave节点与master节点断开时间长短，如果超过指定值（`down-after-milliseconds * 10`）则会排除该slave节点。
    
- 然后判断slave节点的`slave-priority`值，越小优先级越高，如果是0则永不参与选举
    
- 如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高
    
- 最后是判断slave节点的 runid大小，越小优先级越高。

#### 实现故障转移

当选出一个新的master后，该**如何实现切换**呢？

- sentinel给备选的slave1节点发送`slaveof no one`命令，让该节点成为master
    
- sentinel给所有其它slave发送 `slaveof 192.168.200.130 7002` 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。
    
- 最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点

![[Pasted image 20240514161732.png|400]]

### 3.1.4. 小结

Sentinel的三个作用是什么？

- 监控
    
- 故障转移
    
- 通知

Sentinel如何判断一个redis实例是否健康？

- 每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线
    
- 如果大多数sentinel都认为实例主观下线，则判定服务下线

故障转移步骤有哪些？

- 首先选定一个slave作为新的master，执行slaveof no one
    
- 然后让所有节点都执行slaveof 新master
    
- 修改故障节点配置，添加slaveof 新master

## 3.2. 搭建哨兵集群


## 3.3. RedisTemplate
在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的`RedisTemplate`底层利用lettuce实现了节点的感知和自动切换。

下面，我们通过一个测试来实现`RedisTemplate`集成哨兵机制。

### 3.3.1. 导入Demo工程

首先，我们引入课前资料提供的Demo工程：

![[Pasted image 20240515124456.png|96]]

### 3.3.2. 引入依赖

在项目的pom文件中引入依赖：

<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-data-redis</artifactId>  
</dependency>

### 3.3.3. 配置Redis地址

然后在配置文件application.yml中指定redis的sentinel相关信息：

spring:  
  redis:  
    sentinel:  
      master: mymaster  
      nodes:  
        - 192.168.150.101:27001  
        - 192.168.150.101:27002  
        - 192.168.150.101:27003

### 3.3.4. 配置读写分离

在项目的启动类中，添加一个新的bean：

```java
@Bean  
public LettuceClientConfigurationBuilderCustomizer clientConfigurationBuilderCustomizer(){  
    return clientConfigurationBuilder -> clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);  
}
```

这个bean中配置的就是读写策略，包括四种：

- `MASTER`：从主节点读取
    
- `MASTER_PREFERRED`：优先从master节点读取，master不可用才读取replica
    
- `REPLICA`：从slave（replica）节点读取
    
- `REPLICA _PREFERRED`：优先从slave（replica）节点读取，所有的slave都不可用才读取master

