基于Redis集群解决单机Redis存在的问题

单机的Redis存在四大问题：

![[Pasted image 20240513153122.png]]
# 1. Redis持久化

Redis有两种持久化方案：

- RDB持久化
    
- AOF持久化

## 1.1. RDB持久化

**RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据压缩快照。**

简单来说就是**把内存中的所有数据都记录到磁盘中**。当Redis实例故障重启后，从磁盘读取压缩快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录下。

### 1.1.1. 执行时机

RDB持久化在四种情况下会执行：

- 执行save命令
    
- 执行bgsave命令
    
- Redis停机时
    
- 触发RDB条件时

**1）save命令**

执行下面的命令，可以立即执行一次RDB：

![[Pasted image 20240513153623.png]]

save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。

**2）bgsave命令**

下面的命令可以**异步执行RDB**：

![[Pasted image 20240513153635.png]]

这个命令执行后会**开启独立进程完成RDB**，**主进程可以持续处理用户请求，不受影响**。

**3）停机时**

**Redis停机时会自动执行一次save命令**，实现RDB持久化。

**4）触发RDB条件**

Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：

```properties
# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save "" 则表示禁用RDB
save 900 1  
save 300 10  
save 60 10000 
```

RDB的其它配置也可以在redis.conf文件中设置：

```properties
# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱  
rdbcompression yes  

# RDB文件名称
dbfilename dump.rdb    

# 文件保存的路径目录  
dir ./ 
```

### 1.1.2.RDB原理

bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。

fork采用的是`copy-on-write`技术：

- 当主进程执行读操作时，访问共享内存；
    
- 当主进程执行写操作时，则会拷贝一份数据，执行写操作。

![[Pasted image 20240513165832.png]]

### 1.1.3.小结

RDB方式bgsave的基本流程？

- fork主进程得到一个子进程，共享内存空间
    
- 子进程读取内存数据并写入新的RDB文件
    
- 用新RDB文件替换旧的RDB文件

RDB会在什么时候执行？`save 60 1000`代表什么含义？

- 默认是服务停止时
    
- 代表60秒内至少执行1000次修改则触发RDB

RDB的缺点？

- **RDB执行间隔时间长**，**两次RDB之间写入数据有丢失的风险**
    
- fork子进程、压缩、写出RDB文件都比较耗时

## 1.2. AOF持久化
### 1.2.1.AOF原理
AOF全称为Append Only File（追加文件）。Redis处理的**每一个写命令都会记录在AOF文件**，可以看做是**命令日志文件**。
![[Pasted image 20240513165959.png]]

> 在图中显示的 AOF（Append Only File）文件格式，**`$3` 表示接下来的字符串长度为 3 个字符**。
> `$3` 后跟的 `set` 表示 `set` 是一个**三个字符长的字符串**；
> 同样，后面的 `num` 和 `123` 也都是被视为字符串，并用 `$3` 表示它们各自也都是三个字符长。
> 这种格式帮助 Redis 在读取 AOF 文件时准确地重建原始的操作指令。

### 1.2.2.AOF配置
AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：

```properties
# 是否开启AOF功能，默认是no  
appendonly yes  
# AOF文件的名称  
appendfilename "appendonly.aof"
```

AOF的命令记录的频率也可以通过redis.conf文件来配：

```properties
# 表示每执行一次写命令，立即记录到AOF文件
appendfsync always 
# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec 
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
```

![[Pasted image 20240513171329.png]]

### 1.2.3.AOF文件重写

**因为是记录命令，AOF文件会比RDB文件大的多**。而且AOF会记录对同一个key的多次写操作，但只有**最后一次写操作才有意义**。通过执行 `bgrewriteaof` 命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。

![[Pasted image 20240513173431.png]]

如图，AOF原本有三个命令，但是`set num 123 和 set num 666`都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。
所以重写命令后，AOF文件内容就是：`mset name jack num 666`
Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：

```properties
# AOF文件比上次文件 增长超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写 
auto-aof-rewrite-min-size 64mb 
```

## 1.3. RDB与AOF对比
RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会**结合**两者来使用。

![[Pasted image 20240513173249.png]]

### Redis 默认使用哪种？
**Redis 默认配置是启用 RDB 持久化，而不启用 AOF**。这意味着它会在配置的时间间隔内自动保存快照到磁盘。这种方式简单高效，能够满足大多数恢复需求，但可能会在服务器故障时丢失最近的数据。

在实际应用中，可以根据需要配置 Redis **同时使用 RDB 和 AOF，以结合两者的优点**。例如，可以通过定时的 RDB 快照来提供一个全数据的恢复点，同时通过 AOF 来保证更高级别的数据完整性和安全性。在配置双重持久化时，Redis 会在启动时优先加载 AOF 文件，因为它通常包含比 RDB 更完整的数据集。

### 同时启用：优先级？
如果在 Redis 配置中同时启用了 RDB 和 AOF 持久化方式，**Redis 在重启时会优先加载 AOF 文件**。这是**因为 AOF 文件通常能够提供比 RDB 文件更完整和更准确的数据状态**。AOF 持久化记录了所有写入操作的顺序，能够确保数据的完整性，即使面临非正常的服务器关闭情况。

**这样的设计确保了数据的最大可能恢复**。因为 AOF 通常保存了更多的写操作，它比 RDB 文件更能反映服务器关闭前的最后状态。如果 AOF 持久化被配置为每次操作后都进行同步写入磁盘，那么这种方法几乎可以消除数据丢失的风险。

