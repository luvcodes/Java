# 4. Redis分片集群
## 4.1. 搭建分片集群

主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：

- 海量数据存储问题
  
- 高并发写的问题

使用分片集群可以解决上述问题，如图: 

![[Pasted image 20240515124638.png|475]]

### 4.1.1 分片集群特征

- 集群中有多个master，每个master保存不同数据
  
- 每个master都可以有多个slave节点
  
- master之间通过ping监测彼此健康状态
  
- 客户端请求可以访问集群任意节点，最终都会被转发到正确节点

具体搭建流程参考课前资料《Redis集群.md》：

![[Pasted image 20240515124725.png|94]]

集群管理以及集成到了redis-cli中，格式如下：

```shell
redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003
```

命令说明：

- `redis-cli --cluster`或者`./redis-trib.rb`：代表集群操作命令
    
- `create`：代表是创建集群
    
- `--replicas 1`或者`--cluster-replicas 1` ：指定集群中每个master的副本个数为1，此时`节点总数 ÷ (replicas + 1)` 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master

### 4.1.2 计算主从节点数量

```sh
redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003
```

其中，`--cluster-replicas 1`表示**每个主节点会有一个从节点**。根据这个信息以及提供的节点列表，可以做以下推测：

1. **节点数目**：
   - 总共有6个节点。
   - `--cluster-replicas 1`意味着有3个主节点和3个从节点。

2. **节点顺序**：
   - **通常情况下，命令会按顺序分配主节点和从节点**。也就是说，**前半部分的节点分配为主节点**，**后半部分的节点分配为从节点**。

3. **推测主节点和从节点**：
   - 前3个节点是主节点，后3个节点是从节点。

因此，根据你的命令，我们可以推测出：

- 主节点（3个）：`192.168.150.101:7001, 192.168.150.101:7002, 192.168.150.101:7003`
- 从节点（3个）：`192.168.150.101:8001, 192.168.150.101:8002, 192.168.150.101:8003`

这样分配的话，主从节点的配对关系可以如下：

- `192.168.150.101:7001`（主） <-> `192.168.150.101:8001`（从）
- `192.168.150.101:7002`（主） <-> `192.168.150.101:8002`（从）
- `192.168.150.101:7003`（主） <-> `192.168.150.101:8003`（从）

## 4.2. 散列插槽
### 4.2.1. 插槽原理
Redis会**把每一个master节点映射到0~16383共16384个插槽（hash slot）上**，查看集群信息时就能看到：

![[Pasted image 20240515153900.png]]

**数据key不是与节点绑定，而是与插槽绑定**。redis会根据key的有效部分计算插槽值，分两种情况：

- key中包含"{}"，且“{}”中至少包含1个字符，“{}”中的部分是有效部分
  
- key中不包含“{}”，整个key都是有效部分

例如：key是num，那么就根据num计算，如果是 `{itcast}num`，则根据 `itcast` 计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。

![[Pasted image 20240515155742.png]]

如图，在7001 端口这个 Redis 实例中执行 `set num 123`, 然后执行 `set a 1` 时，对 `a` 做hash运算，对16384取余，得到的结果是15495，因此要存储到15495节点，这个节点是位于 7003 端口的，那么就跳转到了 7003 端口的 Redis 实例。

这时候直接执行 `get num` 的时候是没有问题的，因为 `a` 这个就分配到了 15495，也就是 7003 端口的 Redis 实例中，所以直接就可以取到 `a` 的值。

但是执行 `get num` 的时候，对 num 做 hash 运算，对 16384 取余，得到的结果是 2765，就会跳转回 2765 插槽，而这个插槽是属于 7001 端口的 Redis，因此需要切换到 7001 节点。

### 4.2.2. 小结

Redis 如何判断某个 key 应该在哪个 Redis 实例？

- 将 16384 个插槽分配到不同的 Redis 实例
  
- 根据 key 的有效部分计算哈希值，对 16384 取余
  
- 余数作为插槽，寻找插槽所在实例即可

如何将同一类数据固定的保存在同一个 Redis 实例？

- 这一类数据**使用相同的有效部分**，例如 key 都以 `{typeId}` 为前缀

Redis 分片集群中的散列插槽（Hash Slots）是管理数据分布的核心概念之一。以下是关于 Redis 散列插槽的详细解释：

#### 1. 散列插槽的定义

- 散列插槽是 Redis 集群用来分布数据的基本单元。
- Redis 集群总共定义了 `16384` 个散列插槽，**每个散列插槽可以存储多个键值对**。
- 散列插槽的编号范围是 0 到 16383。
#### 2. 键到散列插槽的映射

- 当你存储一个键值对时，Redis 会计算键的哈希值，然后将其映射到一个特定的散列插槽。
- Redis 使用 CRC 16 哈希函数计算键的哈希值，然后对 16384 取模，得到一个散列插槽号。

  ```python
  hash_slot = CRC16(key) % 16384
  ```

- 例如，假设键 `"mykey"` 的 CRC 16 哈希值是 12345，那么其散列插槽号是 `12345 % 16384 = 12345`。
#### 3. 节点和散列插槽的分布

- 在 Redis 集群中，每个节点（主节点）负责管理一定范围的散列插槽。
- 整个集群的 16384 个散列插槽被均匀分布在所有主节点上。
- 例如，假设有 3 个主节点，散列插槽的分布可能如下：
  - 节点 1：负责散列插槽 0 - 5460
  - 节点 2：负责散列插槽 5461 - 10922
  - 节点 3：负责散列插槽 10923 - 16383
#### 4. 数据访问和路由

- 当客户端向集群发送一个键的**读写请求**时，Redis 集群客户端会根据键的散列插槽号将请求路由到负责该散列插槽的节点。
- 客户端库（如 `redis-cli` 或其他 Redis 客户端库）通常会自动处理键到散列插槽的映射和请求路由。
#### 5. 节点故障和重新分片

- 如果一个负责某些散列插槽的主节点发生故障，集群会自动将这些散列插槽的责任转移到对应的从节点，并提升从节点为新的主节点。
- 集群支持动态添加或移除节点，Redis 会自动调整散列插槽的分布，以保持数据的均衡。
#### 6. 实际操作示例

假设有一个 Redis 集群，包含以下节点：

- 主节点 1：负责散列插槽 0 - 5460
- 主节点 2：负责散列插槽 5461 - 10922
- 主节点 3：负责散列插槽 10923 - 16383

当你执行以下命令时：

```sh
SET mykey "myvalue"
```

Redis 会执行以下步骤：

1. 计算 `mykey` 的 CRC 16 哈希值，假设结果为 12345。
2. 计算 `mykey` 的散列插槽号：`12345 % 16384 = 12345`。
3. 找到负责散列插槽 12345 的节点（假设是主节点 3）。
4. 将 `SET mykey "myvalue"` 请求路由到主节点 3，并在该节点上存储键值对。
#### 7. 散列插槽和键标签

Redis 支持使用键标签来**强制**特定的键值对**存储在同一个散列插槽**中。**键标签是通过在键中使用花括号 `{}` 指定的部分**。例如：

```sh
SET user:{1000}:name "Alice"
SET user:{1000}:age "30"
```

- 两个键 `user:{1000}:name` 和 `user:{1000}:age` 都有相同的键标签 `{1000}`，因此它们会映射到同一个散列插槽。
- 这对于需要存储在同一个节点上的相关数据非常有用，例如事务处理和管道操作。


## 4.3 集群伸缩

`redis-cli --cluster`提供了很多操作集群的命令，可以通过下面方式查看：

![[Pasted image 20240515165423.png]]

比如，添加节点的命令：

![[Pasted image 20240515185438.png]]

### 4.3.1. 需求分析

需求：向集群中添加一个新的master节点，并向其中存储 num = 10

- 启动一个新的redis实例，端口为7004
    
- 添加7004到之前的集群，并作为一个master节点
    
- 给7004节点分配插槽，使得num这个key可以存储到7004实例
    

这里需要两个新的功能：

- 添加一个节点到集群中
    
- 将部分插槽分配到新插槽

### 4.3.2. 创建新的redis实例

创建一个文件夹：

`mkdir 7004`

拷贝配置文件：

`cp redis.conf /7004`

修改配置文件：

`sed /s/6379/7004/g 7004/redis.conf`

启动

`redis-server 7004/redis.conf`

### 4.3.3. 添加新节点到redis

添加节点的语法如下：

![[Pasted image 20240515202715.png]]

执行命令：

`redis-cli --cluster add-node 192.168.150.101:7004 192.168.150.101:7001`

通过命令查看集群状态：

`redis-cli -p 7001 cluster nodes`

如图，7004加入了集群，并且默认是一个master节点：

![[Pasted image 20240515202734.png]]

### 4.3.4. 转移插槽

我们要将num存储到7004节点，因此需要先看看num的插槽是多少：

![[Pasted image 20240515202806.png]]

如上图所示，num的插槽为2765.

我们可以将0~3000的插槽从7001转移到7004，命令格式如下：

![[Pasted image 20240515202822.png]]

具体命令如下：

建立连接：

![[Pasted image 20240515202855.png]]

得到下面的反馈：

![[Pasted image 20240515202906.png]]

询问要移动多少个插槽，我们计划是3000个：

新的问题来了：

![[Pasted image 20240515202920.png]]

那个node来接收这些插槽？？显然是7004，那么7004节点的id是多少呢？

![[Pasted image 20240515202938.png]]

复制这个id，然后拷贝到刚才的控制台后：

![[Pasted image 20240515202951.png]]

这里询问，你的插槽是从哪里移动过来的？

- all：代表全部，也就是三个节点各转移一部分
    
- 具体的id：目标节点的id
    
- done：没有了
    

这里我们要从7001获取，因此填写7001的id：

![[Pasted image 20240515203009.png]]

填完后，点击done，这样插槽转移就准备好了：

![[Pasted image 20240515203220.png]]

确认要转移吗？输入yes：

然后，通过命令查看结果：

![[Pasted image 20240515203235.png]]

可以看到：

![[Pasted image 20240515203249.png]]

目的达成。

## 4.4. 故障转移

集群初识状态是这样的：

![[Pasted image 20240515203612.png]]

其中7001、7002、7003都是master，我们计划让7002宕机。

### 4.4.1. 自动故障转移

当集群中有一个master宕机会发生什么呢？

直接停止一个redis实例，例如7002：

`redis-cli -p 7002 shutdown
`
1）首先是该实例与其它实例失去连接

2）然后是疑似宕机：

![[Pasted image 20240515203629.png]]

3）最后是确定下线，自动提升一个slave为新的master：

![[Pasted image 20240515203641.png]]

4）当7002再次启动，就会变为一个slave节点了：

![[Pasted image 20240515203651.png]]

### 4.4.2. 手动故障转移

利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：

![[Pasted image 20240515203833.png]]

这种failover命令可以指定三种模式：

- 缺省：默认的流程，如图1~6歩
    
- force：省略了对offset的一致性校验
    
- takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见
    

**案例需求**：在7002这个slave节点执行手动故障转移，重新夺回master地位

步骤如下：

1）利用redis-cli连接7002这个节点

2）执行cluster failover命令

如图：

![[Pasted image 20240515203848.png]]

效果：

![[Pasted image 20240515203857.png]]

## 4.5. RedisTemplate访问分片集群

RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：

1）引入redis的starter依赖

2）配置分片集群地址

3）配置读写分离

与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：

```yaml
spring:  
  redis:  
    cluster:  
      nodes:  
        - 192.168.150.101:7001  
        - 192.168.150.101:7002  
        - 192.168.150.101:7003  
        - 192.168.150.101:8001  
        - 192.168.150.101:8002  
        - 192.168.150.101:8003
```