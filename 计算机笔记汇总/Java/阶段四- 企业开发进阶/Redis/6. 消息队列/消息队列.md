# 概念

什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：

- 消息队列：存储和管理消息，也被称为消息代理（Message Broker）

- 生产者：发送消息到消息队列

- 消费者：从消息队列获取消息并处理消息

![[Pasted image 20240509145202.png]]

使用队列的好处在于：**解耦**

所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，**这就是一个异步**。

如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。

这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。

消息队列允许应用程序或服务将消息发送到队列，而不需要直接与接收应用程序进行交互。这些消息存储在队列中，直到被接收方处理。消息队列提供了一种松耦合的通信方式，有利于提高系统的可伸缩性和响应性。

# Redis中的消息队列

Redis的消息队列是指使用Redis这个内存中的数据结构存储系统来实现消息队列的功能。

Redis本身是一个键值对数据库，但它也支持发布/订阅（pub/sub）模式，这使得它可以用作消息队列。在Redis中，生产者可以将消息发布到特定的频道，消费者则订阅这些频道来接收消息。

由于Redis的高性能和低延迟特性，它常被用于需要快速响应的消息传递场景。
## 特点

1. **快速和高效**：由于Redis是基于内存的，因此消息的发布和接收都非常快速。
2. **支持多种数据结构**：Redis不仅支持简单的字符串，还支持列表、集合、哈希等多种数据结构，使得在消息队列中可以实现更复杂的功能。
3. **可持久化**：尽管Redis是内存中的，但它提供了数据持久化的选项，确保在系统崩溃时不会丢失重要数据。
4. **支持多种编程语言**：Redis有多种编程语言的客户端，方便集成到不同的应用程序中。
5. **简单易用**：Redis的使用相对简单，易于设置和维护。

Redis 提供了几种**可以被用作消息队列的机制**，其中三种比较常见的是：**列表（Lists）、发布/订阅（Pub/Sub）和流（Streams）**。

## 列表（Lists）

消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果 (**先进先出**)。

队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。 

不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该**使用BRPOP或者BLPOP来实现阻塞效果**。

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%884.22.22.png]]

在 Redis 中，`BRPOP` 和 `BLPOP` 是两个用于从列表中移除并返回元素的命令。它们是 `RPOP` 和 `LPOP` 的阻塞版本，分别用于列表的右端（尾部）和左端（头部）。

**阻塞操作**：这些命令是阻塞的，意味着**如果列表为空，它们会等待**，**直到有元素可弹出或达到指定的超时时间**。这在处理消息队列时非常有用，因为消费者可以等待消息到达而不必持续查询列表。**`BRPOP` 和 `BLPOP` 与非阻塞的 `RPOP` 和 `LPOP` 相比，更适用于消息队列场景**，因为它们**在等待新消息时不会消耗过多资源**。


### 优缺点

优点：

- 利用Redis存储，不受限于JVM内存上限
    
- 基于Redis的持久化机制，数据安全性有保证
    
- 可以满足消息有序性
    
缺点：

- 无法避免消息丢失
    
- 只支持单消费者

## 发布/订阅（Pub/Sub）

PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。

SUBSCRIBE channel [channel] ：订阅一个或多个频道 PUBLISH channel msg ：向一个频道发送消息 PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道

- 这是一种消息广播机制。
- 发布者（publisher）发送消息到一个频道，而订阅了那个频道的订阅者（subscriber）可以接收到这些消息。
- Pub/Sub 模式适用于实时消息广播和通知，但它不保证消息的持久化或者顺序，一旦消息发布，不在线的订阅者将无法接收到这些消息。

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%884.34.28.png]]

### 优缺点

优点：

- 采用发布订阅模型，**支持多生产、多消费**

缺点：

- 不支持数据持久化
    
- 无法避免消息丢失
    
- 消息堆积有上限，超出时数据丢失

## 流（Streams）

- Redis 流是一个更复杂、功能更强大的消息队列实现，引入了更多的特性，如消息持久化、消费者群组和消息确认。
- 流可以被视为一个日志文件，其中包含一系列的消息条目。
- 它适用于更复杂的应用场景，如消息队列、事件溯源或者日志记录。

每种类型的消息队列都适用于不同的场景，可以根据具体的应用需求和环境选择适合的机制。

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%886.48.57.png|700]]

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%886.55.14.png|700]]

Stream 当中消息读取完成之后不会从队列中删除。

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%886.56.14.png]]

BLOCK 后面的值如果是 0 就是永久阻塞。这个值代表的是阻塞时间。

注意：当我们**指定起始ID为$时，代表读取最新的消息**，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，**会出现漏读消息的问题**。

STREAM类型消息队列的XREAD命令特点：

- 消息可回溯
    
- 一个消息可以被多个消费者读取
    
- 可以阻塞读取
    
- 有消息漏读的风险

### 消费者组

消费者组（Consumer Group）：**将多个消费者划分到一个组中**，**监听同一个队列**。具备下列特点：

![[Pasted image 20240509161150.png]]

#### 消费者组

1. **概念**:
    - 消费者组允许将 Stream 中的消息**分发给多个消费者**，这些消费者可以是不同的线程、进程或者服务器。
    - 一个消费者组中的多个消费者共享消息流，但每个消息只会被组内的一个消费者处理。
2. **工作方式**:
    - 当一个消息被消费者组内的某个消费者读取时，它会被标记为 "已投递"，但不会从 Stream 中删除。
    - 这允许其他消费者（即使不属于同一个组）也能读取同一个消息，确保消息不会在处理前丢失。
3. **确认机制**:
    - 消费者处理完消息后应该对其进行**确认**。这样，消息就会从 "Pending List" 中移除，表示已经被成功处理。

#### Pending List

1. **定义**:
    - "Pending List" 是消费者组内部的一个数据结构，用来跟踪那些已经被消费者**读取但尚未被确认**的消息。
    - **每当消费者从消费者组获取消息时，这些消息就会被加入到 "Pending List"。**
2. **用途**:
    - 它**用于确保消息的可靠处理**。如果一个消费者读取了消息但因崩溃或其他原因未能处理，那么这个消息仍然会留在 "Pending List" 中。
    - 这**允许其他消费者或同一消费者在恢复后重新处理**这些消息。
3. **处理未确认消息**:
    - 消费者组可以检查 "Pending List" 来找出那些长时间未被确认的消息。
    - 这些消息可以被重新投递给消费者组中的任一消费者进行处理，确保所有消息最终都被正确处理。

#### 操作

**创建消费者组**

![[Pasted image 20240509162208.png]]

- key：队列名称 
- groupName：消费者组名称 
- ID：起始ID标示，
- $代表队列中最后一个消息，
- 0则代表队列中第一个消息 
- MKSTREAM：队列不存在时自动创建队列 其它常见命令：

**删除指定的消费者组**

`XGROUP DESTORY key groupName`

**给指定的消费者组添加消费者**

`XGROUP CREATECONSUMER key groupname consumername`

**删除消费者组中的指定消费者**

`XGROUP DELCONSUMER key groupname consumername`

**从消费者组读取消息**

`XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]`

- group：消费组名称
    
- consumer：消费者名称，如果消费者不存在，会自动创建一个消费者
    
- count：本次查询的最大数量
    
- BLOCK milliseconds：当没有消息时最长等待时间
    
- NOACK：无需手动ACK，获取到消息后自动确认
    
- STREAMS key：指定队列名称
    
- ID：获取消息的起始ID：

">"：从下一个未消费的消息开始 其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始

#### 消费者监听消息的基本思路

![[Pasted image 20240509162811.png]]

XREADGROUP命令特点：

- 消息可回溯
    
- 可以多消费者争抢消息，加快消费速度
    
- 可以阻塞读取
    
- 没有消息漏读的风险
    
- 有消息确认机制，保证消息至少被消费一次

### 总结

在基于 Stream 的消息队列中，消费者组和 "Pending List" 提供了一种可靠的方式来处理和监控消息。消费者组允许多个消费者共同处理同一个消息流，而 "Pending List" 确保了消息在被成功处理之前不会丢失。这种机制非常适合于那些需要高度可靠性和可伸缩性的消息处理系统。

- 消费者从 Stream 中读取消息后，消息就被加入到 "Pending List"。
- 如果消费者成功处理消息，它会发送确认，消息就会从 "Pending List" 中移除。
- 如果消费者失败或崩溃，未确认的消息保留在 "Pending List"，可以由其他消费者重新处理。

这种机制提高了消息处理的可靠性，确保即使在出现故障的情况下，消息也不会丢失，并且能够被及时处理。

# 对比总结3种消息队列

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%888.01.00.png]]