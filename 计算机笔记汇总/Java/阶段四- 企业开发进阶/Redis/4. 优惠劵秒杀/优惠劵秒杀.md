# 全局唯一ID 生成策略

用户抢购业务，订单表如果使用数据库自增ID就存在一些问题:

- id规律性太明显，容易被用户找到规律
- 受表单数据量的限制。数据量太大之后，单表很难存储了。在mysql中每张表的id又都是独立控制的，所以就有可能出现多表的不同数据，id字段值相同，损失了唯一性。

全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，有下列特性:

![[%E6%88%AA%E5%B1%8F2024-01-11_%E4%B8%8A%E5%8D%889.18.16.png|475]]

## 全局 UUID

## Redis 自增

为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其他信息。

![[%E6%88%AA%E5%B1%8F2024-01-11_%E4%B8%8A%E5%8D%889.22.36.png|600]]

`符号位 + 时间戳 + 序列号` 就是 Redis 自增解决全局唯一 ID 生成策略

### 重点内容

![[Pasted image 20240506122433.png|243]]
## Snowflake 算法

## 数据库自增

# 超卖问题

超卖问题通常出现在秒杀系统中，主要是因为系统在高并发情况下处理订单的机制不够完善。具体原因包括：

1. **库存同步问题**：多个用户同时下单，系统处理不及时，导致实际销售的商品数量超过库存数量。
2. **数据库写入延迟**：数据库更新库存的操作不能即时完成，结果是在库存实际扣减前，更多订单已经被接受。
3. **缺乏事务控制**：如果订单处理和库存更新不是作为一个原子操作处理，可能会导致在订单确认后，库存更新失败，但订单依然有效。

解决这些问题通常需要引入事务控制，使用更优的并发控制策略（如乐观锁或悲观锁），或者实现更高效的库存扣减逻辑（如使用分布式锁或消息队列来控制订单处理流程）。
## 解决方法

![[%E6%88%AA%E5%B1%8F2024-01-11_%E4%B8%8A%E5%8D%8810.52.58.png]]

## 悲观锁

添加同步锁，让线程串行执行

优点: 简单粗暴

缺点: 性能一般

## 乐观锁

关键是判断之前查询得到的数据是否有被修改过

不加锁，在更新时判断是否有其他线程做了修改

优点: 性能好

缺点: 存在成功率低的问题

### 版本号法

用版本标识数据有没有变化

![[Pasted image 20240506144439.png]]

经过线程 1 的修改之后，stock 的值变为 0，version 值变为 2。线程 2 想要再减库存的时候，就发现 stock 的值已经为 0，无法再进行修改; 同时，也发现 version 的值不为 1，证明有其他的线程修改过了数据。

![[%E6%88%AA%E5%B1%8F2024-01-11_%E4%B8%8A%E5%8D%8810.58.05.png]]

### CAS法

版本号法和 CAS（Compare And Swap）法都是乐观锁的实现方式，但有些细微的差别：

- **CAS 法**：这是一种更广义的比较和交换操作，它可以应用在任何支持这种原子操作的系统上。它**直接比较内存中的值**，如果**与预期的旧值相符，就更新为新值**。这种方法在多线程编程和硬件级别的操作中非常常见。

在实现时，版本号法是数据库级的乐观锁实现，依赖于数据表中的字段；而 **CAS 是一种可以在内存操作中直接使用的底层同步机制**。

![[Pasted image 20240506145609.png]]

线程一和线程二都执行查询之后，线程一先进行扣减的操作，在这里，因为 CAS 方法没有使用版本号来判断是否在执行此操作之前是否原值已经修改，所以在这里直接就使用 stock 字段的值来进行判断。
先读取 stock 的值，与上面查询的 stock 值进行对比，如果相同，说明没有发生修改，执行扣减。


![[%E6%88%AA%E5%B1%8F2024-01-11_%E4%B8%8A%E5%8D%8811.01.38.png]]

但是在线程二中，进行判断，stock 的值大于 0，因为在上面查询库存中读到的值依旧是 1，但是在下面它会进行对比，查询发现 stock 的值已经变成了 0，与线程二上面自己查询到的 stock 值不一样，所以不会执行扣减动作。

因此，线程安全问题不会发生。

