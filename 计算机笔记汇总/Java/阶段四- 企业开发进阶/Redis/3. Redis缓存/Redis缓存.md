# 什么是缓存

缓存是数据交换的缓冲区 (Cache)，是存储数据的临时地方，一般读写性能较高。

![[%E6%88%AA%E5%B1%8F2024-01-07_%E4%B8%8A%E5%8D%889.54.44.png]]

缓存（Cache）是一种高速数据存储层，它的主要作用是存储临时数据，以便于快速访问。缓存的使用在计算机科学和技术领域非常普遍，包括硬件和软件层面。

![[%E6%88%AA%E5%B1%8F2024-01-07_%E4%B8%8A%E5%8D%889.57.51.png]]

### 缓存的作用

1. **提高数据访问速度**：缓存通常使用更快的存储介质，如SRAM（静态随机存取存储器），比主存储（如DRAM，动态随机存取存储器）快得多。
2. **减少数据访问次数**：对于频繁访问的数据，缓存可以减少对慢速存储（如硬盘或远程服务器）的访问次数。
3. **减轻主存储负担**：**缓存作为一个中间层，可以减少对主存储的压力**，尤其是在高并发访问场景中。
4. **改善系统性能**：在多层缓存架构中，缓存可以显著提高系统的整体性能和响应速度。

### 缓存的成本

1. **硬件成本**：物理硬件缓存（如CPU缓存）需要额外的硬件资源，这会增加成本。
2. **维护成本**：缓存需要适当的维护和管理策略，如缓存失效策略（LRU、FIFO等），这需要额外的算法和资源管理。
3. **数据一致性问题**：保持缓存数据与原始数据源的一致性是一个挑战，特别是在分布式系统中。
4. **资源占用**：缓存占用内存或存储空间，可能会限制其他应用或进程使用这些资源。
5. **设计和管理复杂性**：合理地设计和管理缓存系统需要专业知识，可能会增加软件开发和运维的复杂性。

# 添加Redis缓存

![[%E6%88%AA%E5%B1%8F2024-01-07_%E4%B8%8A%E5%8D%8810.03.38.png|234]]

# 缓存更新策略

![[%E6%88%AA%E5%B1%8F2024-01-07_%E4%B8%8A%E5%8D%8810.44.25.png]]

## 主动更新3种方案

![[%E6%88%AA%E5%B1%8F2024-01-09_%E4%B8%8B%E5%8D%885.54.51.png]]

选择第一种

## 缓存更新策略的最佳实践方案

- 更新缓存会产生无效更新，并且存在较大的线程安全问题
- **删除缓存**本质是延迟更新，没有无效更新，**线程安全问题相对较低**

**使用删除缓存的方式来替代更新缓存的方式**

![[%E6%88%AA%E5%B1%8F2024-01-09_%E4%B8%8B%E5%8D%886.12.22.png|400]]

每当数据库发生更新，缓存就会被移除。这样每次用户看到的信息都是最新的，而不是原来缓存里保存的数据。

# 缓存穿透

客户端请求的数据在缓存中和数据库中都不存在，这样的缓存永远不会生效，这些请求都会打到数据库。

## 缓存穿透产生的原因

用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力

## 解决方案

### 缓存空对象 (缓存null值)

- 优点: 实现简单，维护方便
- 缺点
    - 额外的内存消耗
    - 可能造成短期的不一致

### 布隆过滤

- 优点: 内存占用较少，没有多余key
- 缺点
    - 实现复杂
    - 存在误判可能

Redis中的布隆过滤器（Bloom filter）是一种空间效率极高的数据结构，用于检测一个元素是否在一个集合中。它的特点包括：

1. **空间效率和查询时间**：相比于其它的数据结构，布隆过滤器在空间使用上非常高效。同时，它提供了快速的查询操作。
2. **概率性和误判**：布隆过滤器是一种概率性数据结构，它可能会错误地判断某个不存在的元素为存在（假阳性），但绝不会将存在的元素判断为不存在（假阴性）。
3. **不支持删除操作**：传统的布隆过滤器不支持从集合中删除元素。尽管存在变体可以实现这一点，但Redis的实现不支持删除。
4. **可调的误判率**：通过调整过滤器的大小和使用的哈希函数的数量，可以在占用空间和误判率之间进行权衡。

布隆过滤器的使用场景通常包括快速集合成员检查，例如在缓存系统中防止缓存穿透，或在大型数据库中快速查询一个元素是否存在。

### 如何使用布隆过滤器防止缓存穿透

1. **初始化布隆过滤器**：首先，需要在Redis中初始化一个布隆过滤器。这通常在系统启动时完成，可以通过将数据库中所有有效数据的键添加到布隆过滤器中来实现。
2. **查询流程调整**：
    - 当一个查询请求到来时，首先使用布隆过滤器检查请求的键是否可能存在。
    - 如果布隆过滤器判断键不可能存在，那么可以直接返回，不需要查询数据库。
    - 如果布隆过滤器判断键可能存在，再去缓存中查询。
    - 如果缓存中没有，再去数据库中查询，并根据需要更新缓存。

这种方法的好处是大量不存在的查询请求不会穿过布隆过滤器，从而不会对数据库造成不必要的压力。

### 注意事项

- **误判率**：布隆过滤器存在一定的误判率，即它可能会错误地认为某些不存在的键是存在的。因此，即使布隆过滤器判断键可能存在，实际上数据库中可能没有这个键。误判率可以通过调整布隆过滤器的参数（如大小和哈希函数数量）来控制。  

![[%E6%88%AA%E5%B1%8F2024-01-09_%E4%B8%8B%E5%8D%887.34.07.png]]

# 缓存雪崩

同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库带来巨大压力

![[%E6%88%AA%E5%B1%8F2024-01-10_%E4%B8%8A%E5%8D%888.01.16.png|414]]

## 解决方案

![[%E6%88%AA%E5%B1%8F2024-01-10_%E4%B8%8A%E5%8D%888.08.33.png|205]]
# 缓存击穿

也叫热点key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

![[%E6%88%AA%E5%B1%8F2024-01-10_%E4%B8%8A%E5%8D%888.12.53.png]]

## 解决方案

### 互斥锁

给缓存重建过程加锁，确保重建过程只有一个线程执行，其它线程等待

![[%E6%88%AA%E5%B1%8F2024-01-10_%E4%B8%8A%E5%8D%888.15.47.png|316]]

最大问题就是: 互相等待。如果线程很多，一个时间段内只能有一个线程执行，其他的线程都在等待

### 逻辑过期

![[%E6%88%AA%E5%B1%8F2024-01-10_%E4%B8%8A%E5%8D%888.22.19.png]]

“逻辑过期”是一种缓存更新策略，用于解决缓存击穿问题。缓存击穿是指当缓存中某个热点数据过期的瞬间，大量的请求同时击中数据库去获取这个数据，如果没有合适的策略，这将可能导致数据库的短时间内高负载。

**逻辑过期的工作原理**：

- 在缓存数据时，除了存储数据本身外，还存储该数据的过期时间。
- 当一个请求查询数据时，先检查缓存中的数据是否过期。
- 如果数据未过期，直接返回缓存数据。
- 如果数据已经过期，不立即删除缓存数据。而是启动一个异步任务去更新这个数据，并延长数据的过期时间，然后返回这个过期的缓存数据。
- 新的请求在异步任务更新完成前，都会返回这个过期的缓存数据，从而避免对数据库的大量请求。

**逻辑过期的缺点**：

1. **数据一致性**：使用逻辑过期策略会**导致短时间内返回给客户端的是过期数据**，这在某些对数据实时性要求较高的场景下可能是不可接受的。
2. **复杂性**：实现逻辑过期需要更复杂的缓存控制逻辑。需要维护数据的过期时间，并且需要处理异步更新操作，这会增加系统的复杂度。
3. **资源占用**：在数据过期后，直到异步任务完成更新之前，过期的数据仍然会占用缓存空间，这可能会在缓存资源有限的情况下影响到其他数据的缓存效率。
4. **竞态条件**：如果异步更新任务执行失败或者延迟较大，**可能会有一段时间内用户一直获取到的是过期数据**，这需要通过合理的重试策略和超时控制来保证数据最终能够被更新。

![[%E6%88%AA%E5%B1%8F2024-01-10_%E4%B8%8A%E5%8D%888.25.27.png]]
