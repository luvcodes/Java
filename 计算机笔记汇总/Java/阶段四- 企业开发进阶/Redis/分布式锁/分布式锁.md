  

  

![[%E6%88%AA%E5%B1%8F2024-01-12_%E4%B8%8B%E5%8D%883.57.41.png]]

分布式锁的核心是实现多线程之间的互斥

![[%E6%88%AA%E5%B1%8F2024-01-12_%E4%B8%8B%E5%8D%884.07.21.png]]

# 基于Redis的分布式锁

![[%E6%88%AA%E5%B1%8F2024-01-12_%E4%B8%8B%E5%8D%884.17.04.png]]

这里对应代码中的`utils.SimpleRedisLock`文件中的代码，`setIfAbsent`就是上面的`setnx`这种redis指令对应的Java API

# 基于Redis的lua脚本

Redis 的 Lua 脚本是一种功能，允许用户在 Redis 服务器上运行 Lua 脚本。这些脚本在 Redis 服务器内部执行，可以用来处理复杂的操作，比如事务、计算或者流程控制。使用 Lua 脚本的主要优点是它们在执行时是原子性的，这意味着在一个脚本执行的过程中不会被其他 Redis 命令或脚本中断。

## 如何使用 Redis 的 Lua 脚本？

1. **编写 Lua 脚本**：首先，你需要用 Lua 语言编写一个脚本来执行你想要的操作。
2. **加载脚本**：通过 `EVAL` 命令或 `EVALSHA` 命令将脚本加载到 Redis。`EVAL` 需要完整的脚本内容，而 `EVALSHA` 使用脚本内容的 SHA1 校验和，适用于之前已加载的脚本。
3. **执行脚本**：执行已加载的脚本。你可以传递参数给脚本，这些参数可以是键名、值或其他数据。

## Redis Lua 脚本的特点：

1. **原子性操作**：脚本在执行期间不会被其他 Redis 命令打断，保证了操作的原子性。
2. **减少网络开销**：通过在服务器端执行复杂逻辑，减少了客户端与服务器之间的通信次数。
3. **高性能**：Lua 脚本在 Redis 服务器内部运行，提供了高性能的执行。
4. **灵活性**：可以执行比 Redis 原生命令更复杂的操作和逻辑。
5. **安全性注意事项**：不当的脚本可能导致长时间的执行，影响 Redis 服务器的性能。

### 示例

假设你想要在一个键的值增加之前检查其是否存在，你可以编写如下 Lua 脚本：

```Lua
if redis.call("EXISTS", KEYS[1]) == 1 then
    return redis.call("INCR", KEYS[1])
else
    return nil
end
```

然后使用 `EVAL` 命令来执行这个脚本。

### 结论

Redis 的 Lua 脚本提供了一种强大和灵活的方式来执行复杂操作，同时保持了高性能和原子性。通过合理使用 Lua 脚本，可以极大地提升 Redis 的使用效率和功能性。

  

## 保证原子性

如果不使用 Lua 脚本，某些操作在 Redis 中可能无法保证原子性。在 Redis 中，原子性是指一个操作或一系列操作要么完全执行，要么完全不执行，且在执行过程中不会被其他操作打断。不使用 Lua 脚本时，连续的 Redis 命令之间可能会被其他客户端的命令打断，从而导致数据不一致或逻辑错误。

### 丧失原子性的例子

1. **计数器递增**：
    - 假设有一个操作是检查一个键是否存在，如果存在则递增它的值。
    - 使用单独的命令，你可能会先调用 `EXISTS` 检查键是否存在，然后调用 `INCR` 递增键的值。
    - 在这两个命令之间，如果另一个客户端删除了这个键，那么你的 `INCR` 操作将意外地创建一个新键并设置其值为 1，这违反了原本的逻辑意图。
2. **库存扣减**：
    - 在处理例如电商网站的订单时，你可能需要先检查产品的库存量是否足够，然后再进行扣减。
    - 使用非原子操作，你可能先获取库存量，然后再执行扣减操作。
    - 如果在这两步操作之间，另一个操作更改了库存量，可能会导致超卖的情况。
3. **组合读写操作**：
    - 假设你想更新一个键的值，但更新的逻辑依赖于当前的值。
    - 你可能首先读取这个键的值，根据这个值来计算新值，然后再进行更新。
    - 如果在读取和更新之间，其他客户端修改了这个键的值，你的更新可能就是基于过时的信息。

### 使用 Lua 脚本保证原子性

在上述每个例子中，使用 Lua 脚本可以保证整个操作的原子性。Lua 脚本在执行时，不会被其他 Redis 命令打断，因此可以确保即使在高并发的环境下，操作的整体性和顺序性得以保持。例如，你可以将检查库存和扣减库存的操作写在一个 Lua 脚本中，这样整个操作要么完全执行，要么完全不执行，不会出现因并发操作导致的数据不一致问题。

  

![[%E6%88%AA%E5%B1%8F2024-01-13_%E4%B8%8B%E5%8D%884.45.15.png]]

  

# 基于Redis的分布式锁优化

## 概念

Redisson 是一个在 Java 中广泛使用的 Redis 客户端库，它提供了一套丰富的分布式数据结构和分布式服务。其中，Redisson 对 Redis 的分布式锁特性提供了高级的封装，使其在 Java 应用中易于使用。

1. **概念**：
    - Redisson 的分布式锁是基于 Redis 实现的，它提供了跨多个节点的同步机制。
    - 使用 Redis 的特性，比如 `SETNX`（set if not exists），`EXPIRE`（设置过期时间）等来实现锁的功能。
2. **特点**：
    - **安全性**：确保在分布式环境中，同一时刻只有一个进程可以持有锁。
    - **死锁避免**：通过设置锁的有效期来防止死锁的发生。
    - **性能**：由于基于 Redis，因此性能较高。

## Redisson入门

使用 Redisson 实现分布式锁的步骤大致如下：

1. **添加依赖**：  
    在你的 Java 项目中添加 Redisson 的依赖。如果使用 Maven，可以在  
    `pom.xml` 中添加如下依赖：
    
    ```XML
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
        <version>最新版本</version>
    </dependency>
    ```
    
2. **配置 Redisson 客户端**：  
    创建并配置 Redisson 客户端实例。这通常涉及指定 Redis 服务器的地址和其他相关配置。  
    
    ```Java
    Config config = new Config();
    config.useSingleServer().setAddress("redis://127.0.0.1:6379");
    RedissonClient redisson = Redisson.create(config);
    ```
    
3. **获取分布式锁**：  
    使用 Redisson 获取分布式锁实例。锁是通过一个唯一的名称标识的。  
    
    ```Java
    RLock lock = redisson.getLock("myLock");
    ```
    
4. **加锁和解锁**：  
    使用  
    `lock()` 和 `unlock()` 方法来加锁和解锁。
    
    ```Java
    try {
        // 尝试获取锁，可以指定等待时间和锁的持有时间
        if (lock.tryLock(10, 2, TimeUnit.SECONDS)) {
            try {
                // 执行业务逻辑
            } finally {
                lock.unlock();
            }
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
    ```
    

这段代码演示了如何在 Java 中使用 Redisson 实现分布式锁。

**尝试获取锁**

```Java
if (lock.tryLock(10, 2, TimeUnit.SECONDS)) {
    // ...
}
```

- `**tryLock**` **方法**：这个方法尝试获取锁。
    - **第一个参数（10）**：这是尝试获取锁的最大等待时间。在这个例子中，如果锁在 10 秒内不可用，当前线程将停止等待。
    - **第二个参数（2）**：这是锁的持有时间。一旦锁被获取，它将至少保持锁状态 2 秒。
    - **第三个参数（**`**TimeUnit.SECONDS**`**）**：这是时间单位，本例中使用的是秒。
- **逻辑**：`tryLock` 会立即返回一个布尔值。如果获取到锁，返回 `true`；如果在指定的等待时间内未能获取到锁，返回 `false`。
- 一个线程使用 tryLock 方法尝试获取锁时，如果锁已经被另一个线程持有，那么这个线程将等待指定的时间（在您的例子中是10秒）以尝试获取锁。
    - 如果在这个等待时间内，锁被释放并且当前线程成功获取到锁，tryLock 会返回 true 并且线程将继续执行。
    - 如果在等待时间结束时，线程仍然未能获取到锁，那么会发生以下情况：
        - 直接放弃：tryLock 方法会返回 false。这表示线程在指定的等待时间内未能获取锁。
        - 不会强行获取：**线程不会强制获取锁，也不会继续等待**。它会退出锁获取的尝试。 在这种情况下，通常你**需要在代码中处理未能获取锁的情况**。

**执行业务逻辑**

```Java
try {
    // 执行业务逻辑
} finally {
    lock.unlock();
}
```

- 当获取到锁后，你可以在这个 `try` 块中执行业务逻辑。
- 无论业务逻辑执行过程中发生了什么（即使是异常），`finally` 块都将确保锁被释放。

**解锁**

- `**lock.unlock()**`：这行代码在 `finally` 块中调用，确保锁无论如何都会被释放。这是避免死锁非常重要的一步，特别是在多线程和分布式环境中。

**异常处理**

- `**catch (InterruptedException e)**`：这个 `catch` 块处理了在等待锁的过程中可能发生的中断异常。
- `**Thread.currentThread().interrupt();**`：这行代码重新设置当前线程的中断状态。这在处理多线程时是一种常规做法，它确保高层代码可以感知到中断并且可以进一步处理。

  

1. **关闭客户端**：  
    在应用程序关闭时，关闭 Redisson 客户端。  
    
    ```Java
    redisson.shutdown();
    ```
    
    ## 注意事项
    
    - **确保解锁**：在业务逻辑执行完毕后，务必在 finally 块中释放锁，以防止死锁。
    - **锁的有效期**：合理设置锁的有效期，避免长时间持有锁。
    - **异常处理**：适当处理加锁和解锁过程中可能出现的异常。
    - **分布式环境考量**：在分布式环境下，确保锁的使用不会导致系统整体性能下降。
    
    使用 Redisson 的分布式锁是在分布式系统中处理并发问题的一个有效工具，它利用了 Redis 的高性能和高可用性特性，为 Java 应用提供了一种可靠的锁机制。
    
      
    

# Redisson的可重入锁

Redisson 的可重入锁（Reentrant Lock）是一种特殊类型的锁，它允许同一个线程多次获取同一把锁而不会发生死锁。在分布式系统中，这种锁的行为类似于 Java 中 `java.util.concurrent.locks.ReentrantLock` 的行为。

## 特点

1. **可重入性**：
    - 如果一个线程已经持有了锁，它可以再次获取这个锁而不会被自己阻塞。这对于递归函数或者一个函数在多个地方需要多次加锁的情况非常有用。
2. **防止死锁**：
    - 在传统的锁机制中，如果一个线程试图获取它已经持有的锁，将会导致死锁。而可重入锁避免了这个问题，因为它允许同一个线程多次获取同一把锁。
3. **锁计数**：
    - 当一个线程首次获取锁时，锁计数为1。每当同一线程再次获取锁时，计数增加。每当线程释放锁时，计数减少。只有当计数降至0时，锁才被完全释放。
4. **线程所有权**：
    - 可重入锁跟踪哪个线程持有了锁，并且只有锁的持有者才能释放锁。

## 应用场景

可重入锁非常适用于需要多次执行加锁操作的场景，例如：

- **递归调用**：一个递归函数在每次调用时都需要加锁。
- **跨方法加锁**：在一个方法中获取锁后，调用另一个也需要加锁的方法。

  

![[%E6%88%AA%E5%B1%8F2024-01-13_%E4%B8%8B%E5%8D%886.58.56.png]]

在上面的代码和流程图中，锁被尝试获取两次是因为存在两个不同的方法（`method1` 和 `method2`），并且每个方法都尝试获取相同的锁。在这种情况下，锁需要被获取两次的原因通常是为了确保在递归调用或者嵌套调用中，一个线程可以多次进入临界区而不会被自己阻塞。这样的锁称为“可重入锁”。

## 可重入锁的使用场景：

1. **递归调用**：当一个同步方法递归调用自己时，线程已经持有了锁，但是由于递归调用它需要再次获取锁。如果锁不是可重入的，线程将会因为尝试获取它已经持有的锁而阻塞。
2. **嵌套方法调用**：当一个同步方法在持有锁的情况下调用另一个同步方法，需要再次获取锁。如果锁不是可重入的，这将会导致死锁。

## 代码的逻辑：

1. `method1` 尝试获取锁，如果成功，它会继续执行并打印日志。
2. `method1` 在持有锁的状态下调用 `method2`。
3. `method2` 同样尝试获取锁。由于锁是可重入的，这个操作是允许的，因为已经是由相同的线程（即正在执行 `method1` 的线程）

持有锁。如果锁不是可重入的，这将会失败，因为锁已经被持有。

1. `method2` 获取锁之后执行其业务逻辑，然后在 `finally` 块中释放锁。但由于是可重入锁，这次释放不会真正释放锁，只会减少锁的持有计数。
2. 控制权回到 `method1`，在它的 `finally` 块中，它再次释放锁。由于这是最后一次释放（锁的持有计数归零），锁此时真正被释放。

在这个过程中，锁的获取次数与释放次数是对应的。这是可重入锁的基本特性，确保了同一个线程可以在不同的方法中多次获取同一个锁，而不会导致死锁。

在实际应用中，可重入锁对于编写复杂的同步代码非常有用，因为开发者不需要担心每个锁获取的确切位置，只需要确保每个锁获取都有一个相应的锁释放。这简化了同步代码的编写和理解。

  

一个实际的业务场景，其中可重入锁非常有用，是在处理电子商务网站的订单系统中的多步骤事务性操作。假设一个系统需要在处理一个订单时执行以下步骤：

1. **验证库存**：检查所购买商品的库存量是否足够。
2. **创建订单**：如果库存充足，创建一个新的订单记录。
3. **更新库存**：订单创建后，相应减少库存数量。
4. **计算积分**：为用户计算购买后的积分，并更新积分记录。

这些步骤可能涉及到多个方法调用，并且每个方法都可能需要访问共享资源（如库存和积分数据），这需要同步以避免并发问题。

### 场景描述

假设您有一个 `OrderService` 类，它有一个 `processOrder` 方法和一个 `updateInventory` 方法。`processOrder` 方法在处理订单时需要调用 `updateInventory` 方法来更新库存。

```Java
public class OrderService {
    private final RLock lock = redissonClient.getLock("orderLock");

    public void processOrder(String itemId, int quantity) {
        lock.lock(); // 第一次获取锁
        try {
            if (checkInventory(itemId, quantity)) {
                createOrder(itemId, quantity);
                updateInventory(itemId, -quantity); // 更新库存，内部会尝试再次获取锁
            }
        } finally {
            lock.unlock(); // 第一次释放锁
        }
    }

    public void updateInventory(String itemId, int quantity) {
        lock.lock(); // 第二次获取锁（可重入）
        try {
            // 执行库存更新逻辑
        } finally {
            lock.unlock(); // 第二次释放锁
        }
    }

    // ... 其他方法，如 checkInventory 和 createOrder ...
}
```

在这个场景中，`processOrder` 方法在调用 `updateInventory` 之前已经获取了锁。如果锁不是可重入的，那么 `updateInventory` 尝试获取锁时会发生死锁，因为它会等待 `processOrder` 释放锁。但由于锁是可重入的，`updateInventory` 可以在不阻塞的情况下再次获取同一个锁。

# Redisson的分布式锁主从一致性问题

在Redisson的multi-lock机制中，涉及的是多个不同的锁，而不是同一个锁的多次实例。这些锁可以位于不同的Redis节点上。

1. **多个锁实例**：Multi-lock涉及的是多个锁实例。这些锁可能分布在不同的Redis节点上，每个节点上的锁都是独立的。
2. **独立性**：每个锁都是独立的实体。虽然它们被组合在一起以形成一个multi-lock，但每个锁的状态和操作都是独立的。
3. **锁定过程**：当请求multi-lock时，Redisson会尝试在所有指定的Redis节点上获取各自的锁。只有当所有锁都成功获取时，整个multi-lock才被认为是锁定的。
4. **原子操作**：整个锁定和解锁过程是原子的。这意味着不会出现部分锁被锁定而其他锁未被锁定的情况。要么所有锁同时被锁定，要么都不被锁定。
5. **用途**：这种机制通常用于分布式系统中的复杂同步问题，特别是当需要跨多个Redis节点协调资源时。

总的来说，multi-lock机制提供了一种强大的方式来在分布式环境中同步操作，确保了操作的一致性和原子性。

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%884.46.57.png]]

  

# 总结

  

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%885.07.33.png]]

三种不同类型的Redis锁机制，每种都有其用途和缺点：

1. **不可重入的Redis分布式锁**：
    - **用途**：这种锁使用`setnx`命令来实现。它是最基础的锁机制，当锁不存在时可以设置锁，使用完后需要显式地释放。
    - **缺点**：它的主要缺点是不可重入，即同一个客户端在锁已经被自己获取的情况下不能再次获取，否则会被阻塞。
2. **可重入的Redis分布式锁**：
    - **用途**：相比于不可重入锁，可重入锁允许同一个线程多次获取同一把锁。它使用了`hash`数据结构来追踪锁的持有者，并结合`watchDog`机制自动延长锁的有效期，确保长时间运行的任务不会因为锁超时而被中断。
    - **缺点**：相对复杂，需要额外的机制来维护锁的状态和延长锁的有效期。
3. **Redisson的multiLock**：
    - **用途**：multiLock是Redisson客户端提供的一个高级锁机制，它允许跨多个Redis节点实现锁的集合。只有当所有指定的锁都被成功获取时，才算整体上锁成功，适合于涉及多个资源的复杂操作。
    - **缺点**：实现较为复杂，因为需要协调多个节点上的锁状态，保证原子性。

这三种锁机制各有适用场景，设计得当时能够很好地在分布式系统中管理对共享资源的访问。在选择合适的锁类型时，需要根据实际的应用场景和需求来决定。

  

# Redis的优化秒杀

## 秒杀优化的流程

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%886.00.06.png]]

  

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%888.49.18.png]]