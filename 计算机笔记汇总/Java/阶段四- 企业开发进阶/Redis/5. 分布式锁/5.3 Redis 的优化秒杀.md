# Redis 的优化秒杀

## 异步秒杀思路

我们来回顾一下下单流程

当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤：

![[Pasted image 20240509090344.png]]

1、查询优惠卷

2、判断秒杀库存是否足够

3、查询订单

4、校验是否是一人一单

5、扣减库存

6、创建订单

在这六步操作中，又**有很多操作是要去操作数据库**的，而且还是**一个线程串行执行**，这样就会**导致我们的程序执行的很慢**，所以我们**需要异步程序执行**。

在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？

> 答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中**类似消息队列的方式**来完成我们的需求，**而不是使用线程池或者是异步编排的方式**来完成这个需求。

## 秒杀优化的流程

我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要到redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua 脚本来操作。

当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%886.00.06.png]]

## Redis完成秒杀资格判断

需求：

- 新增秒杀优惠券的同时，将优惠券信息保存到Redis中
    
- 基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功
    
- 如果抢购成功，将优惠券id和用户id封装后存入阻塞队列
    
- 开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能

![[Pasted image 20240509095657.png]]


## 基于阻塞队列实现秒杀优化







![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%888.49.18.png]]