# Redisson 相关内容

Redisson 是一个在 Java 环境下使用的 **Redis 客户端库**，它实现了多种 Java 实用工具接口，并提供了与 Redis 数据库交互的高级功能。下面是 Redisson 的一些主要特性和知识点：

1. **实现 Java 接口**：Redisson 对 Java 的一些常用接口进行了实现，如 `Map`, `Set`, `List`, `Queue`, `Deque` 等，使得 Java 程序可以通过这些接口直接操作 Redis 存储的数据。

2. **对象映射**：Redisson 提供了 RObject 接口，允许将 Java 对象直接存储在 Redis 数据库中。这通过序列化和反序列化机制实现，方便对象的存取。

3. **分布式数据结构**：除了标准的数据结构，Redisson 还提供了一些分布式数据结构，如 RLock（分布式锁）、RSemaphore（分布式信号量）、RCountDownLatch（分布式倒计时门闩）等，这些结构在分布式系统中特别有用。

4. **发布/订阅**：Redisson 支持 Redis 的发布订阅模式，可以非常容易地在应用程序中实现消息的发布和订阅。

5. **持久化和复制支持**：Redisson 可以配合 Redis 的持久化和复制功能，确保数据的安全性和高可用性。

6. **配置灵活**：Redisson 允许通过 **JSON** 和 **YAML** 两种格式**配置其连接到 Redis 服务器**的方式，支持单机、哨兵、集群等多种部署模式的配置。

7. **异步 API**：Redisson 提供了异步 API，使得操作可以在非阻塞模式下执行，提高了程序的执行效率。

使用 Redisson，Java 开发者可以更加高效地利用 Redis 的功能，进行快速的数据处理和实现分布式计算场景。


基于setnx实现 (基于 Redis 锁实现) 的分布式锁存在下面的问题：

**重入问题**：重入问题是指**获得锁的线程可以再次进入到相同的锁的代码块中**，**可重入锁的意义在于防止死锁**。比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的`synchronized`和`Lock`锁都是可重入的。[[5.2.1 可重入锁]]

**不可重试**：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。

**超时释放：**我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患

**主从一致性：** 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。

# Redisson 入门

使用 Redisson 实现分布式锁的步骤大致如下：

1. **添加依赖**：  
    在你的 Java 项目中添加 Redisson 的依赖。如果使用 Maven，可以在  
    `pom.xml` 中添加如下依赖：
    
    ```XML
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
        <version>最新版本</version>
    </dependency>
    ```
    
2. **配置 Redisson 客户端**：  
    创建并配置 Redisson 客户端实例。这通常涉及指定 Redis 服务器的地址和其他相关配置。  
    
    ```Java
    Config config = new Config();
    config.useSingleServer().setAddress("redis://127.0.0.1:6379");
    RedissonClient redisson = Redisson.create(config);
    ```
    
3. **获取分布式锁**：  
    使用 Redisson 获取分布式锁实例。锁是通过一个唯一的名称标识的。  
    
    ```Java
    RLock lock = redisson.getLock("myLock");
    ```
    
4. **加锁和解锁**：  
    使用  
    `lock()` 和 `unlock()` 方法来加锁和解锁。
    
    ```Java
    try {
        // 尝试获取锁，可以指定等待时间和锁的持有时间
        if (lock.tryLock(10, 2, TimeUnit.SECONDS)) {
            try {
                // 执行业务逻辑
            } finally {
                lock.unlock();
            }
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
    ```
    

这段代码演示了如何在 Java 中使用 Redisson 实现分布式锁。

**尝试获取锁**

```Java
if (lock.tryLock(10, 2, TimeUnit.SECONDS)) {
    // ...
}
```

- `**tryLock**` **方法**：这个方法尝试获取锁。
    - **第一个参数（10）**：这是尝试获取锁的最大等待时间。在这个例子中，如果锁在 10 秒内不可用，当前线程将停止等待。
    - **第二个参数（2）**：这是锁的持有时间。一旦锁被获取，它将至少保持锁状态 2 秒。
    - **第三个参数（**`**TimeUnit.SECONDS**`**）**：这是时间单位，本例中使用的是秒。
- **逻辑**：`tryLock` 会立即返回一个布尔值。如果获取到锁，返回 `true`；如果在指定的等待时间内未能获取到锁，返回 `false`。
- 一个线程使用 tryLock 方法尝试获取锁时，如果锁已经被另一个线程持有，那么这个线程将等待指定的时间（在您的例子中是 10 秒）以尝试获取锁。
    - 如果在这个等待时间内，锁被释放并且当前线程成功获取到锁，tryLock 会返回 true 并且线程将继续执行。
    - 如果在等待时间结束时，线程仍然未能获取到锁，那么会发生以下情况：
        - 直接放弃：tryLock 方法会返回 false。这表示线程在指定的等待时间内未能获取锁。
        - 不会强行获取：**线程不会强制获取锁，也不会继续等待**。它会退出锁获取的尝试。在这种情况下，通常你**需要在代码中处理未能获取锁的情况**。

**执行业务逻辑**

```Java
try {
    // 执行业务逻辑
} finally {
    lock.unlock();
}
```

- 当获取到锁后，你可以在这个 `try` 块中执行业务逻辑。
- 无论业务逻辑执行过程中发生了什么（即使是异常），`finally` 块都将确保锁被释放。

**解锁**

- `**lock.unlock()**`：这行代码在 `finally` 块中调用，确保锁无论如何都会被释放。这是避免死锁非常重要的一步，特别是在多线程和分布式环境中。

**异常处理**

- `**catch (InterruptedException e)**`：这个 `catch` 块处理了在等待锁的过程中可能发生的中断异常。
- `**Thread.currentThread().interrupt();**`：这行代码重新设置当前线程的中断状态。这在处理多线程时是一种常规做法，它确保高层代码可以感知到中断并且可以进一步处理。

1. **关闭客户端**：  
    在应用程序关闭时，关闭 Redisson 客户端。  
    
    ```Java
    redisson.shutdown();
    ```
    
    ## 注意事项
    
    - **确保解锁**：在业务逻辑执行完毕后，务必在 finally 块中释放锁，以防止死锁。
    - **锁的有效期**：合理设置锁的有效期，避免长时间持有锁。
    - **异常处理**：适当处理加锁和解锁过程中可能出现的异常。
    - **分布式环境考量**：在分布式环境下，确保锁的使用不会导致系统整体性能下降。
    
    使用 Redisson 的分布式锁是在分布式系统中处理并发问题的一个有效工具，它利用了 Redis 的高性能和高可用性特性，为 Java 应用提供了一种可靠的锁机制。

# 基于 Redis 的分布式锁优化

## 应用场景

可重入锁非常适用于需要多次执行加锁操作的场景，例如：

- **递归调用**：一个递归函数在每次调用时都需要加锁。
- **跨方法加锁**：在一个方法中获取锁后，调用另一个也需要加锁的方法。

![[%E6%88%AA%E5%B1%8F2024-01-13_%E4%B8%8B%E5%8D%886.58.56.png]]

在上面的代码和流程图中，锁被尝试获取两次是因为存在两个不同的方法（`method1` 和 `method2`），并且每个方法都尝试获取相同的锁。在这种情况下，锁需要被获取两次的原因通常是为了确保在递归调用或者嵌套调用中，一个线程可以多次进入临界区而不会被自己阻塞。这样的锁称为“可重入锁”。
## 代码的逻辑

1. `method1` 尝试获取锁，如果成功，它会继续执行并打印日志。
2. `method1` 在持有锁的状态下调用 `method2`。
3. `method2` 同样尝试获取锁。由于锁是可重入的，这个操作是允许的，因为已经是由相同的线程（即正在执行 `method1` 的线程）

持有锁。如果锁不是可重入的，这将会失败，因为锁已经被持有。

1. `method2` 获取锁之后执行其业务逻辑，然后在 `finally` 块中释放锁。但由于是可重入锁，这次释放不会真正释放锁，只会减少锁的持有计数。
2. 控制权回到 `method1`，在它的 `finally` 块中，它再次释放锁。由于这是最后一次释放（锁的持有计数归零），锁此时真正被释放。

在这个过程中，锁的获取次数与释放次数是对应的。这是可重入锁的基本特性，确保了同一个线程可以在不同的方法中多次获取同一个锁，而不会导致死锁。

在实际应用中，可重入锁对于编写复杂的同步代码非常有用，因为开发者不需要担心每个锁获取的确切位置，只需要确保每个锁获取都有一个相应的锁释放。这简化了同步代码的编写和理解。

### 场景描述

假设您有一个 `OrderService` 类，它有一个 `processOrder` 方法和一个 `updateInventory` 方法。`processOrder` 方法在处理订单时需要调用 `updateInventory` 方法来更新库存。

```Java
public class OrderService {
    private final RLock lock = redissonClient.getLock("orderLock");

    public void processOrder(String itemId, int quantity) {
        lock.lock(); // 第一次获取锁
        try {
            if (checkInventory(itemId, quantity)) {
                createOrder(itemId, quantity);
                updateInventory(itemId, -quantity); // 更新库存，内部会尝试再次获取锁
            }
        } finally {
            lock.unlock(); // 第一次释放锁
        }
    }

    public void updateInventory(String itemId, int quantity) {
        lock.lock(); // 第二次获取锁（可重入）
        try {
            // 执行库存更新逻辑
        } finally {
            lock.unlock(); // 第二次释放锁
        }
    }

    // ... 其他方法，如 checkInventory 和 createOrder ...
}
```

在这个场景中，`processOrder` 方法在调用 `updateInventory` 之前已经获取了锁。如果锁不是可重入的，那么 `updateInventory` 尝试获取锁时会发生死锁，因为它会等待 `processOrder` 释放锁。但由于锁是可重入的，`updateInventory` 可以在不阻塞的情况下再次获取同一个锁。

# Redission锁重试和WatchDog机制

## 锁重试

在Redisson中，当一个线程尝试获取一个已经被其他线程持有的锁时，它会进入阻塞状态，直到锁变得可用。锁重试机制是指在锁被其他线程持有时，当前尝试获取锁的线程会周期性地重试，直到它成功获得锁或达到一定的超时限制。这种机制确保了在高竞争的环境下，线程仍有机会按照一定的间隔尝试获取锁，而不是一直处于无限等待状态。

## 看门狗机制

Redisson 的看门狗（WatchDog）机制的自动续期和在客户端故障时的锁释放，看起来是基于两种不同的逻辑，但它们**实际上是为了处理分布式锁中两个关键的问题**：

1. 保证在正常操作中锁的持续性; 
2. 确保在异常情况下锁的可恢复性。

这两者共同确保了分布式系统中的资源同步和稳定性。
### 自动续期

自动续期是指，在**持有锁的客户端仍活跃**的情况下，看门狗会**定期检查并自动延长锁的过期时间**。这确保了在执行长时间操作时，锁**不会意外过期**，导致其他客户端错误地认为资源已经释放。自动续期是基于客户端活跃性的一个保护措施，它避免了因操作时间超出最初预设的锁持续时间而无意中丢失锁的情况。

### 防止客户端故障导致的资源锁定

另一方面，如果**客户端因为崩溃或其他原因变得不再响应**，看门狗无法继续从该客户端接收到活跃的信号，也就无法执行续期操作。因此，**锁会在预设的过期时间后自动释放**。这是一种**安全机制**，防止因客户端故障而导致的资源长时间锁定，它使得其他客户端可以在合理的时间后获取到锁，并继续执行相关的操作。

这两种机制的共存，使得 Redisson 的锁**既能适应长时间的操作需求**，**也能处理突发的客户端故障**，有效平衡了系统的健壮性和响应性。这种设计是处理分布式环境中的锁定问题的一种有效方式，确保了系统在多种情况下的正常运作。
# Redission锁的MutiLock原理

为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例。

此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。

# Redisson 的分布式锁主从一致性问题

在 Redisson 的 multi-lock 机制中，涉及的是多个不同的锁，而不是同一个锁的多次实例。这些锁可以位于不同的 Redis 节点上。

1. **多个锁实例**：Multi-lock 涉及的是多个锁实例。这些锁可能分布在不同的 Redis 节点上，每个节点上的锁都是独立的。
2. **独立性**：每个锁都是独立的实体。虽然它们被组合在一起以形成一个 multi-lock，但每个锁的状态和操作都是独立的。
3. **锁定过程**：当请求 multi-lock 时，Redisson 会尝试在所有指定的 Redis 节点上获取各自的锁。只有当所有锁都成功获取时，整个 multi-lock 才被认为是锁定的。
4. **原子操作**：整个锁定和解锁过程是原子的。这意味着不会出现部分锁被锁定而其他锁未被锁定的情况。要么所有锁同时被锁定，要么都不被锁定。
5. **用途**：这种机制通常用于分布式系统中的复杂同步问题，特别是当需要跨多个 Redis 节点协调资源时。

总的来说，multi-lock 机制提供了一种强大的方式来在分布式环境中同步操作，确保了操作的一致性和原子性。

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%884.46.57.png]]

# 总结

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%885.07.33.png|400]]

三种不同类型的 Redis 锁机制，每种都有其用途和缺点：

1. **不可重入的 Redis 分布式锁**：
    - **用途**：这种锁使用 `setnx` 命令来实现。它是最基础的锁机制，当锁不存在时可以设置锁，使用完后需要显式地释放。
    - **缺点**：它的主要缺点是不可重入，即同一个客户端在锁已经被自己获取的情况下不能再次获取，否则会被阻塞。
2. **可重入的 Redis 分布式锁**：
    - **用途**：相比于不可重入锁，可重入锁允许同一个线程多次获取同一把锁。它使用了 `hash` 数据结构来追踪锁的持有者，并结合 `watchDog` 机制自动延长锁的有效期，确保长时间运行的任务不会因为锁超时而被中断。
    - **缺点**：相对复杂，需要额外的机制来维护锁的状态和延长锁的有效期。
3. **Redisson 的 multiLock**：
    - **用途**：multiLock 是 Redisson 客户端提供的一个高级锁机制，它允许跨多个 Redis 节点实现锁的集合。只有当所有指定的锁都被成功获取时，才算整体上锁成功，适合于涉及多个资源的复杂操作。
    - **缺点**：实现较为复杂，因为需要协调多个节点上的锁状态，保证原子性。

这三种锁机制各有适用场景，设计得当时能够很好地在分布式系统中管理对共享资源的访问。在选择合适的锁类型时，需要根据实际的应用场景和需求来决定。