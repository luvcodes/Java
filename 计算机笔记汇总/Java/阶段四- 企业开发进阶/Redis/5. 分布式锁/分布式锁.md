
分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。

分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路。

![[Pasted image 20240507103122.png]]


那么分布式锁他应该满足一些什么样的条件呢？

- 可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思

- 互斥：互斥是分布式锁的最基本的条件，使得程序串行执行

- 高可用：程序不易崩溃，时时刻刻都保证较高的可用性

- 高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能

- 安全性：安全也是程序中必不可少的一环


![[%E6%88%AA%E5%B1%8F2024-01-12_%E4%B8%8B%E5%8D%883.57.41.png]]

分布式锁的核心是实现多线程之间的互斥

常见的分布式锁有三种

Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见

Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁

Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述

![[%E6%88%AA%E5%B1%8F2024-01-12_%E4%B8%8B%E5%8D%884.07.21.png]]

# 基于Redis的分布式锁

![[%E6%88%AA%E5%B1%8F2024-01-12_%E4%B8%8B%E5%8D%884.17.04.png]]
核心思路：

我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可。

![[Pasted image 20240507103237.png|475]]




在 JDK 里提供的锁实际上有两种机制: 
1. 阻塞等待: 获取锁失败，等到有人释放锁
2. 非阻塞等待: 尝试获取锁，如果获取失败，就返回一个结果

这里是展示非阻塞等待的机制，阻塞机制对 CPU 有要求。


## Redis分布式锁误删情况说明

### 逻辑说明

持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程 2 来尝试获得锁，就拿到了这把锁，然后线程 2 在持有锁执行过程中，线程 1 反应过来，继续执行，而线程 1 执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程 2 的锁进行删除，这就是误删别人锁的情况说明。

在使用 Redis 分布式锁的场景中，**误删是指一个客户端错误地删除了另一个客户端持有的锁**。这种情况通常发生在以下几个场景：

1. **锁超时**：如果锁持有者在锁自动过期（超时）之前未能完成其任务，锁会被自动释放。此时，如果另一个客户端获取了锁并开始执行任务，**原客户端完成任务**后可能会**错误地删除新客户端设置的锁**。

2. **客户端混淆**：在没有正确检查锁的归属（即锁是由哪个客户端设置的）的情况下，一个客户端可能会误删除另一个客户端的锁。

### 解决方案

解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。

在 Redis 锁中**使用一个唯一标识符来验证锁的归属**，确保只有锁的设置者才能删除该锁。此外，使用更复杂的锁机制，如 Redlock 算法，可以进一步减少这种风险。

![[Pasted image 20240507113735.png]]

## 解决Redis分布式锁误删问题

需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示） 在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致

- 如果一致则释放锁

- 如果不一致则不释放锁

核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。

![[Pasted image 20240507142137.png|300]]

重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。

# 分布式锁的原子性问题

更为极端的误删逻辑说明：

线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经**走到了条件判断的过程**中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题。

之所以有这个问题，是因为线程1的**拿锁，比锁，删锁，实际上并不是原子性的**，我们要防止刚才的情况发生。

![[Pasted image 20240507143523.png|500]]

# Lua脚本解决多条命令原子性问题

Redis 的 Lua 脚本是一种功能，允许用户在 Redis 服务器上运行 Lua 脚本。这些脚本在 Redis 服务器内部执行，可以用来处理复杂的操作，比如事务、计算或者流程控制。

使用 Lua 脚本的**主要优点**是它们在执行时是**原子性**的，这意味着在一个脚本执行的过程中不会被其他 Redis 命令或脚本中断。

Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：[https://www.runoob.com/lua/lua-tutorial.html](https://www.runoob.com/lua/lua-tutorial.html)，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。

这里重点介绍Redis提供的调用函数，语法如下：

```lua
redis.call('命令名称', 'key', '其它参数', ...)
```

例如，我们要执行set name jack，则脚本是这样：

```lua
redis.call('set', 'name', 'jack')
```

例如，我们要先执行set name Rose，再执行get name，则脚本如下：

```lua
# 先执行 set name jack  
redis.call('set', 'name', 'Rose')  
# 再执行 get name  
local name = redis.call('get', 'name')  
# 返回  
return name
```

写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：

![[Pasted image 20240507143817.png|500]]

例如，我们要执行 redis.call('set', 'name', 'jack') 这个脚本，语法如下：

![[Pasted image 20240507143832.png|500]]

如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：

![[Pasted image 20240507143859.png|600]]

接下来我们来回一下我们释放锁的逻辑：

释放锁的业务流程是这样的

1、获取锁中的线程标示

2、判断是否与指定的标示（当前线程标示）一致

3、如果一致则释放锁（删除）

4、如果不一致则什么都不做

如果用Lua脚本来表示则是这样的：

最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样

```lua
-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示  
-- 获取锁中的标示，判断是否与当前线程标示一致  
if (redis.call('GET', KEYS[1]) == ARGV[1]) then  
  -- 一致，则删除锁  
  return redis.call('DEL', KEYS[1])  
end  
-- 不一致，则直接返回  
return 0
```


## 保证原子性

如果不使用 Lua 脚本，某些操作在 Redis 中可能无法保证原子性。在 Redis 中，原子性是指一个操作或一系列操作要么完全执行，要么完全不执行，且在执行过程中不会被其他操作打断。不使用 Lua 脚本时，连续的 Redis 命令之间可能会被其他客户端的命令打断，从而导致数据不一致或逻辑错误。

### 丧失原子性的例子

1. **计数器递增**：
    - 假设有一个操作是检查一个键是否存在，如果存在则递增它的值。
    - 使用单独的命令，你可能会先调用 `EXISTS` 检查键是否存在，然后调用 `INCR` 递增键的值。
    - 在这两个命令之间，如果另一个客户端删除了这个键，那么你的 `INCR` 操作将意外地创建一个新键并设置其值为 1，这违反了原本的逻辑意图。
2. **库存扣减**：
    - 在处理例如电商网站的订单时，你可能需要先检查产品的库存量是否足够，然后再进行扣减。
    - 使用非原子操作，你可能先获取库存量，然后再执行扣减操作。
    - 如果在这两步操作之间，另一个操作更改了库存量，可能会导致超卖的情况。
3. **组合读写操作**：
    - 假设你想更新一个键的值，但更新的逻辑依赖于当前的值。
    - 你可能首先读取这个键的值，根据这个值来计算新值，然后再进行更新。
    - 如果在读取和更新之间，其他客户端修改了这个键的值，你的更新可能就是基于过时的信息。

### 使用 Lua 脚本保证原子性

在上述每个例子中，使用 Lua 脚本可以保证整个操作的原子性。Lua 脚本在执行时，不会被其他 Redis 命令打断，因此可以确保即使在高并发的环境下，操作的整体性和顺序性得以保持。例如，你可以将检查库存和扣减库存的操作写在一个 Lua 脚本中，这样整个操作要么完全执行，要么完全不执行，不会出现因并发操作导致的数据不一致问题。

  

![[%E6%88%AA%E5%B1%8F2024-01-13_%E4%B8%8B%E5%8D%884.45.15.png]]

  

# 基于Redis的分布式锁优化

## 概念

Redisson 是一个在 Java 中广泛使用的 Redis 客户端库，它提供了一套丰富的分布式数据结构和分布式服务。其中，Redisson 对 Redis 的分布式锁特性提供了高级的封装，使其在 Java 应用中易于使用。

1. **概念**：
    - Redisson 的分布式锁是基于 Redis 实现的，它提供了跨多个节点的同步机制。
    - 使用 Redis 的特性，比如 `SETNX`（set if not exists），`EXPIRE`（设置过期时间）等来实现锁的功能。
2. **特点**：
    - **安全性**：确保在分布式环境中，同一时刻只有一个进程可以持有锁。
    - **死锁避免**：通过设置锁的有效期来防止死锁的发生。
    - **性能**：由于基于 Redis，因此性能较高。

## Redisson入门

使用 Redisson 实现分布式锁的步骤大致如下：

1. **添加依赖**：  
    在你的 Java 项目中添加 Redisson 的依赖。如果使用 Maven，可以在  
    `pom.xml` 中添加如下依赖：
    
    ```XML
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
        <version>最新版本</version>
    </dependency>
    ```
    
2. **配置 Redisson 客户端**：  
    创建并配置 Redisson 客户端实例。这通常涉及指定 Redis 服务器的地址和其他相关配置。  
    
    ```Java
    Config config = new Config();
    config.useSingleServer().setAddress("redis://127.0.0.1:6379");
    RedissonClient redisson = Redisson.create(config);
    ```
    
3. **获取分布式锁**：  
    使用 Redisson 获取分布式锁实例。锁是通过一个唯一的名称标识的。  
    
    ```Java
    RLock lock = redisson.getLock("myLock");
    ```
    
4. **加锁和解锁**：  
    使用  
    `lock()` 和 `unlock()` 方法来加锁和解锁。
    
    ```Java
    try {
        // 尝试获取锁，可以指定等待时间和锁的持有时间
        if (lock.tryLock(10, 2, TimeUnit.SECONDS)) {
            try {
                // 执行业务逻辑
            } finally {
                lock.unlock();
            }
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
    ```
    

这段代码演示了如何在 Java 中使用 Redisson 实现分布式锁。

**尝试获取锁**

```Java
if (lock.tryLock(10, 2, TimeUnit.SECONDS)) {
    // ...
}
```

- `**tryLock**` **方法**：这个方法尝试获取锁。
    - **第一个参数（10）**：这是尝试获取锁的最大等待时间。在这个例子中，如果锁在 10 秒内不可用，当前线程将停止等待。
    - **第二个参数（2）**：这是锁的持有时间。一旦锁被获取，它将至少保持锁状态 2 秒。
    - **第三个参数（**`**TimeUnit.SECONDS**`**）**：这是时间单位，本例中使用的是秒。
- **逻辑**：`tryLock` 会立即返回一个布尔值。如果获取到锁，返回 `true`；如果在指定的等待时间内未能获取到锁，返回 `false`。
- 一个线程使用 tryLock 方法尝试获取锁时，如果锁已经被另一个线程持有，那么这个线程将等待指定的时间（在您的例子中是10秒）以尝试获取锁。
    - 如果在这个等待时间内，锁被释放并且当前线程成功获取到锁，tryLock 会返回 true 并且线程将继续执行。
    - 如果在等待时间结束时，线程仍然未能获取到锁，那么会发生以下情况：
        - 直接放弃：tryLock 方法会返回 false。这表示线程在指定的等待时间内未能获取锁。
        - 不会强行获取：**线程不会强制获取锁，也不会继续等待**。它会退出锁获取的尝试。 在这种情况下，通常你**需要在代码中处理未能获取锁的情况**。

**执行业务逻辑**

```Java
try {
    // 执行业务逻辑
} finally {
    lock.unlock();
}
```

- 当获取到锁后，你可以在这个 `try` 块中执行业务逻辑。
- 无论业务逻辑执行过程中发生了什么（即使是异常），`finally` 块都将确保锁被释放。

**解锁**

- `**lock.unlock()**`：这行代码在 `finally` 块中调用，确保锁无论如何都会被释放。这是避免死锁非常重要的一步，特别是在多线程和分布式环境中。

**异常处理**

- `**catch (InterruptedException e)**`：这个 `catch` 块处理了在等待锁的过程中可能发生的中断异常。
- `**Thread.currentThread().interrupt();**`：这行代码重新设置当前线程的中断状态。这在处理多线程时是一种常规做法，它确保高层代码可以感知到中断并且可以进一步处理。

  

1. **关闭客户端**：  
    在应用程序关闭时，关闭 Redisson 客户端。  
    
    ```Java
    redisson.shutdown();
    ```
    
    ## 注意事项
    
    - **确保解锁**：在业务逻辑执行完毕后，务必在 finally 块中释放锁，以防止死锁。
    - **锁的有效期**：合理设置锁的有效期，避免长时间持有锁。
    - **异常处理**：适当处理加锁和解锁过程中可能出现的异常。
    - **分布式环境考量**：在分布式环境下，确保锁的使用不会导致系统整体性能下降。
    
    使用 Redisson 的分布式锁是在分布式系统中处理并发问题的一个有效工具，它利用了 Redis 的高性能和高可用性特性，为 Java 应用提供了一种可靠的锁机制。
    
      
    

# Redisson的可重入锁

Redisson 的可重入锁（Reentrant Lock）是一种特殊类型的锁，它允许同一个线程多次获取同一把锁而不会发生死锁。在分布式系统中，这种锁的行为类似于 Java 中 `java.util.concurrent.locks.ReentrantLock` 的行为。

## 特点

1. **可重入性**：
    - 如果一个线程已经持有了锁，它可以再次获取这个锁而不会被自己阻塞。这对于递归函数或者一个函数在多个地方需要多次加锁的情况非常有用。
2. **防止死锁**：
    - 在传统的锁机制中，如果一个线程试图获取它已经持有的锁，将会导致死锁。而可重入锁避免了这个问题，因为它允许同一个线程多次获取同一把锁。
3. **锁计数**：
    - 当一个线程首次获取锁时，锁计数为1。每当同一线程再次获取锁时，计数增加。每当线程释放锁时，计数减少。只有当计数降至0时，锁才被完全释放。
4. **线程所有权**：
    - 可重入锁跟踪哪个线程持有了锁，并且只有锁的持有者才能释放锁。

## 应用场景

可重入锁非常适用于需要多次执行加锁操作的场景，例如：

- **递归调用**：一个递归函数在每次调用时都需要加锁。
- **跨方法加锁**：在一个方法中获取锁后，调用另一个也需要加锁的方法。

  

![[%E6%88%AA%E5%B1%8F2024-01-13_%E4%B8%8B%E5%8D%886.58.56.png]]

在上面的代码和流程图中，锁被尝试获取两次是因为存在两个不同的方法（`method1` 和 `method2`），并且每个方法都尝试获取相同的锁。在这种情况下，锁需要被获取两次的原因通常是为了确保在递归调用或者嵌套调用中，一个线程可以多次进入临界区而不会被自己阻塞。这样的锁称为“可重入锁”。

## 可重入锁的使用场景：

1. **递归调用**：当一个同步方法递归调用自己时，线程已经持有了锁，但是由于递归调用它需要再次获取锁。如果锁不是可重入的，线程将会因为尝试获取它已经持有的锁而阻塞。
2. **嵌套方法调用**：当一个同步方法在持有锁的情况下调用另一个同步方法，需要再次获取锁。如果锁不是可重入的，这将会导致死锁。

## 代码的逻辑：

1. `method1` 尝试获取锁，如果成功，它会继续执行并打印日志。
2. `method1` 在持有锁的状态下调用 `method2`。
3. `method2` 同样尝试获取锁。由于锁是可重入的，这个操作是允许的，因为已经是由相同的线程（即正在执行 `method1` 的线程）

持有锁。如果锁不是可重入的，这将会失败，因为锁已经被持有。

1. `method2` 获取锁之后执行其业务逻辑，然后在 `finally` 块中释放锁。但由于是可重入锁，这次释放不会真正释放锁，只会减少锁的持有计数。
2. 控制权回到 `method1`，在它的 `finally` 块中，它再次释放锁。由于这是最后一次释放（锁的持有计数归零），锁此时真正被释放。

在这个过程中，锁的获取次数与释放次数是对应的。这是可重入锁的基本特性，确保了同一个线程可以在不同的方法中多次获取同一个锁，而不会导致死锁。

在实际应用中，可重入锁对于编写复杂的同步代码非常有用，因为开发者不需要担心每个锁获取的确切位置，只需要确保每个锁获取都有一个相应的锁释放。这简化了同步代码的编写和理解。

  

一个实际的业务场景，其中可重入锁非常有用，是在处理电子商务网站的订单系统中的多步骤事务性操作。假设一个系统需要在处理一个订单时执行以下步骤：

1. **验证库存**：检查所购买商品的库存量是否足够。
2. **创建订单**：如果库存充足，创建一个新的订单记录。
3. **更新库存**：订单创建后，相应减少库存数量。
4. **计算积分**：为用户计算购买后的积分，并更新积分记录。

这些步骤可能涉及到多个方法调用，并且每个方法都可能需要访问共享资源（如库存和积分数据），这需要同步以避免并发问题。

### 场景描述

假设您有一个 `OrderService` 类，它有一个 `processOrder` 方法和一个 `updateInventory` 方法。`processOrder` 方法在处理订单时需要调用 `updateInventory` 方法来更新库存。

```Java
public class OrderService {
    private final RLock lock = redissonClient.getLock("orderLock");

    public void processOrder(String itemId, int quantity) {
        lock.lock(); // 第一次获取锁
        try {
            if (checkInventory(itemId, quantity)) {
                createOrder(itemId, quantity);
                updateInventory(itemId, -quantity); // 更新库存，内部会尝试再次获取锁
            }
        } finally {
            lock.unlock(); // 第一次释放锁
        }
    }

    public void updateInventory(String itemId, int quantity) {
        lock.lock(); // 第二次获取锁（可重入）
        try {
            // 执行库存更新逻辑
        } finally {
            lock.unlock(); // 第二次释放锁
        }
    }

    // ... 其他方法，如 checkInventory 和 createOrder ...
}
```

在这个场景中，`processOrder` 方法在调用 `updateInventory` 之前已经获取了锁。如果锁不是可重入的，那么 `updateInventory` 尝试获取锁时会发生死锁，因为它会等待 `processOrder` 释放锁。但由于锁是可重入的，`updateInventory` 可以在不阻塞的情况下再次获取同一个锁。

# Redisson的分布式锁主从一致性问题

在Redisson的multi-lock机制中，涉及的是多个不同的锁，而不是同一个锁的多次实例。这些锁可以位于不同的Redis节点上。

1. **多个锁实例**：Multi-lock涉及的是多个锁实例。这些锁可能分布在不同的Redis节点上，每个节点上的锁都是独立的。
2. **独立性**：每个锁都是独立的实体。虽然它们被组合在一起以形成一个multi-lock，但每个锁的状态和操作都是独立的。
3. **锁定过程**：当请求multi-lock时，Redisson会尝试在所有指定的Redis节点上获取各自的锁。只有当所有锁都成功获取时，整个multi-lock才被认为是锁定的。
4. **原子操作**：整个锁定和解锁过程是原子的。这意味着不会出现部分锁被锁定而其他锁未被锁定的情况。要么所有锁同时被锁定，要么都不被锁定。
5. **用途**：这种机制通常用于分布式系统中的复杂同步问题，特别是当需要跨多个Redis节点协调资源时。

总的来说，multi-lock机制提供了一种强大的方式来在分布式环境中同步操作，确保了操作的一致性和原子性。

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%884.46.57.png]]

  

# 总结

  

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%885.07.33.png]]

三种不同类型的Redis锁机制，每种都有其用途和缺点：

1. **不可重入的Redis分布式锁**：
    - **用途**：这种锁使用`setnx`命令来实现。它是最基础的锁机制，当锁不存在时可以设置锁，使用完后需要显式地释放。
    - **缺点**：它的主要缺点是不可重入，即同一个客户端在锁已经被自己获取的情况下不能再次获取，否则会被阻塞。
2. **可重入的Redis分布式锁**：
    - **用途**：相比于不可重入锁，可重入锁允许同一个线程多次获取同一把锁。它使用了`hash`数据结构来追踪锁的持有者，并结合`watchDog`机制自动延长锁的有效期，确保长时间运行的任务不会因为锁超时而被中断。
    - **缺点**：相对复杂，需要额外的机制来维护锁的状态和延长锁的有效期。
3. **Redisson的multiLock**：
    - **用途**：multiLock是Redisson客户端提供的一个高级锁机制，它允许跨多个Redis节点实现锁的集合。只有当所有指定的锁都被成功获取时，才算整体上锁成功，适合于涉及多个资源的复杂操作。
    - **缺点**：实现较为复杂，因为需要协调多个节点上的锁状态，保证原子性。

这三种锁机制各有适用场景，设计得当时能够很好地在分布式系统中管理对共享资源的访问。在选择合适的锁类型时，需要根据实际的应用场景和需求来决定。

  

# Redis的优化秒杀

## 秒杀优化的流程

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%886.00.06.png]]

  

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%888.49.18.png]]