# 可重入锁

## 概念

可重入锁（Reentrant Lock）是一种允许同一个线程多次获得同一把锁的同步机制。在Java中，`synchronized` 关键字就提供了可重入锁的功能。下面是可重入锁的几个主要特点：

1. **线程安全**：可重入锁可以确保当一个线程执行锁定代码块时，其他线程不能执行该代码块，从而保持线程安全。

2. **避免死锁**：如果一个锁不是可重入的，那么线程尝试再次获取它已持有的锁时会导致死锁。可重入锁允许线程再次获得它已经持有的锁，这可以避免在递归调用或一系列调用中出现死锁。

3. **灵活性**：由于可重入锁可以重复获取，它提供了更大的灵活性，使得编程模式可以根据需要自由地进入和退出同步代码块，而不会遇到锁管理问题。

4. **递归调用支持**：可重入锁非常适合递归调用，因为递归调用通常涉及多次进入同一个方法，如果方法是同步的，那么需要可重入锁来支持这种调用模式。

5. **锁持有计数**：可重入锁内部通常有一个计数器来追踪同一个线程获取锁的次数。线程每获取一次锁，计数器加一；每释放一次锁，计数器减一。当计数器归零时，锁被释放。

在使用可重入锁时，程序员需要确保在任何情况下，锁最终都能被释放，以防止潜在的锁泄漏问题。这通常是通过在`finally`块中释放锁来实现的，确保即使在发生异常时锁也能被正确释放。
## 示例说明

让我们通过一个简单的例子来解释为什么不可重入锁在某些情况下会导致死锁。

假设我们有一个不可重入锁（尽管 Java 中的 `synchronized` 是可重入的，我们这里假设它不是，以便说明问题）。我们有两个由这个锁保护的方法，方法 A 和方法 B，它们都需要获取相同的锁：

```java
public synchronized void methodA() {
    // 一些操作
    methodB();
}

public synchronized void methodB() {
    // 一些操作
}
```

如果锁是不可重入的，情况将如下发展：

1. 线程 T 开始执行 `methodA()`，它为此方法获取锁。
2. 在 `methodA()` 的执行过程中，线程 T 尝试调用 `methodB()`。
3. 由于 `methodB()` 也需要获取相同的锁，线程 T 试图再次获取已经由它自己持有的锁。
4. **如果锁是不可重入的**，线程 T 不能再次获取锁，因为锁已经被占用，而且系统不允许同一线程重复获取同一锁。
5. 结果，**线程 T 在等待释放它已经持有的锁，以便进入 `methodB()`。这导致线程 T 被阻塞，无法继续执行。**
6. 由于没有其他线程可以释放这个锁（因为锁是由线程 T 自己持有的），**线程 T 将永远等待，进入了死锁状态。**

在这个例子中，线程 T 因为等待一个它自己已经持有的锁而被阻塞，而这个锁又无法被释放，因为释放锁需要线程 T 继续执行。这种情况就是典型的死锁。

在实际应用中，这就是为什么可重入锁非常重要。它们允许线程再次获取已经持有的锁，从而避免了这类死锁的问题。Java 中的 `synchronized` 关键字实现的就是这样一个可重入锁，允许同一个线程多次获取同一个锁，从而安全地调用多个 `synchronized` 方法或代码块。
## 可重入锁的使用场景

1. **递归调用**：当一个同步方法递归调用自己时，线程已经持有了锁，但是由于递归调用它需要再次获取锁。如果锁不是可重入的，线程将会因为尝试获取它已经持有的锁而阻塞。
2. **嵌套方法调用**：当一个同步方法在持有锁的情况下调用另一个同步方法，需要再次获取锁。如果锁不是可重入的，这将会导致死锁。
# 不可重入锁

不可重入锁是一种同步机制，它不允许同一个线程多次获得同一把锁。这意味着一旦一个线程获得了锁，即使是同一个线程，如果再次尝试获取这个锁，也会被阻塞，直到锁被释放。这种锁的特性可以导致死锁，尤其是在递归调用或者一个线程在持有锁的同时尝试再次获取同一锁时。

## 不可重入锁概念

1. **简单实现**：不可重入锁通常实现起来比可重入锁简单，因为它不需要跟踪锁的所有者以及锁被获取的次数。
2. **高风险**：由于不支持同一线程的多次获取，不可重入锁使用不当时容易导致死锁。
3. **限制性**：这种锁限制了编程模式，因为开发者必须非常小心地管理锁的获取和释放，避免重复获取锁。

## 示例说明

假设我们有一个不可重入的锁实现，并且一个线程试图两次获取这个锁：

```java
public class NonReentrantLock {
    private boolean isLocked = false;

    public synchronized void lock() throws InterruptedException {
        while (isLocked) {
            wait();
        }
        isLocked = true;
    }

    public synchronized void unlock() {
        isLocked = false;
        notify();
    }
}

public class Example {
    NonReentrantLock lock = new NonReentrantLock();

    public void doSomething() throws InterruptedException {
        lock.lock();
        try {
            // 做一些工作...
            anotherMethod();  // 在此方法中尝试再次获取锁
        } finally {
            lock.unlock();
        }
    }

    public void anotherMethod() throws InterruptedException {
        lock.lock();
        try {
            // 做其他工作
        } finally {
            lock.unlock();
        }
    }
}
```

在这个示例中，如果 `doSomething()` 方法被调用，它将首先获取锁，并在执行过程中调用 `anotherMethod()`。在 `anotherMethod()` 中，程序再次尝试获取同一锁。由于这是一个不可重入锁，这个尝试会导致线程在等待它自己释放锁，从而产生死锁。

这个例子说明了不可重入锁的使用风险，以及为什么在设计锁和同步结构时，通常优先考虑可重入锁，尤其是在复杂的应用程序中。