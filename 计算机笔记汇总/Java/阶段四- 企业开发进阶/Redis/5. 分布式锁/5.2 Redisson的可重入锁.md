# 基于 Redis 的分布式锁优化

## 应用场景

可重入锁非常适用于需要多次执行加锁操作的场景，例如：

- **递归调用**：一个递归函数在每次调用时都需要加锁。
- **跨方法加锁**：在一个方法中获取锁后，调用另一个也需要加锁的方法。

![[%E6%88%AA%E5%B1%8F2024-01-13_%E4%B8%8B%E5%8D%886.58.56.png]]

在上面的代码和流程图中，锁被尝试获取两次是因为存在两个不同的方法（`method1` 和 `method2`），并且每个方法都尝试获取相同的锁。在这种情况下，锁需要被获取两次的原因通常是为了确保在递归调用或者嵌套调用中，一个线程可以多次进入临界区而不会被自己阻塞。这样的锁称为“可重入锁”。

## 可重入锁的使用场景：

1. **递归调用**：当一个同步方法递归调用自己时，线程已经持有了锁，但是由于递归调用它需要再次获取锁。如果锁不是可重入的，线程将会因为尝试获取它已经持有的锁而阻塞。
2. **嵌套方法调用**：当一个同步方法在持有锁的情况下调用另一个同步方法，需要再次获取锁。如果锁不是可重入的，这将会导致死锁。

## 代码的逻辑：

1. `method1` 尝试获取锁，如果成功，它会继续执行并打印日志。
2. `method1` 在持有锁的状态下调用 `method2`。
3. `method2` 同样尝试获取锁。由于锁是可重入的，这个操作是允许的，因为已经是由相同的线程（即正在执行 `method1` 的线程）

持有锁。如果锁不是可重入的，这将会失败，因为锁已经被持有。

1. `method2` 获取锁之后执行其业务逻辑，然后在 `finally` 块中释放锁。但由于是可重入锁，这次释放不会真正释放锁，只会减少锁的持有计数。
2. 控制权回到 `method1`，在它的 `finally` 块中，它再次释放锁。由于这是最后一次释放（锁的持有计数归零），锁此时真正被释放。

在这个过程中，锁的获取次数与释放次数是对应的。这是可重入锁的基本特性，确保了同一个线程可以在不同的方法中多次获取同一个锁，而不会导致死锁。

在实际应用中，可重入锁对于编写复杂的同步代码非常有用，因为开发者不需要担心每个锁获取的确切位置，只需要确保每个锁获取都有一个相应的锁释放。这简化了同步代码的编写和理解。

一个实际的业务场景，其中可重入锁非常有用，是在处理电子商务网站的订单系统中的多步骤事务性操作。假设一个系统需要在处理一个订单时执行以下步骤：

1. **验证库存**：检查所购买商品的库存量是否足够。
2. **创建订单**：如果库存充足，创建一个新的订单记录。
3. **更新库存**：订单创建后，相应减少库存数量。
4. **计算积分**：为用户计算购买后的积分，并更新积分记录。

这些步骤可能涉及到多个方法调用，并且每个方法都可能需要访问共享资源（如库存和积分数据），这需要同步以避免并发问题。

### 场景描述

假设您有一个 `OrderService` 类，它有一个 `processOrder` 方法和一个 `updateInventory` 方法。`processOrder` 方法在处理订单时需要调用 `updateInventory` 方法来更新库存。

```Java
public class OrderService {
    private final RLock lock = redissonClient.getLock("orderLock");

    public void processOrder(String itemId, int quantity) {
        lock.lock(); // 第一次获取锁
        try {
            if (checkInventory(itemId, quantity)) {
                createOrder(itemId, quantity);
                updateInventory(itemId, -quantity); // 更新库存，内部会尝试再次获取锁
            }
        } finally {
            lock.unlock(); // 第一次释放锁
        }
    }

    public void updateInventory(String itemId, int quantity) {
        lock.lock(); // 第二次获取锁（可重入）
        try {
            // 执行库存更新逻辑
        } finally {
            lock.unlock(); // 第二次释放锁
        }
    }

    // ... 其他方法，如 checkInventory 和 createOrder ...
}
```

在这个场景中，`processOrder` 方法在调用 `updateInventory` 之前已经获取了锁。如果锁不是可重入的，那么 `updateInventory` 尝试获取锁时会发生死锁，因为它会等待 `processOrder` 释放锁。但由于锁是可重入的，`updateInventory` 可以在不阻塞的情况下再次获取同一个锁。

# Redisson 的可重入锁

Redisson 的可重入锁（Reentrant Lock）是一种特殊类型的锁，它允许同一个线程多次获取同一把锁而不会发生死锁。在分布式系统中，这种锁的行为类似于 Java 中 `java.util.concurrent.locks.ReentrantLock` 的行为。

## 特点

1. **可重入性**：
    - 如果一个线程已经持有了锁，它可以再次获取这个锁而不会被自己阻塞。这对于递归函数或者一个函数在多个地方需要多次加锁的情况非常有用。
2. **防止死锁**：
    - 在传统的锁机制中，如果一个线程试图获取它已经持有的锁，将会导致死锁。而可重入锁避免了这个问题，因为它允许同一个线程多次获取同一把锁。
3. **锁计数**：
    - 当一个线程首次获取锁时，锁计数为 1。每当同一线程再次获取锁时，计数增加。每当线程释放锁时，计数减少。只有当计数降至 0 时，锁才被完全释放。
4. **线程所有权**：
    - 可重入锁跟踪哪个线程持有了锁，并且只有锁的持有者才能释放锁。


## 概念

Redisson 是一个在 Java 中广泛使用的 Redis 客户端库，它提供了一套丰富的分布式数据结构和分布式服务。其中，Redisson 对 Redis 的分布式锁特性提供了高级的封装，使其在 Java 应用中易于使用。

1. **概念**：
    - Redisson 的分布式锁是基于 Redis 实现的，它提供了跨多个节点的同步机制。
    - 使用 Redis 的特性，比如 `SETNX`（set if not exists），`EXPIRE`（设置过期时间）等来实现锁的功能。
2. **特点**：
    - **安全性**：确保在分布式环境中，同一时刻只有一个进程可以持有锁。
    - **死锁避免**：通过设置锁的有效期来防止死锁的发生。
    - **性能**：由于基于 Redis，因此性能较高。

## Redisson 入门

使用 Redisson 实现分布式锁的步骤大致如下：

1. **添加依赖**：  
    在你的 Java 项目中添加 Redisson 的依赖。如果使用 Maven，可以在  
    `pom.xml` 中添加如下依赖：
    
    ```XML
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
        <version>最新版本</version>
    </dependency>
    ```
    
2. **配置 Redisson 客户端**：  
    创建并配置 Redisson 客户端实例。这通常涉及指定 Redis 服务器的地址和其他相关配置。  
    
    ```Java
    Config config = new Config();
    config.useSingleServer().setAddress("redis://127.0.0.1:6379");
    RedissonClient redisson = Redisson.create(config);
    ```
    
3. **获取分布式锁**：  
    使用 Redisson 获取分布式锁实例。锁是通过一个唯一的名称标识的。  
    
    ```Java
    RLock lock = redisson.getLock("myLock");
    ```
    
4. **加锁和解锁**：  
    使用  
    `lock()` 和 `unlock()` 方法来加锁和解锁。
    
    ```Java
    try {
        // 尝试获取锁，可以指定等待时间和锁的持有时间
        if (lock.tryLock(10, 2, TimeUnit.SECONDS)) {
            try {
                // 执行业务逻辑
            } finally {
                lock.unlock();
            }
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
    ```
    

这段代码演示了如何在 Java 中使用 Redisson 实现分布式锁。

**尝试获取锁**

```Java
if (lock.tryLock(10, 2, TimeUnit.SECONDS)) {
    // ...
}
```

- `**tryLock**` **方法**：这个方法尝试获取锁。
    - **第一个参数（10）**：这是尝试获取锁的最大等待时间。在这个例子中，如果锁在 10 秒内不可用，当前线程将停止等待。
    - **第二个参数（2）**：这是锁的持有时间。一旦锁被获取，它将至少保持锁状态 2 秒。
    - **第三个参数（**`**TimeUnit.SECONDS**`**）**：这是时间单位，本例中使用的是秒。
- **逻辑**：`tryLock` 会立即返回一个布尔值。如果获取到锁，返回 `true`；如果在指定的等待时间内未能获取到锁，返回 `false`。
- 一个线程使用 tryLock 方法尝试获取锁时，如果锁已经被另一个线程持有，那么这个线程将等待指定的时间（在您的例子中是 10 秒）以尝试获取锁。
    - 如果在这个等待时间内，锁被释放并且当前线程成功获取到锁，tryLock 会返回 true 并且线程将继续执行。
    - 如果在等待时间结束时，线程仍然未能获取到锁，那么会发生以下情况：
        - 直接放弃：tryLock 方法会返回 false。这表示线程在指定的等待时间内未能获取锁。
        - 不会强行获取：**线程不会强制获取锁，也不会继续等待**。它会退出锁获取的尝试。在这种情况下，通常你**需要在代码中处理未能获取锁的情况**。

**执行业务逻辑**

```Java
try {
    // 执行业务逻辑
} finally {
    lock.unlock();
}
```

- 当获取到锁后，你可以在这个 `try` 块中执行业务逻辑。
- 无论业务逻辑执行过程中发生了什么（即使是异常），`finally` 块都将确保锁被释放。

**解锁**

- `**lock.unlock()**`：这行代码在 `finally` 块中调用，确保锁无论如何都会被释放。这是避免死锁非常重要的一步，特别是在多线程和分布式环境中。

**异常处理**

- `**catch (InterruptedException e)**`：这个 `catch` 块处理了在等待锁的过程中可能发生的中断异常。
- `**Thread.currentThread().interrupt();**`：这行代码重新设置当前线程的中断状态。这在处理多线程时是一种常规做法，它确保高层代码可以感知到中断并且可以进一步处理。

1. **关闭客户端**：  
    在应用程序关闭时，关闭 Redisson 客户端。  
    
    ```Java
    redisson.shutdown();
    ```
    
    ## 注意事项
    
    - **确保解锁**：在业务逻辑执行完毕后，务必在 finally 块中释放锁，以防止死锁。
    - **锁的有效期**：合理设置锁的有效期，避免长时间持有锁。
    - **异常处理**：适当处理加锁和解锁过程中可能出现的异常。
    - **分布式环境考量**：在分布式环境下，确保锁的使用不会导致系统整体性能下降。
    
    使用 Redisson 的分布式锁是在分布式系统中处理并发问题的一个有效工具，它利用了 Redis 的高性能和高可用性特性，为 Java 应用提供了一种可靠的锁机制。


# Redisson 的分布式锁主从一致性问题

在 Redisson 的 multi-lock 机制中，涉及的是多个不同的锁，而不是同一个锁的多次实例。这些锁可以位于不同的 Redis 节点上。

1. **多个锁实例**：Multi-lock 涉及的是多个锁实例。这些锁可能分布在不同的 Redis 节点上，每个节点上的锁都是独立的。
2. **独立性**：每个锁都是独立的实体。虽然它们被组合在一起以形成一个 multi-lock，但每个锁的状态和操作都是独立的。
3. **锁定过程**：当请求 multi-lock 时，Redisson 会尝试在所有指定的 Redis 节点上获取各自的锁。只有当所有锁都成功获取时，整个 multi-lock 才被认为是锁定的。
4. **原子操作**：整个锁定和解锁过程是原子的。这意味着不会出现部分锁被锁定而其他锁未被锁定的情况。要么所有锁同时被锁定，要么都不被锁定。
5. **用途**：这种机制通常用于分布式系统中的复杂同步问题，特别是当需要跨多个 Redis 节点协调资源时。

总的来说，multi-lock 机制提供了一种强大的方式来在分布式环境中同步操作，确保了操作的一致性和原子性。

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%884.46.57.png]]

  

# 总结

![[%E6%88%AA%E5%B1%8F2024-01-14_%E4%B8%8B%E5%8D%885.07.33.png|400]]

三种不同类型的 Redis 锁机制，每种都有其用途和缺点：

1. **不可重入的 Redis 分布式锁**：
    - **用途**：这种锁使用 `setnx` 命令来实现。它是最基础的锁机制，当锁不存在时可以设置锁，使用完后需要显式地释放。
    - **缺点**：它的主要缺点是不可重入，即同一个客户端在锁已经被自己获取的情况下不能再次获取，否则会被阻塞。
2. **可重入的 Redis 分布式锁**：
    - **用途**：相比于不可重入锁，可重入锁允许同一个线程多次获取同一把锁。它使用了 `hash` 数据结构来追踪锁的持有者，并结合 `watchDog` 机制自动延长锁的有效期，确保长时间运行的任务不会因为锁超时而被中断。
    - **缺点**：相对复杂，需要额外的机制来维护锁的状态和延长锁的有效期。
3. **Redisson 的 multiLock**：
    - **用途**：multiLock 是 Redisson 客户端提供的一个高级锁机制，它允许跨多个 Redis 节点实现锁的集合。只有当所有指定的锁都被成功获取时，才算整体上锁成功，适合于涉及多个资源的复杂操作。
    - **缺点**：实现较为复杂，因为需要协调多个节点上的锁状态，保证原子性。

这三种锁机制各有适用场景，设计得当时能够很好地在分布式系统中管理对共享资源的访问。在选择合适的锁类型时，需要根据实际的应用场景和需求来决定。