# 启动

## Windows 11 启动
[https://www.cnblogs.com/suanshun/p/7699084.html](https://www.cnblogs.com/suanshun/p/7699084.html)

## CentOS 7 启动

```shell
# 进入redis安装目录 
cd /usr/local/src/redis-6.2.6
# 启动
redis-server redis.conf
redis-cli
```

# 初识Redis

Redis是一种键值型的NoSql数据库，这里有两个关键字：
- 键值型
- NoSql
其中**键值型**，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json：

![[Pasted image 20240430125243.png|500]]

而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。

## 1.1.认识NoSQL

**NoSql**可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为**非关系型数据库**。

### 1.1.1.结构化与非结构化

传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束：

![[Pasted image 20240430125332.png|500]]

而NoSql则对数据库格式没有严格约束，往往形式松散，自由。

可以是键值型：

![[Pasted image 20240430125503.png|167]]

也可以是文档型：

![[Pasted image 20240430125523.png|165]]

甚至可以是图格式：

![[Pasted image 20240430125541.png|157]]

### 1.1.2.关联和非关联

传统数据库的表与表之间往往存在关联，例如外键：

![[Pasted image 20240430125637.png|500]]

而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：

```sql{  
  id: 1,  
  name: "张三",  
  orders: [  
    {  
       id: 1,  
       item: {  
     id: 10, title: "荣耀6", price: 4999  
       }  
    },  
    {  
       id: 2,  
       item: {  
     id: 20, title: "小米11", price: 3999  
       }  
    }  
  ]  
}
```

此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。

### 1.1.3.查询方式

传统关系型数据库会基于Sql语句做查询，语法有统一标准；

而不同的非关系数据库查询语法差异极大，五花八门各种各样。

![[Pasted image 20240430125725.png|500]]
### 1.1.4.事务

传统关系型数据库能满足事务ACID的原则。

而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。
### 1.1.5.总结

除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：

![[Pasted image 20240430125805.png]]

- 存储方式
    - 关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响
    - 非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些

- 扩展性
    - 关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。
    - 非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。
    - 关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦

## 1.2.认识Redis

Redis诞生于2009年全称是**Re**mote **D**ictionary **S**erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。

**特征**：

- 键值（key-value）型，value支持多种不同数据结构，功能丰富
- 单线程，每个命令具备原子性
- 低延迟，速度快（基于内存、IO多路复用、良好的编码）。
- 支持数据持久化
- 支持主从集群、分片集群
- 支持多语言客户端

**作者**：Antirez

Redis的官方网站地址：[https://redis.io/](https://redis.io/)

# String及其常见命令

## String类型的三种格式

String类型，也就是字符串类型，是Redis中最简单的存储类型。

其value是字符串，不过根据字符串的格式不同，又可以分为3类：

- string：普通字符串
- int：整数类型，可以做自增、自减操作
- float：浮点类型，可以做自增、自减操作

不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m。

## String类型的常见命令

![[%E6%88%AA%E5%B1%8F2024-01-04_%E4%B8%8A%E5%8D%888.43.39.png|500]]

## key的结构

Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开

这个格式并非固定，根据自己的需求

![[%E6%88%AA%E5%B1%8F2024-01-04_%E4%B8%8A%E5%8D%888.53.28.png|500]]

存入4条数据就可以有下面的结果:

`set heima:user:1 ‘{“id”:1, “name”:”Jack”, “age”: 18}’`

`set heima:user:2 ‘{“id”:2, “name”:”Rose”, “age”: 20}’`

`set heima:product:1 ‘{“id”:1, “name”:”xiaomi11”, “price”: 4999}’`

`set heima:product:2 ‘{“id”:2, “name”:”honor6”, “price”: 2999}’`

![[Untitled 13.png|232]]

# Hash类型

Hash类型，也叫散列，其value是一个无序字典，类似于HashMap结构。

![[%E6%88%AA%E5%B1%8F2024-01-04_%E4%B8%8A%E5%8D%889.18.48.png|500]]

在Redis的哈希数据结构中，一个 `field` 只能有一个对应的 `value`。每个 `field` 是唯一的，并且与一个特定的 `value` 相关联。如果你尝试为同一个 `field` 设置新的 `value`，它将覆盖原有的 `value`。

要理解这一点，可以将Redis哈希视为类似于Java中的 `HashMap`。就像在这些数据结构中一样，每个键（`field`）都映射到一个单独的值（`value`）。

# List类型

![[%E6%88%AA%E5%B1%8F2024-01-04_%E4%B8%8A%E5%8D%8811.03.57.png|500]]

1. **LRANGE**: 获取列表指定范围内的元素。
    
    示例：`LRANGE mylist 0 -1` - 获取 'mylist' 中的所有元
    
2. **LLEN**: 获取列表的长度。
    
    示例：`LLEN mylist` - 返回 'mylist' 的长度。
    
3. **LINDEX**: 获取列表中指定位置的元素。
    
    示例：`LINDEX mylist 0` - 获取 'mylist' 第一个元素。
    
4. **LSET**: 将列表中指定位置的元素设置为另一个值。
    
    示例：`LSET mylist 0 x` - 将 'mylist' 中第一个元素的值设置为 'x'。
    
5. **LTRIM**: 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。
    
    示例：`LTRIM mylist 1 -1` - 移除列表 'mylist' 中第一个元素之外的所有元素。

## 如何利用List结构模拟一个栈？

入口出口在同一边

## 如何利用List结构模拟一个队列？

入口出口在不同边

## 如何利用List结构模拟一个阻塞队列？

入口和出口在不同边

出队时采用BLPOP或BRPOP (因为指定时间之后，如果数据库中没有这个数据，就会阻塞)

# Set类型

Redis的set结构与java中的HashSet类似，可以看作是一个value为null的HashMap

- 无序
- 元素不可重复
- 查找快
- 支持交集、并集、差集等功能

![[%E6%88%AA%E5%B1%8F2024-01-04_%E4%B8%8A%E5%8D%8811.22.30.png|500]]

# SortedList类型

Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但是底层数据结构却差别很大。

每个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个SkipList + Hash表

- 可排序
- 元素不重复
- 查询速度快

![[%E6%88%AA%E5%B1%8F2024-01-04_%E4%B8%8A%E5%8D%8811.37.14.png|500]]

## 练习题

![[%E6%88%AA%E5%B1%8F2024-01-04_%E4%B8%8A%E5%8D%8811.46.25.png|400]]

[[Redis的Java客户端]]

[[Redis实战项目]]

[[Redis缓存]]

[[优惠劵秒杀]]

[[分布式锁]]

[[消息队列]]

