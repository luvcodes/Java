# 8种基本数据类型

## 变量类型

Java是一种静态类型语言，这意味着所有变量在使用前都必须声明其类型。主要有两种类型的变量：

1. **基本数据类型**：这些类型直接存储值，不是对象。它们包括：

- 整数类型：`byte`（8位）、`short`（16位）、`int`（32位）、`long`（64位）
- 浮点数类型：`float`（32位）、`double`（64位）
- 字符类型：`char`（16位，用于存储字符）
- 布尔类型：`boolean`（用于存储真（true）或假（false））

1. **引用类型**：这些类型指向对象的引用（或地址），而不是直接存储值。包括：

- 类（Class）
- 接口（Interface）
- 数组（Array）

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696684386809-22964e3c-308f-4907-81d5-2ff1862b692f.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696684386809-22964e3c-308f-4907-81d5-2ff1862b692f.png)

| 变量名称    | 字节  | 位数  |
| ------- | --- | --- |
| byte    | 1   | 8   |
| boolean | 1   | 8   |
| short   | 2   | 16  |
| char    | 2   | 16  |
| int     | 4   | 32  |
| float   | 4   | 32  |
| double  | 8   | 64  |
| long    | 8   | 64  |

## Float类型

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696685086026-d930453a-212c-43f5-8c64-8f0449bd04f9.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696685086026-d930453a-212c-43f5-8c64-8f0449bd04f9.png)

链接：[https://www.nowcoder.com/questionTerminal/d2282ec2c34a498ebc88bfb87909e11a?](https://www.nowcoder.com/questionTerminal/d2282ec2c34a498ebc88bfb87909e11a?)

- Float是类，float不是类.
- 查看JDK源码就可以发现Byte，Character，Short，Integer，Long，Float，Double，Boolean都在java.lang包中.
- Float正确复制方式是Float f=1.0f, 若不加f会被识别成double型, double无法向float隐式转换.
- Float a= new Float(1.0)是正确的赋值方法，但是在1.5及以上版本引入自动装箱拆箱后，会提示这是不必要的装箱的警告，通常直接使用Float f=1.0f.

## int类型

**int a = 1; 这条语句在java的内存中到底是怎么体现的？**

在 Java 中，`int a = 1;` 这条语句会进行以下几个步骤：

1. **内存分配**：在栈（Stack）内存中为变量 `a` 分配 4 个字节（因为 `int` 类型需要 4 个字节）。
2. **初始化**：将这 4 个字节设置为代表整数 `1` 的二进制值。
3. **标识符映射**：变量名 `a` 会映射到这块内存地址，以便后续使用。

## 在内存中的具体表现：

- **内存地址**：假设为 `0x7fff5fbffb58`（这是一个假设的地址，实际地址会根据运行环境变化）。
- **值的存储**：在这个地址处，存储的二进制值会是 `00000001`（这是整数 `1` 的 32 位二进制表示，实际存储为 4 字节，我这里简化显示）。

## 高级细节

- **局部变量和成员变量**：如果 `a` 是一个局部变量（比如在一个方法内部定义），则存储在栈内存中。如果 `a` 是一个成员变量（类的属性），则会存储在堆（Heap）内存中作为对象的一部分。
- **指令集和JVM**：Java 程序运行在 Java 虚拟机（JVM）上，具体的内存管理和寻址操作会由 JVM 来完成，通常是与底层系统的硬件指令集相对应的。

总的来说，`int a = 1;` 会在内存中分配一块用于存储 `int` 类型数据的空间，并将该空间初始化为 `1`，同时变量名 `a` 会映射到这块内存地址。

## byte类型参与运算

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696686393309-f13a2734-0c9e-4759-96c7-542231f9bb65.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696686393309-f13a2734-0c9e-4759-96c7-542231f9bb65.png)

答案:A

short类型转为byte类型出错

a1*a2结果为int类型，转为byte类型出错

# 为什么a1*a2结果为int类型呢？

链接：[https://www.nowcoder.com/questionTerminal/4cefb62973b149478bedc0ebcdbfb160?](https://www.nowcoder.com/questionTerminal/4cefb62973b149478bedc0ebcdbfb160?)

java中如果碰到char、byte和short参与运算时，会**自动将这些值转换为int类型然后再进行运算**。这里a1和a2就自动转为int类型了，结果也为Int类型。把一个int类型赋值给byte需要转型。
### 包装类

对于每个基本数据类型，Java提供了一个对应的包装类。包装类使得基本数据类型的变量可以作为对象来处理。这些包装类是：

- `Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean`

这些类在java.lang包中，它们提供了多种方法来操作基本数据类型的值，例如比较、转换为其他类型等。

### 强制类型转换

在Java中，类型转换分为两种：自动类型转换和强制类型转换。

1. **自动类型转换**：当将一个较小数据类型的值赋给较大数据类型的变量时，Java会自动进行类型转换。例如，将`int`赋值给`long`变量。
2. **强制类型转换**：当需要将较大数据类型的值赋给较小数据类型的变量时，需要进行强制类型转换。这是通过在值前加上括号和目标类型来实现的。例如：

```Java
double d = 100.04;
long l = (long)d;  // 强制类型转换为 long
int i = (int)l;    // 强制类型转换为 int
```

强制类型转换可能会导致数据丢失，因为较小的类型可能无法容纳较大类型的所有可能值。

这些概念是理解Java程序的基础，对于编写高效、可靠的Java代码非常重要。

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696686119687-2cdc915f-e53d-4036-8ba6-42596ca042aa.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696686119687-2cdc915f-e53d-4036-8ba6-42596ca042aa.png)

链接：[https://www.nowcoder.com/questionTerminal/0886d19c7b6a4cbe8c52b2a31d748252?](https://www.nowcoder.com/questionTerminal/0886d19c7b6a4cbe8c52b2a31d748252?)

这道题考的是数据类型转换问题。由大到小需要强制转换，由小到大不需要。

A：return; 没有返回值，**错误**

B：short → float 无须强制转换，**正确**

C：long → float 无须强制转换（**这个最选项容易出错**），**正确。**

float占4个字节为什么比long占8个字节大呢，因为底层的实现方式不同。

**浮点数的32位并不是简单直接表示大小，而是按照一定标准分配的**。

第1位，符号位，即S

接下来8位，指数域，即E。

剩下23位，小数域，即M，取值范围为[1 ,2 ) 或[0 , 1)

然后按照公式：**V=(-1)^s * M * 2^E**

**也就是说浮点数在内存中的32位不是简单地转换为十进制，而是通过公式来计算而来，通过这个公式虽然， 只有4个字节，但浮点数最大值要比长整型的范围要大**。

D：double → float 没有强制转换，**错误**。

# 题目

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696685831368-399300b0-071f-458a-9ee4-202e43f084f8.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696685831368-399300b0-071f-458a-9ee4-202e43f084f8.png)

**解答**

链接：[https://www.nowcoder.com/questionTerminal/a40182696d5d46c2be753074f3330d84?](https://www.nowcoder.com/questionTerminal/a40182696d5d46c2be753074f3330d84?)

内存引用地址，是指栈中存放的地址，来指向堆中的某个位置。int 是基本类型，数据直接存放在栈中，不存在内存引用地址的说法A对 指向常量池里的"hello"。B对 题中没说声明的a是局部变量。C错 int a =1;并不指向堆中，它只有值，没有引用地址，Integer b =new Integer(1);指向堆中地址为1的位置。D错 原因同C

![[Untitled 3.png|700]]

[[03隐式转换的练习]]