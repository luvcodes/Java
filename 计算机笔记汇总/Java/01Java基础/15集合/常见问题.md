# **Collections工具类**

## **为什么重写了equals方法一定要重写HashCode方法？**

**因为必须保证重写后的equals方法认定相同的两个对象拥有相同的哈希值**”。同时我们顺便得出了一个结论：“**hashCode方法的重写原则就是保证equals方法认定为相同的两个对象拥有相同的哈希值**”。回答见: [https://zhuanlan.zhihu.com/p/50206657](https://zhuanlan.zhihu.com/p/50206657)

当我们将equals方法重写后有必要将hashCode方法也重写，这样做才能保证不违背hashCode方法中“**相同对象必须有相同哈希值**”的约定。对于任何一个对象，不论是使用继承自Object的equals方法还是重写equals方法。hashCode方法实际上必须要完成的一件事情就是，**为该equals方法认定为相同的对象返回相同的哈希值**。

1. 相同的对象必然导致相同的哈希值。
2. 不同的哈希值必然是由不同对象导致的。

哈希函数/散列函数的概念: **哈希函数（散列函数）能够将任意长度的输入值转变成固定长度的值输出，该值称为散列值，输出值通常为字母与数字组合**

- **为什么要保证它们的哈希值相等呢？“hashCode方法返回的哈希值在语言中扮演了一个什么角色？**
    - 这里可以根据HashMap的源码来说明。
- Equals的原理是什么？为什么需要重写equals方法呢？
    - Object类中的equals方法区分两个对象的做法是比较地址值，即使用“==”。而我们如若根据业务需求改写了equals方法的实现，那么也应当同时改写hashCode方法的实现。否则hashCode方法依然返回的是依据Object类中的依据地址值得到的integer哈希值。继承自Object的equals方法不能满足业务需求的情形，就比如我在文中说的，String除了对比地址值之外，还将每个对应字符相等的两个String对象也认定为“equals”。