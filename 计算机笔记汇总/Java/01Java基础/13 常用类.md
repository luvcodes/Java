 # Math类

## 概念

Math类所在包为java.lang包，因此在使用的时候不需要进行导包。并且Math类被final修饰了，因此该类是不能被继承的。

Math类包含执行基本数字运算的方法，我们可以使用Math类完成基本的数学运算。

## 常见方法

```Java
public static int abs(int a)					// 返回参数的绝对值
public static double ceil(double a)				// 返回大于或等于参数的最小整数
public static double floor(double a)			// 返回小于或等于参数的最大整数
public static int round(float a)				// 按照四舍五入返回最接近参数的int类型的值
public static int max(int a,int b)				// 获取两个int值中的较大值
public static int min(int a,int b)				// 获取两个int值中的较小值
public static double pow (double a,double b)	// 计算a的b次幂的值
public static double random()					// 返回一个[0.0,1.0)的随机值
```

# System类

## 概念

System类所在包为java.lang包，因此在使用的时候不需要进行导包。并且System类被final修饰了，因此该类是不能被继承的。

System包含了系统操作的一些常用的方法。比如获取当前时间所对应的毫秒值，再比如终止当前JVM等等。

## 常见方法

`currentTimeMillis`方法

```Java
public static long currentTimeMillis()			// 获取当前时间所对应的毫秒值（当前时间为0时区所对应的时间即就是英国格林尼治天文台旧址所在位置）
public static void exit(int status)				// 终止当前正在运行的Java虚拟机，0表示正常退出，非零表示异常退出
public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length); // 进行数值元素copy
```

`exit`方法

```Java
public class SystemDemo01 {
    public static void main(String[] args) {
        System.out.println("程序开始执行了.....");
        // 终止JVM
        System.exit(0);
        System.out.println("程序终止了..........");
    }
}
```

`arraycopy`方法

```Java
public class SystemDemo01 {
    public static void main(String[] args) {
        int[] srcArray = {23 , 45 , 67 , 89 , 14 , 56 } ;

        // 定义目标数组
        int[] desArray = new int[10] ;

        // 进行数组元素的copy: 把srcArray数组中从0索引开始的3个元素，从desArray数组中的1索引开始复制过去
        System.arraycopy(srcArray , 0 , desArray , 1 , 3);

        // 遍历目标数组
        for(int x = 0 ; x < desArray.length ; x++) {
            if(x != desArray.length - 1) {
                System.out.print(desArray[x] + ", ");
            }else {
                System.out.println(desArray[x]);
            }
        }
    }
}
```

进行数组元素的copy: 把srcArray数组中从0索引开始的3个元素，从desArray数组中的1索引开始复制过去。

# Runtime

## 概述

Runtime表示Java中运行时对象，可以获取到程序运行时设计到的一些信息

## 常见方法

**常见方法介绍**

```Java
public static Runtime getRuntime()		//当前系统的运行环境对象
public void exit(int status)			//停止虚拟机
public int availableProcessors()		//获得CPU的线程数
public long maxMemory()				    //JVM能从系统中获取总内存大小（单位byte）
public long totalMemory()				//JVM已经从系统中获取总内存大小（单位byte）
public long freeMemory()				//JVM剩余内存大小（单位byte）
public Process exec(String command) 	//运行cmd命令
```

# Object类

Object类所在包是java.lang包。Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类；换句话说，该类所具备的方法，其他所有类都继承了。

## 常见方法

**常见方法介绍**

```Java
public String toString()				//返回该对象的字符串表示形式(可以看做是对象的内存地址值)
public boolean equals(Object obj)		//比较两个对象地址值是否相等；true表示相同，false表示不相同
protected Object clone()    			//对象克隆
```

### toString方法

### equals实现步骤：

1. 在测试类（ObjectDemo02）的main方法中，创建两个学生对象，然后比较两个对象是否相同

代码如下所示：

```Java
public class ObjectDemo02 {
    public static void main(String[] args) {
        // 创建两个学生对象
        Student s1 = new Student("itheima" , "14") ;
        Student s2 = new Student("itheima" , "14") ;

        // 比较两个对象是否相等
        System.out.println(s1 == s2);
    }
}
```

运行程序进行测试，控制台的输出结果如下所示：`false`

因为**"=="号比较的是对象的地址值**，而我们通过new关键字创建了两个对象，它们的地址值是不相同的。因此比较结果就是false。

我们尝试调用Object类中的equals方法进行比较，代码如下所示：

```Java
// 调用equals方法比较两个对象是否相等
boolean result = s1.equals(s2);

// 输出结果
System.out.println(result);
```

运行程序进行测试，控制台的输出结果为：`false`

为什么结果还是false呢？我们可以查看一下Object类中equals方法的源码，如下所示：

```Java
public boolean equals(Object obj) {     // Object类中的equals方法的源码
return (this == obj);
}
```

通过源码我们可以发现**默认情况下**`**equals**`**方法比较的也是对象的地址值**。比较内存地址值一般情况下是没有意义的，我们希望比较的是对象的属性，如果两个对象的属性相同，我们认为就是同一个对象；

那么要比较对象的属性，我们就需要在Student类中重写Object类中的equals方法。生成的equals方法和hashCode方法如下：

```Java
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
Student student = (Student) o;
return Objects.equals(name, student.name) && Objects.equals(age, student.age);  // 比较的是对象的name属性值和age属性值
}

@Override
public int hashCode() {
    return 0;
}
```

hashCode方法我们暂时使用不到，可以将hashCode方法删除。重写完毕以后运行程序进行测试，控制台输出结果`true`

此时`equals`方法比较的是对象的成员变量值，而s1和s2两个对象的成员变量值都是相同的。因此比较完毕以后的结果就是true。

小结：

1. 默认情况下equals方法比较的是对象的地址值
2. 比较对象的地址值是没有意义的，因此一般情况下我们都会重写Object类中的equals方法

### 对象克隆

把A对象的属性值完全拷贝给B对象，也叫对象拷贝，对象复制。

浅拷贝:

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708214158583-34840046-6e70-4cea-b99b-33d484ea4f82.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708214158583-34840046-6e70-4cea-b99b-33d484ea4f82.png)

深拷贝:

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708214231655-e9b881e6-3f8a-48c6-aa4d-22dadce235ce.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708214231655-e9b881e6-3f8a-48c6-aa4d-22dadce235ce.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708214280113-1c917700-1752-48a2-85ab-8b85610b4b21.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708214280113-1c917700-1752-48a2-85ab-8b85610b4b21.png)

# Objects类

Objects类所在包是在java.util包下，因此在使用的时候需要进行导包。并且Objects类是被final修饰的，因此该类不能被继承。

Objects类提供了一些对象常见操作的方法。比如判断对象是否相等，判断对象是否为null等等。

```Java
public static String toString(Object o) 					// 获取对象的字符串表现形式
public static boolean equals(Object a, Object b)			// 比较两个对象是否相等
public static boolean isNull(Object obj)					// 判断对象是否为null
public static boolean nonNull(Object obj)					// 判断对象是否不为null
```

# BigInteger类

## 概念

平时在存储整数的时候，Java中默认是int类型，int类型有取值范围：-2147483648 ~ 2147483647。如果数字过大，我们可以使用long类型，但是如果long类型也表示不下怎么办呢？

就需要用到BigInteger，可以理解为：大的整数。

有多大呢？理论上最大到42亿的21亿次方

基本上在内存撑爆之前，都无法达到这个上限。

## 常见方法

### 构造方法

```Java
public BigInteger(int num, Random rnd) 		//获取随机大整数，范围：[0 ~ 2的num次方-1]
public BigInteger(String val) 				//获取指定的大整数
public BigInteger(String val, int radix) 	//获取指定进制的大整数

下面这个不是构造，而是一个静态方法获取BigInteger对象
public static BigInteger valueOf(long val) 	//静态方法获取BigInteger的对象，内部有优化
```

**构造方法小结：**

- 如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取。
- 如果BigInteger表示的超出long的范围，可以用构造方法获取。
- **对象一旦创建，BigInteger内部记录的值不能发生改变。**
- 只要进行计算都会产生一个新的BigInteger对象

### 常见成员方法

```Java
public BigInteger add(BigInteger val)					//加法
public BigInteger subtract(BigInteger val)				//减法
public BigInteger multiply(BigInteger val)				//乘法
public BigInteger divide(BigInteger val)				//除法
public BigInteger[] divideAndRemainder(BigInteger val)	 //除法，获取商和余数
public  boolean equals(Object x) 					    //比较是否相同
public  BigInteger pow(int exponent) 					//次幂、次方
public  BigInteger max/min(BigInteger val) 				//返回较大值/较小值
public  int intValue(BigInteger val) 					//转为int类型整数，超出范围数据有误
```

# BigDecimal类

# 包装类 - 针对八种基本数据类型相应的引用类型

- 单独的两个类别
- boolean => Boolean
- char => Character
- Number类型:

1. byte => Byte
2. int => integer
3. long => Long
4. float => Float
5. double => Double
6. short => Short

- 装箱和拆箱

1. 手动装箱: int => Integer
2. 手动拆箱: Integer => int
3. jdk5以后，就可以自动装箱和拆箱了