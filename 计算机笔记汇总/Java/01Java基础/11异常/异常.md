# 示例

可以看这段代码作为引子:

```Java
package Exception_;

public class Exception01 {
    public static void main(String[] args) {
        int num1 = 10;
        int num2 = 0;
        /*
        * 1. num1 / num2 => 10 / 0
        * 2. 当执行到 num1 / num2 因为num2 = 0，程序就会抛出异常 ArithmeticException
        * 3. 当抛出异常后，程序就退出，崩溃了，下面的代码就不再执行
        * 4. Ctrl + Alt + t -> 选中try-catch
        * 5. 如果进行异常处理，那么即使出现了异常，程序可以继续执行
        * */
        try {
            int res = num1 / num2;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        System.out.println("Program continues...");
    }
}
```

在Java中，当一个异常被抛出并且没有被捕获，它会导致当前执行的线程立即停止，并且异常信息会被输出到控制台。这也意味着当前线程中该异常之后的代码不会被执行。

在你提供的代码中，当遇到`10 / 0`这个算术错误时，会抛出一个`ArithmeticException`。这个异常在`try`块中被捕获。然后，在`catch`块中，你又抛出了一个新的异常，`RuntimeException`。

当`RuntimeException`被抛出，它并没有在任何地方被捕获（你的代码中并没有包含处理这个异常的额外的`catch`块），所以它会导致程序立即停止执行。因此，`System.out.println("Program continues...");`这行代码位于`RuntimeException`被抛出之后，所以它不会被执行。

总结：由于`RuntimeException`在`catch`块中被抛出并且没有被后续代码捕获，程序立即停止，这就是为什么`println`语句没有执行的原因。

# throws和try-catch语句的关系与不同

在Java中，`throws` 和 `try-catch` 都是用于处理异常的，但它们的用法和目的是不同的。下面是对这两者的关系和区别的详细描述：

1. **用途**:

- `**try-catch**`：当你知道某些代码可能会抛出异常并且你想在当前方法中处理它时，你会使用 `try-catch` 结构。使用这种方法，你可以捕获异常并执行一些恢复操作或给出一些有关错误的信息。
- `**throws**`：当你的方法中有可能抛出异常，但你**不想在这个方法中处理它**，而是**想让调用这个方法的代码处理这个异常**时，你会在你的方法签名中使用 `throws` 关键字。

1. **工作原理**:

- `**try-catch**`：代码在 `try` 块中运行。如果 `try` 块中的代码抛出异常，控制权会立即传递给相应的 `catch` 块，并执行该块中的代码。
- `**throws**`：如果一个方法使用了 `throws` 关键字，当它抛出异常时，它不会处理该异常。相反，异常会被抛给调用该方法的上一级，并需要在那里被处理。

1. **示例**:

```Java
public void myMethod() throws SomeException {
   // Some code that might throw SomeException
}
```

在上述代码中，`myMethod` 可能会抛出 `SomeException`，但**它本身不处理该异常。调用** `**myMethod**` **的代码必须处理它**，要么用 `try-catch`，要么继续使用 `throws` 将它向上抛。

1. **总结**:

- 使用 `try-catch` 时，你是在说：“我知道这段代码可能会出错，所以我要处理它。”
- 使用 `throws` 时，你是在说：“我知道这个方法可能会出错，但我不想在这里处理它。我要让调用这个方法的人来处理。”

# 异常体系图

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696307526777-e23e5a69-772b-4607-b219-9c939bbbb423.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696307526777-e23e5a69-772b-4607-b219-9c939bbbb423.png)

# 异常的类型

Checked异常和Runtime异常

Java中的异常可以分为Checked异常和RuntimeException(Runtime的子类)。

- Checked异常必须在代码中显式地进行捕获或抛出,否则会导致编译错误。例如IOException、SQLException等。
- RuntimeException及其子类都属于非受检异常,编译器不会强制捕获或抛出,但是可以选择捕获以防止程序异常终止。如NullPointerException、ArrayIndexOutOfBoundsException等。

## **运行时异常**

程序运行时，发生的异常。编译器检测不出来。也就是javac.exe字节码文件转换为java.exe的过程中(指向在内存中加载、运行类)出现的error

主要介绍**5种运行异常**:

- ArrayIndexOutOfBoundsException
- NullPointerException
- ClassCastException: 当试图将对象强制转换为不是实例的子类时，抛出该异常
- ArithmeticException
- NumberFormatException: 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时

## **编译时异常**

编译时，编译器检查出的异常, 是**编译器要求必须处置的异常**。也就是Java源程序编译为javac.exe字节码文件的过程中

- SQLException
- IOException
- FileNotFoundException
- ClassNotFoundException
- EOFException
- IllegalArguementException

# 异常处理

## try-catch-finally捕捉异常

程序员在代码中捕获发生的异常，自行处理

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696307963536-8617f1c9-4277-4611-89a5-f05e4eda5ef2.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696307963536-8617f1c9-4277-4611-89a5-f05e4eda5ef2.png)

[return和finally之间的关系](https://www.yuque.com/chuangshiji-poapl/epb8vm/kuk3h7xq0ua81b2k)

### try-catch-finally执行顺序

1. 如果没有出现异常，则执行try块中所有语句，不执行catch块中语句，如果有finally，最后还需要执行finally里面的语句。
2. 如果出现异常，则try块中异常发生后，try块剩下的语句不再执行。将执行catch块中的语句，如果有finally，最后还需要执行finally里面的语句。

## throws处理机制

将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者就是JVM

throw和throws的区分

- throws后面带的是异常类型
- throw后面带的是具体的异常对象

### 对比throw和throws

### `throw`

1. **用途**: `throw`关键字用于显式地抛出一个异常。
2. **语法**: `throw new SomeException("Some message");`
3. **位置**: 通常在方法体内部使用。
4. **作用范围**: 只能抛出单个异常。
5. **示例**:

```Java
public void someMethod() {
    if (someCondition) {
        throw new ArithmeticException("Division by zero");
    }
}
```

### `throws`

1. **用途**: `throws`关键字用于声明一个方法可能会抛出的异常类型。
2. **语法**: `public void someMethod() throws SomeException, AnotherException { ... }`
3. **位置**: 在方法签名中使用。
4. **作用范围**: 可以声明多个异常类型。
5. **示例**:

```Java
public void someMethod() throws IOException, SQLException {
    // method body
}
```

### 对比

- `throw`是用于实际抛出异常的，而`throws`是用于声明可能会抛出异常的方法。
- `throw`会立即终止程序执行（除非异常被捕获），而`throws`仅仅是一个声明，不会影响代码执行。
- 使用`throw`时，你需要创建异常对象；使用`throws`时，你只需要声明异常类型。

总结：`throw`用于触发异常，而`throws`用于声明异常。两者通常一起使用，以提供完整的异常处理机制。

# 自定义异常

1. 一般情况下，我们自定义异常是继承 RuntimeException
2. 即把自定义异常做成 运行时异常，好处是，我们可以使用默认的异常机制

```Java
/**
 * 自定义一个异常
 * */
class AgeException extends RuntimeException {
    public AgeException(String message) {
        super(message);
    }
}
```

**try-catch-finally和throws二选一就可以**。如果程序员，没有显式处理异常，默认throws Exception

[[return和finally之间的关系]]

[[Notion/Java/01Java基础/11异常/练习题]]