# 接口成分的特点

在JDK7，包括JDK7之前，接口中的**只有**包含：抽象方法和常量

## 抽象方法

注意：接口中的抽象方法**默认会自动加上**`public abstract`修饰。

## 常量

在接口中定义的成员变量默认会加上： `public static final`修饰。也就是说在接口中定义的成员变量实际上是一个常量。

这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。

## 案例演示

```Java
public interface InterF {
    // 抽象方法！
    // public abstract void run();
    void run();

    // public abstract String getName();
    String getName();

    // public abstract int add(int a , int b);
    int add(int a , int b);


    // 它的最终写法是：
    // public static final int AGE = 12 ;
    int AGE  = 12; //常量
    String SCHOOL_NAME = "黑马程序员";
}
```

# Java 8更新接口定义

## 使用default修饰方法

从 Java 8 开始，接口中允许有带有 `default` 修饰符的方法。这种方法可以有默认的实现，这样实现该接口的类可以选择是否覆盖这个方法。如果不覆盖，那么就会使用接口中提供的默认实现。

这样做的好处是，当接口需要添加新的方法时，已经实现该接口的现有类不需要做任何改动，因为新添加的方法有一个默认实现。

```Java
public interface Cup {
    void use();

    default void clean() {
        System.out.println("Cleaning the cup.");
    }
}
```

在这个例子中，任何实现 `Cup` 接口的类都必须提供 `use()` 方法的实现，但是 `clean()` 方法是可选的。如果实现类没有覆盖 `clean()` 方法，那么就会使用接口中的默认实现。

```Java
public class SmallCup implements Cup {
    @Override
    public void use() {
        System.out.println("Using the small cup.");
    }

    // 不需要提供 clean() 方法的实现，会使用接口中的默认实现
}
```

需要注意的是，即使是带有 `default` 修饰符的方法，其访问级别依然是 `public`。所以，如果你在实现类中覆盖这个方法，覆盖的方法也必须是 `public` 的。

这里的详情可以见[Java 8的新特性](https://www.yuque.com/chuangshiji-poapl/epb8vm/albkkvei6egn3glz)

### 注意事项

1. 默认方法不是抽象方法，所以不强制被重写，但是如果被重写，重写的时候去掉default关键字。
2. public可以省略，default不能省略。
3. 如果实现了多个借口，多个借口中存在相同名字的默认方法，子类就必须对该方法进行重写。

## 使用static修饰方法

- **定义**：接口中的静态方法是属于接口本身而不是接口的实例。因此，它们可以直接通过接口名来调用。
- **目的**：静态方法允许在接口中定义一些工具方法，这些方法可以直接通过接口进行调用而不需要实现该接口的对象实例。
- **访问**：**接口中的静态方法不能被接口的实现类继承**，即这些方法必须通过直接使用接口名来调用。

```Java
public interface MyInterface {
    // 定义一个静态方法
    static void staticMethod() {
        System.out.println("这是接口中的静态方法");
    }
}

public class MyInterfaceImpl implements MyInterface {
    // 这个类实现了MyInterface接口，但它不能继承接口中的静态方法
}

public class Test {
    public static void main(String[] args) {
        // 直接通过接口名调用静态方法
        MyInterface.staticMethod();
    }
}
```

注意：不能通过实现类的实例或类名来调用接口中的静态方法

下面的代码会导致编译错误

- `MyInterfaceImpl.staticMethod();` // 错误
- `new MyInterfaceImpl().staticMethod();` // 错误

# JDK9新增的方法

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710547208931-e3a847f0-1982-47de-827f-8b6164f52953.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710547208931-e3a847f0-1982-47de-827f-8b6164f52953.png)

## 定义私有方法

两种定义方式: 普通的私有方法，静态的私有方法

```Java
public interface InterA {
    public static void show1(){
        System.out.println("show1方法开始执行了");
        show4();
    }


    public static void show2(){
        System.out.println("show2方法开始执行了");
        show4();
    }

    public default void show5() {
        System.out.println("show5方法开始执行了");
        show3();
    }

    // 普通的私有方法，给默认方法服务的
    private void show3(){
        System.out.println("记录程序在运行过程中的各种细节，这里有100行代码");
    }

    // 静态的私有方法，给静态方法服务的
    private static void show4(){
        System.out.println("记录程序在运行过程中的各种细节，这里有100行代码");
    }
}
```

```Java
public class Test implements InterA {
    public static void main(String[] args) {
      /*
       * 接口中私有方法的定义格式：
       *
       * 格式1：private 返回值类型 方法名(参数列表) { }
       * 范例1：private void show() { }
       *
       * 格式2：private static 返回值类型 方法名(参数列表) { }
       * 范例2：private static void method() { }
       */
      InterA.show1();
      InterA.show2();

      // 想要调用show3和sho5方法
      Test test = new Test();
      test.show5();
    }
}
```

# 接口的继承

接口之间可以通过extends关键字进行继承, 这表示一个接口可以继承另一个接口的方法定义。

接口继承接口有以下几点需要注意:

1. 接口继承接口时,子接口会继承父接口所有的方法签名
2. 子接口可以新增自己的方法签名,也可以重写从父接口继承的方法
3. 实现子接口的类必须实现子接口和父接口的所有方法
4. 接口多重继承允许一个接口继承多个接口
5. 接口不能继承类,但可以继承多个接口
6. 接口继承规则和类继承不同,是完全继承,不存在方法覆盖的概念

```Java
interface FatherInterface {
  void method1();
}

interface ChildInterface extends FatherInterface {
  void method2();
}

// 实现ChildInterface必须实现method1和method2
class ChildClass implements ChildInterface {
  public void method1() {}
  public void method2() {}
}
```

所以接口继承意味着子接口会继承父接口的方法声明,实现子接口的类必须实现所有父接口方法。这在设计关系复杂的接口体系时很有用。

# 接口的应用

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710547548285-2860cd8f-64ce-4403-bee0-d2f2def4f15b.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710547548285-2860cd8f-64ce-4403-bee0-d2f2def4f15b.png)

## 接口多态

当一个方法的参数是接口时，这意味着这个方法可以接受任何实现了该接口的对象作为其参数。这是一种非常强大的设计模式，因为它增加了代码的灵活性和可扩展性，使得方法能够处理各种不同的实现，只要它们遵循相同的接口。这种做法是依赖倒置原则的体现，即高层模块不应依赖于低层模块，两者都应依赖于抽象；抽象不应依赖于细节，细节应依赖于抽象。

### 例子

假设有一个接口`Animal`，它定义了一个方法`makeSound`：

```Java
public interface Animal {
    void makeSound();
}
```

然后有两个类实现了这个接口：`Dog`和`Cat`：

```Java
public class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof");
    }
}

public class Cat implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Meow");
    }
}
```

现在，如果我们有一个方法接受一个`Animal`类型的参数：

```Java
public class Test {
    public static void makeItSpeak(Animal animal) {
        animal.makeSound();
    }

    public static void main(String[] args) {
        Dog dog = new Dog();
        Cat cat = new Cat();

        makeItSpeak(dog); // 输出 "Woof"
        makeItSpeak(cat); // 输出 "Meow"
    }
}
```

在这个例子中，`makeItSpeak`方法接受一个`Animal`类型的参数。这意味着你可以传递任何`Animal`接口的实现给这个方法，让方法根据传入对象的具体类型调用相应的`makeSound`实现。这样的设计让你的代码更加灵活和可复用。

### 应用

这种设计模式在Java中非常常见，特别是在设计库和框架时。它允许用户扩展库或框架的功能，只要他们提供符合预期接口的实现。常见的使用场景包括：

- 回调接口，允许用户提供定制的行为来响应特定的事件。
- 策略模式，允许在运行时选择算法的具体实现。
- 工厂方法和抽象工厂模式，用于创建对象，具体创建哪个对象由实现了某个接口的类来决定。
- 在各种设计模式中，如适配器模式、装饰器模式等，广泛应用接口作为方法参数来提供灵活性和扩展性。

# Comparable接口

Comparable接口定义在java.lang包下,它代表一个可比较的类型。**一个类如果实现了Comparable接口,就意味着它的对象可以和其他对象进行比较和排序。**

Comparable接口只包含一个方法: `public int compareTo(T o)`

这个方法**用来比较当前对象和参数对象的顺序**。它必须返回一个整型数字:

- 如果当前对象小于参数对象,返回负数
- 如果当前对象等于参数对象,返回0
- 如果当前对象大于参数对象,返回正数

实现Comparable接口的类对象集合可以通过`Collections.sort()`或者`Arrays.sort()`进行自动排序。**排序会使用compareTo方法进行比较**。例如,String、Integer等包装类都实现了Comparable接口,所以字符串和整数可以比较大小和排序。

我们自己定义的类也可以实现Comparable接口,提供一个自定义排序逻辑。例如,按照年龄来比较Person对象:

```Java
public class Person implements Comparable<Person> {
  private int age;

  public int compareTo(Person other) {
    return this.age - other.age;
  }
}
```

所以Comparable接口对于自定义类对象排序很有用。

让我们举一个例子来展示如何使用`Arrays.sort`方法对实现了`Comparable`接口的对象数组进行排序，以及如何使用`Collections.sort`方法对对象集合进行排序。我们将使用前面提到的`Person`类。

首先，这是`Person`类的完整实现，包括实现了`Comparable`接口的`compareTo`方法：

```Java
public class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Person other) {
        return this.age - other.age; // 按年龄排序
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }

    // Getters and Setters
}
```

### 对数组排序

使用`Arrays.sort`对`Person`对象的数组进行排序：

```Java
import java.util.Arrays;

public class SortExample {
    public static void main(String[] args) {
        Person[] people = {
            new Person("Alice", 30),
            new Person("Bob", 25),
            new Person("Charlie", 35)
        };

        Arrays.sort(people);

        System.out.println("Sorted by age: " + Arrays.toString(people));
    }
}
```

在这个例子中，我们创建了一个`Person`对象的数组，并使用`Arrays.sort`方法对其进行排序。排序依据是`Person`类的`compareTo`方法，即按照年龄排序。排序后，数组将按照年龄升序排列。

### 对集合排序

使用`Collections.sort`对`Person`对象的集合进行排序：

```Java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class SortExample {
    public static void main(String[] args) {
        List<Person> peopleList = new ArrayList<>();
        peopleList.add(new Person("Alice", 30));
        peopleList.add(new Person("Bob", 25));
        peopleList.add(new Person("Charlie", 35));

        Collections.sort(peopleList);

        System.out.println("Sorted by age: " + peopleList);
    }
}
```

在这个例子中，我们创建了一个`Person`对象的`ArrayList`集合，并使用`Collections.sort`方法对其进行排序。与数组排序类似，这里的排序依据同样是`Person`类的`compareTo`方法，即按照年龄排序。排序后，集合将按照年龄升序排列。

通过实现`Comparable`接口并定义`compareTo`方法，`Person`类的实例就可以按照指定的顺序（在本例中是年龄）进行排序，无论是在数组还是集合中。

[[接口相关题目]]