# 什么是内部类

将一个类A定义在另一个类B里面，里面的那个类A就称为**内部类**，B则称为**外部类**。可以把内部类理解成寄生，外部类理解成宿主。

# 内部类的分类

按定义的位置来分

1. **成员内部类**，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)
2. **静态内部类**，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)
3. **局部内部类**，类定义在方法内
4. **匿名内部类**，没有名字的内部类，可以在方法中，也可以在类中方法外。

# 匿名内部类

匿名内部类是Java的一个特性，允许你在一个表达式中声明并且实例化一个类。匿名内部类是没有名字的，是内部类的一种简化形式。

匿名内部类必须**继承一个父类**或者**实现一个父接口**。

**匿名内部类格式**

```Java
new 父类名或者接口名(){
    // 方法重写
    @Override
    public void method() {
        // 执行语句
    }
};
```

## 示例

```Java
interface Swim {
    public abstract void swimming();
}

public class Demo07 {
    public static void main(String[] args) {
        // 使用匿名内部类
		new Swim() {
			@Override
			public void swimming() {
				System.out.println("自由泳...");
			}
		}.swimming();

        // 接口 变量 = new 实现类(); // 多态, 走子类的重写方法
        Swim s2 = new Swim() {
            @Override
            public void swimming() {
                System.out.println("蛙泳...");
            }
        };

        s2.swimming();
        s2.swimming();
    }
}
```

## 示例二

通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：

```Java
interface Swim {
    public abstract void swimming();
}

public class Demo07 {
    public static void main(String[] args) {
        // 匿名内部类使用场景:作为方法参数传递
        Swim s3 = new Swim() {
            @Override
            public void swimming() {
                System.out.println("蝶泳...");
            }
        };
        // 传入匿名内部类
        goSwimming(s3);

        // 完美方案: 一步到位
        goSwimming(new Swim() {
            public void swimming() {
                System.out.println("大学生, 蛙泳...");
            }
        });

        goSwimming(new Swim() {
            public void swimming() {
                System.out.println("小学生, 自由泳...");
            }
        });
    }

    // 定义一个方法,模拟请一些人去游泳
    public static void goSwimming(Swim s) {
        s.swimming();
    }
}
```

## 注意

尽管匿名内部类提供了一个简洁的方法来实现单次使用的类，但它们并不总是最佳选择。

**如果类的定义或逻辑变得复杂**，那么使用**传统的内部类**或者**单独的类**可能**更为合适**，因为这样的代码更容易阅读和维护。

```Java
public class AnonymousInnerClassDetail {
    public static void main(String[] args) {
        Outer05 outer05 = new Outer05();
        outer05.f1();
    }
}

class Outer05 {
    private int n1 = 99;
    public void f1() {
        Person p = new Person() {
            private int n1 = 88;
            @Override
            public void hi() {
                System.out.println("Anonymous inner class override hi() method");
                // 可以直接访问外部类的所有成员，包含私有的
                System.out.println("n1 value = " + n1 + " outer class n1 = " + Outer05.this.n1);
                // Outer05.this就是调用f1的对象
                System.out.println("Outer05.this hashcode = " + Outer05.this);
            }
        };
        p.hi(); // 动态绑定，运行类型是 Outer05$1

        // 也可以直接调用，因为匿名内部类本身也是返回对象
        new Person() {
            @Override
            public void hi() {
                System.out.println("Anonymous inner class override hi() method, haha...");
            }

            @Override
            public void ok(String str) {
                super.ok(str);
            }
        }.ok("jack");
    }
}

class Person {
    public void hi() {
        System.out.println("Person hi() method");
    }
    public void ok(String str) {
        System.out.println("Person ok() " + str);
    }
}
```

# 局部内部类

局部内部类，又称为本地内部类，是**定义在方法内部的类**。因为它是在一个方法内部定义的，所以它只能在这个方法内部使用。这种类的可见性仅限于声明它的方法。

下面是关于局部内部类的一些特点：

1. **作用域限制**：局部内部类的作用域仅限于声明它的方法。
2. **不能有访问修饰符**：由于局部内部类是在方法内部定义的，所以它不能有`public`、`private`、`protected`或`default`修饰符。
3. **访问外部变量**：局部内部类可以访问其外部方法中的`final`局部变量或者从Java 8开始，可以访问事实上的`final`变量（即它的值不被修改的变量）。
4. **不可以是**`**static**`**的**：局部内部类不能有`static`数据成员、方法或者类。

## 示例

```Java
public class OuterClass {
    public void someMethod() {
        int localVar = 10; // 局部变量

        // 局部内部类
        class LocalInnerClass {
            public void printLocalVar() {
                System.out.println(localVar);  // 访问外部方法的局部变量
            }
        }

        // 创建局部内部类的实例并调用其方法
        LocalInnerClass lic = new LocalInnerClass();
        lic.printLocalVar();
    }
}
```

在上述示例中，`LocalInnerClass`是一个局部内部类，它定义在`someMethod`方法内部，并且只能在这个方法内部使用。

## 使用场景

局部内部类主要用于实现特定于某个方法的功能，而这个功能不需要在方法之外被其他部分使用。它提供了一种方法来组织代码，使其更加清晰和模块化，尤其是当某个操作仅在特定方法中需要且逻辑相对复杂时。

然而，如果你发现你需要多次重用相同的局部内部类，或者类变得相对较大，那么可能考虑将其转变为外部类或常规的内部类会更为合适。

# 静态内部类

静态内部类是定义在另一个类中的静态类。它是内部类的一种，但与常规的内部类（非静态内部类）有几个关键区别。最主要的区别是静态内部类不持有其外部类的引用，因此它不能直接访问外部类的非静态成员。

以下是关于静态内部类的一些主要特点：

1. **静态特性**：静态内部类是`static`的，这意味着它是属于外部类的，而不是外部类的任何特定实例。
2. **不持有外部类引用**：与非静态内部类不同，静态内部类不持有对其外部类的任何引用。因此，它不能直接访问外部类的非静态成员。
3. **创建不依赖外部类实例**：由于静态内部类不持有外部类的引用，因此可以独立于外部类的实例创建。这与非静态内部类不同，后者需要外部类的实例才能创建。
4. **可以有静态成员**：与非静态内部类不同，静态内部类可以有自己的静态成员。
5. **访问权限**：静态内部类可以被声明为`public`、`private`、`protected`或`default`（包私有）。

## 示例

```Java
public class OuterClass {
    private static int staticVar = 10;
    private int instanceVar = 20;

    // 静态内部类
    static class StaticInnerClass {
        private int innerVar = 30;

        public void printVars() {
            System.out.println(staticVar);  // 可以直接访问外部类的静态变量
            // System.out.println(instanceVar);  // 错误：不能直接访问外部类的非静态变量
        }
    }

    public static void main(String[] args) {
        // 创建静态内部类的实例
        OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();
        inner.printVars();
    }
}
```

## 使用场景

静态内部类主要用于组织与外部类紧密相关但不需要访问外部类实例成员的类。当你想要创建一个与外部类相关联的辅助类，但不需要访问外部类的非静态成员时，可以使用静态内部类。

此外，由于静态内部类不持有对外部类的隐式引用，它通常在性能上稍微优于非静态内部类，因为它避免了额外的引用开销。

# 成员内部类

```Java
方式一：
public class Test {
    public static void main(String[] args) {
        // 创建内部类对象
        Outer.Inner oi = new Outer().new Inner();
        oi.method();
    }
}

class Outer {
    // 成员内部类，属于外部类对象的。
    // 拓展：成员内部类不能定义静态成员。
    public class Inner{
        public void method(){
            System.out.println("内部类中的方法被调用了");
        }
    }
}

// 方式二
public class OuterClass {
    private String outerField = "Outer field";

    class InnerClass {
        public void display() {
            System.out.println("Inner class method.");
        }
    }

    public void createInnerInstance() {
        InnerClass inner = new InnerClass();
        inner.display();
    }
}
```

## 创建成员内部类对象两种方式

### 从外部类的内部创建

当你在外部类的内部（比如在外部类的一个方法中）时，你可以直接创建内部类的实例，因为在这种情况下，内部类可以直接访问外部类的成员和方法。

```Java
public class OuterClass {
    private String outerField = "Outer field";

    class InnerClass {
        public void display() {
            System.out.println("Inner class method.");
        }
    }

    public void createInnerInstance() {
        InnerClass inner = new InnerClass();
        inner.display();
    }
}
```

在这个例子中，`createInnerInstance` 方法在 `OuterClass` 内部创建了 `InnerClass` 的一个实例。

### 从外部类的外部创建

当你在外部类的外部创建内部类的实例时，你首先需要一个外部类的实例，然后使用这个外部类实例来创建内部类实例。

```Java
public class Main {
    public static void main(String[] args) {
        // 首先创建外部类的实例
        OuterClass outer = new OuterClass();

        // 然后使用外部类的实例来创建内部类的实例
        OuterClass.InnerClass inner = outer.new InnerClass();
        inner.display();
    }
}
```

在这个例子中，我们首先创建了 `OuterClass` 的一个实例 `outer`，然后使用 `outer.new InnerClass()` 来创建 `InnerClass` 的一个实例。

编写成员内部类的注意点：

1. 成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等
2. 在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。
3. 创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。（请参见3.6节的内存图）

详解：

**内部类被private修饰，外界无法直接获取内部类的对象**

被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象

内部类被static修饰是成员内部类中的特殊情况，叫做静态内部类。

**内部类如果想要访问外部类的成员变量**，**外部类的变量必须用final修饰**，JDK8以前必须手动写final，JDK8之后不需要手动写，JDK默认加上。