主线程结束了，并不代表其他线程也结束了，也不代表进程就结束了。

# 创建线程的三种方式

1. **继承Thread类，重写run方法**
2. start方法是核心，start方法调用start0方法，start0(才是真正实现多线程的方法，而不是run方法)是由JVM调用的，**该线程并不一定会立马执行**，只是将线程变成了可运行状态，**具体什么时候执行，取决于CPU**，由CPU统一调用
3. **实现Runnable接口，重写run方法**
4. 因为java是单继承的，所以在某行且况下一个类可能已经继承了某个父类，这时再用继承Thread类方法来创建线程显然不可能了。另外一种方式创建线程，就是通过实现Runnable接口来创建线程。
5. 底层使用了代理模式(设计模式)
6. **实现Callable接口，重写call方法**
7. 使用Callable、FutureTask和Thread的组合工作的原理是:
8. **Callable** **定义了带返回值的任务**。我们在MyCallable中实现call()方法来定义这个线程需要执行的任务逻辑。并指定一个返回类型。
9. **FutureTask** 用于包装Callable任务,作为中间接口层。FutureTask实现了Runnable接口,相当于一个可以持有计算结果的Runnable。它也实现了Future接口,可以在任务结束后获得计算结果。
10. **Thread** 用于执行任务。我们创建了一个Thread实例,并传入FutureTask作为这个线程需要执行的任务。这是标准的传入Runnable的方法。
11. 当Thread.start()方法调用时:它会驱动FutureTask中的逻辑执行。当FutureTask开始执行时,它会调用MyCallable中的call方法去执行我们定义的任务逻辑。一旦call()执行完成,它返回一个值,这个返回值被持有在FutureTask中。
12. 通过调用futureTask.get()方法,主线程可以获得到MyCallable任务返回的结果。
13. 所以**FutureTask既充当了可运行(Runnable)的任务,也持有了计算结果(Future)**。它很好地连接起了这两个接口,完成了在线程中执行任务并获得返回值这一整个流程。

# 继承Thread类

```Java
package Thread.ThreadUse_;

public class Thread01 {
    public static void main(String[] args) throws InterruptedException {
        Cat cat = new Cat();
        cat.start();

        System.out.println("主线程继续执行" + Thread.currentThread().getName());
        for(int i = 0; i < 60; i++) {
            System.out.println("主线程 i=" + i);
            Thread.sleep(1000);
        }
    }
}
class Cat extends Thread {
    int times = 0;
    @Override
    public void run() {
        while (true) {
            System.out.println("喵喵, 我是小猫咪" + (++times) + " 线程名=" + Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if(times == 80) {
                break;
            }
        }
    }
}
```

尽管没有直接调用 cat.run()，但仍然看到了 run() 方法中的输出。**如果你直接调用 cat.run() 而不是 cat.start()，那么 run() 方法会像一个普通的Java方法一样在主线程中执行，而不会启动任何新的线程。**

start() 方法负责启动一个新的线程并在该线程中调用 run() 方法。这是Java多线程编程的标准做法。

# 实现Runnable接口

```Java
/**
 * main线程启动两个子线程
 */
public class Thread03 {
    public static void main(String[] args) {
        T1 t1 = new T1();
        T2 t2 = new T2();
        Thread thread1 = new Thread(t1);
        Thread thread2 = new Thread(t2);
        thread1.start();//启动第1个线程
        thread2.start();//启动第2个线程
    }
}

class T1 implements Runnable {
    int count = 0;

    @Override
    public void run() {
        while (true) {
            //每隔1秒输出 “hello,world”,输出10次
            System.out.println("hello,world " + (++count));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if(count == 10) {
                break;
            }
        }
    }
}

class T2 implements Runnable {
    int count = 0;
    @Override
    public void run() {
        //每隔1秒输出 “hi”,输出5次
        while (true) {
            System.out.println("hi " + (++count));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if(count == 5) {
                break;
            }
        }
    }
}
```

### start方法和run方法之间的关系是什么呢？

run方法就是一个普通的方法, 如果不先执行start方法而直接执行run方法，就相当于没有真正的启动一个线程。

为什么不能实例对象直接调用run方法呢？

`**run()**` **方法本身只是一个普通的方法。如果你直接调用** `**run()**` **而不是** `**start()**`**，那么** `**run()**` **方法会在当前线程中执行，就像调用任何其他普通方法一样。这样做并不会启动一个新的线程。**

1. `**start()**` **方法**：当你调用一个线程的 `start()` 方法时，Java 虚拟机会为这个新线程分配必要的系统资源（如内存、CPU 时间片等），然后调用该线程的 `run()` 方法来执行实际的任务。这个过程是并发的，也就是说，`start()` 方法会立即返回，而 `run()` 方法会在新的线程中并发执行。
2. `**run()**` **方法**：这是你必须重写的方法，其中**包含了线程应执行的具体操作**。这个方法会被 `start()` 方法自动调用，并在新分配的线程中执行。

因此，`start()` 和 `run()` 之间的关系是：`start()` 方法负责启动一个新线程并调用 `run()` 方法，而 `run()` 方法则包含了线程执行的具体逻辑。

# 实现callable接口

```Java
class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        // sum of 1 to 100
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            sum += i;
        }
        return sum;
    }
}

public class ThreadDemo3 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 表示多线程要执行的任务
        MyCallable myCallable = new MyCallable();
        // 管理多线程运行的结果
        FutureTask<Integer> futureTask = new FutureTask<Integer>(myCallable);
        // 表示线程
        Thread t = new Thread(futureTask);

        t.start();

        Integer integer = futureTask.get();
        System.out.println(integer);
    }
}
```

# 区分三种实现方式

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708340894394-791f92e4-bbb0-4020-b432-b8c0d5d6d21f.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708340894394-791f92e4-bbb0-4020-b432-b8c0d5d6d21f.png)

# 线程常用方法

# 设置和获取线程名称

|   |   |
|---|---|
|方法名|说明|
|void  setName(String name)|将此线程的名称更改为等于参数name|
|String  getName()|返回此线程的名称|
|Thread  currentThread()|返回对当前正在执行的线程对象的引用|

# 线程休眠

|   |   |
|---|---|
|方法名|说明|
|static void sleep(long millis)|使当前正在执行的线程停留（暂停执行）指定的毫秒数|

# 线程的优先级

线程调度

- 两种调度方式
- 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片
- 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些

Java使用的是抢占式调度模型

随机性: 假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的

|   |   |
|---|---|
|方法名|说明|
|final int getPriority()|返回此线程的优先级|
|final void setPriority(int newPriority)|更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10|

# 守护线程

|   |   |
|---|---|
|方法名|说明|
|void setDaemon(boolean on)|将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出|

```Java
public class MyThread1 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(getName() + "---" + i);
        }
    }
}
public class MyThread2 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() + "---" + i);
        }
    }
}
public class Demo {
    public static void main(String[] args) {
        MyThread1 t1 = new MyThread1();
        MyThread2 t2 = new MyThread2();

        t1.setName("女神");
        t2.setName("备胎");

        t2.setDaemon(true);

        t1.start();
        t2.start();
    }
}
```

当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了。

# yield()和join()两个方法区分

### Thread.yield()

- **目的**：`yield()` 是一个静态方法，当一个线程调用 `yield()` 时，它给线程调度器一个暗示，表明当前线程愿意放弃其当前的时间片，以便调度器可以运行其他相同优先级的线程。但是，这只是一个暗示，调度器可能会忽略它。
- **行为**：调用 `yield()` 的线程暂停执行，进入就绪（`RUNNABLE`）状态，等待下一次线程调度；但没有任何机制保证它不会被立即重新选中。
- **使用场景**：`yield()` 通常用于调试或测试目的，或者当你想要提高具有相同优先级的其他线程的运行机会时。

### Thread.join()

- **目的**：`join()` 方法允许一个线程等待另一个线程完成。如果线程 A 调用了线程 B 的 `join()` 方法，线程 A 将会被阻塞，直到线程 B 完成执行或者到达指定的等待时间。
- **行为**：在 `join()` 期间，调用 `join()` 的线程（线程 A）会进入 TIMED_WAITING（如果调用了带超时的 `join()`）或 WAITING（如果调用了不带超时的 `join()`）状态。
- **使用场景**：当你需要确保某个线程完成其任务再继续执行当前线程时，例如，等待某个加载资源的线程完成后，再进行资源处理的操作。

# 线程同步

# 同步代码块

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1709505802873-8da4faf3-e96f-486e-a6a6-0b20cacaefe9.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1709505802873-8da4faf3-e96f-486e-a6a6-0b20cacaefe9.png)

- 安全问题出现的条件
- 是多线程环境
- 有共享数据
- 有多条语句操作共享数据
- 如何解决多线程安全问题呢?
- 基本思想：让程序没有安全问题的环境
- 怎么实现呢?
- 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可
- Java提供了同步代码块的方式来解决
- 同步代码块格式：

```Java
synchronized(任意对象) {
	多条语句操作共享数据的代码
}
```

`synchronized`(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁

- 同步的好处和弊端
- 好处：解决了多线程的数据安全问题
- 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率

### 代码示例

```Java
public class MyThread extends Thread {
    // 表示这个类所有的对象，都共享ticket数据 0 ~ 99
    static int ticket = 0;

    @Override
    public void run() {
            while (true) {
                // 同步代码块
                // 小括号中写锁对象，一定要是唯一的
                synchronized (MyThread.class) {
                if (ticket < 100) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    ticket++;
                    System.out.println(getName() + "正在卖第" + ticket + "张票！！！");
                } else {
                    break;
                }
            }
        }
    }
}
```

# 同步方法

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1709506474724-8915977c-2295-49cc-bf35-76b9c44a0d21.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1709506474724-8915977c-2295-49cc-bf35-76b9c44a0d21.png)

同步方法的格式: 同步方法：就是把`synchronized`关键字加到方法上

```Java
修饰符 synchronized 返回值类型 方法名(方法参数) {
	方法体；
}
```

同步方法的锁对象是什么呢? `this`

静态同步方法: 就是把`synchronized`关键字加到静态方法上

```Java
修饰符 static synchronized 返回值类型 方法名(方法参数) {
	方法体；
}
```

同步静态方法的锁对象是什么呢? `类名.class`

### 代码示例

```Java
public class MyRunnable implements Runnable {
    int ticket = 0;

    @Override
    public void run() {
        // 1.循环
        while (true) {
            // 2.同步代码块（同步方法）
            if (method()) {
                break;
            }
        }
    }

    // this
    private synchronized boolean method() {
        // 3.判断共享数据是否到了末尾
        // 如果到了末尾
        if (ticket == 100) {
            return true;
        } else {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 4. 如果没有到末尾
            ticket++;
            System.out.println(Thread.currentThread().getName() + "在卖第" + ticket + "张票！！！");
        }
        return false;
    }
}
```

# Lock锁

虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock。

Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化。

# `ReentrantLock`

`ReentrantLock`是Java中`java.util.concurrent.locks`包提供的一个高级同步机制，用于控制对共享资源的访问。与传统的`synchronized`关键字相比，`ReentrantLock`提供了更灵活的锁定操作，同时也支持更丰富的功能。它是可重入的，意味着同一个线程可以多次获得已经持有的锁。

### 特性和优势

1. **可重入性**：允许线程进入任何一个它已经拥有的锁的同步代码块。`ReentrantLock`跟踪它被锁定的次数，线程每次进入锁定的代码区都需要锁定，每次退出时都需要解锁。只有当锁的持有次数降到0时，锁才被释放。
2. **灵活性**：提供了`tryLock()`方法，它尝试获取锁，如果锁当前不可用（即被其他线程持有），则立即返回而不是等待。这允许在无法获取锁时执行一些其他操作。
3. **可中断的锁获取操作**：`lockInterruptibly()`允许在等待锁的过程中响应中断。
4. **公平锁**：可以创建一个基于公平策略的锁，即按请求锁的顺序来获取锁。这是通过传递`true`给`ReentrantLock`的构造函数来实现的。非公平锁（默认）可能会提高性能，但不保证等待时间的公平性。
5. **条件变量支持**：`ReentrantLock`提供了`Condition`类，这允许线程在某些条件为真之前等待（通过`Condition.await()`），或者在某条件成立时唤醒其他线程（通过`Condition.signal()`或`Condition.signalAll()`）。

### 基本使用

1. **声明一个**`**ReentrantLock**`**对象**：

```Java
private final ReentrantLock lock = new ReentrantLock();
```

1. **锁定和解锁**：在访问共享资源之前锁定，并在访问后解锁：

```Java
lock.lock();  // 在进入同步代码块之前加锁
try {
    // 访问或修改共享资源
} finally {
    lock.unlock();  // 在finally块中释放锁，确保锁一定会被释放
}
```

### 示例

```Java
public class Counter {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;

    public void increment() {
        lock.lock();  // 开始同步区域
        try {
            count++;
        } finally {
            lock.unlock();  // 确保锁被释放
        }
    }

    public int getCount() {
        return count;
    }
}
```

### 总结

`ReentrantLock`是一个强大的同步工具，提供了比`synchronized`关键字更细粒度的控制和更多的功能。它特别适用于复杂的同步任务和高级的并发控制策略。然而，使用时需要更多的注意来确保锁定和解锁逻辑的正确性，以避免死锁或资源泄露。

# 死锁

概述: 线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行

什么情况下会产生死锁？

- 相互排斥条件：资源（在这个例子中是objA和objB）在同一时间只能由一个线程占用。
- 占有且等待条件：一个线程（例如线程A）持有至少一个资源（objA），并且正在等待获取另一个当前被别的线程（线程B）持有的资源（objB）。
- 不可抢占条件：资源只能由占有它的线程释放，不能被抢占。
- 循环等待条件：存在一种线程资源的循环等待关系，例如，线程A等待线程B持有的资源，而线程B又等待线程A持有的资源。

```Java
public class Demo {
    public static void main(String[] args) {
        Object objA = new Object();
        Object objB = new Object();

        new Thread(()->{
            while(true){
                synchronized (objA){
                    //线程一
                    synchronized (objB){
                        System.out.println("小康同学正在走路");
                    }
                }
            }
        }).start();

        new Thread(()->{
            while(true){
                synchronized (objB){
                    //线程二
                    synchronized (objA){
                        System.out.println("小薇同学正在走路");
                    }
                }
            }
        }).start();
    }
}
```

当这两个线程并发运行时，它们可能会各自持有一个锁同时试图获取另一个锁，从而导致彼此永久等待对方释放锁，这就是死锁的情况。