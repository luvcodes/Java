# 并发和并行

并行：在同一时刻，有多个指令在多个CPU上同时执行

并发：在同一时刻，有多个指令在单个CPU上交替执行

# 进程和线程

进程：是正在运行的程序

- 独立性：**进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位**
- 动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的
- 并发性：任何进程都可以同其他进程一起并发执行

线程：是进程中的单个顺序控制流，是一条执行路径

- 单线程：一个进程如果只有一条执行路径，则称为单线程程序
- 多线程：一个进程如果有多条执行路径，则称为多线程程序

# 实现多线程的方式

此处为语雀内容卡片，点击链接查看：[https://www.yuque.com/chuangshiji-poapl/epb8vm/ylp21dnp7elwgey1](https://www.yuque.com/chuangshiji-poapl/epb8vm/ylp21dnp7elwgey1)

# 条件对象

# await, signal, signalAll方法

**调用条件对象上的**`**await**`**方法的线程**必须**是已经获取了相关锁的线程**。这个等待过程发生在线程内部，遵循以下步骤：

1. **线程获取锁**：首先，线程获取锁。这意味着线程现在可以安全地访问那些受锁保护的共享资源。
2. **检查条件**：在持有锁的状态下，线程检查某个特定条件是否满足。如果条件满足，线程将继续执行后续操作；如果不满足，它需要等待。
3. **调用**`**await**`**方法**：如果条件不满足，线程在条件对象上调用`await`方法。这时，发生两件事情：

- **释放锁**：线程释放它持有的锁。这使得其他线程有机会获取这个锁，以修改那个条件。例如，在一个生产者-消费者场景中，如果消费者线程发现缓冲区为空，它会等待（`await`）。然后，生产者线程生产了新的数据项并放入缓冲区，从而改变了条件。
- **线程挂起**：线程挂起，并进入等待状态。它会在这个状态中停留，直到条件可能已被改变。

1. **被唤醒后的操作**：当其他线程在相同的条件对象上调用`signal`或`signalAll`方法时，等待的线程将被唤醒。被唤醒的线程（或线程之一）会尝试重新获取锁。只有当它再次获取到锁之后，它才能继续执行。当条件改变（如缓冲区不再为空）时，修改条件的线程（在我们的例子中是生产者）将在条件对象上调用`signal`或`signalAll`，以通知等待的线程（消费者）条件可能已经满足。
2. **重新检查条件**：通常，被唤醒的线程会重新检查条件是否满足，因为在多线程环境中，状态可能在它等待的期间已经被其他线程改变。被signal或signalAll唤醒的线程（消费者）将尝试重新获取先前释放的锁。如果能够获取锁，它会再次检查条件是否真的满足，如果满足，则继续执行。

通过这种机制，`await`方法允许线程在等待某个条件变为真时释放锁，同时确保当线程被唤醒并继续执行时，它会重新获得锁，保持数据的一致性和线程安全。

# 同步方法

### `synchronized`

- **用途**：`synchronized`关键字在Java中用于控制对共享资源的并发访问。它可以确保在任何时刻只有一个线程可以执行同步代码块或同步方法。
- **如何使用**：
- **同步块**：可以同步一个代码块，通过`synchronized(object)`，其中`object`是一个引用，作为锁的标识。
- **同步方法**：可以在方法定义上使用`synchronized`关键字，这样整个方法成为同步的。

### `wait`

- **用途**：`wait`方法是`Object`类的一部分。一个线程可以调用某个对象的`wait`方法来暂停执行，直到另一个线程在同一个对象上调用`notify`或`notifyAll`方法。
- **如何使用**：
- 必须在同步块或同步方法内部调用（即持有对象的锁）。
- 调用`wait()`会释放锁，并使当前线程进入等待状态。
- `wait`可以被中断，所以最好在循环中调用，并检查等待的条件。

### `notify`

- **用途**：`notify`方法也是`Object`类的一部分。用于唤醒在同一对象上等待的一个线程（如果有的话）。
- **如何使用**：
- 必须在同步块或同步方法内部调用（即持有对象的锁）。
- `notify`不会立即释放锁；锁的释放发生在同步块或同步方法执行完后。

### `notifyAll`

- **用途**：与`notify`类似，但它会唤醒在同一对象上等待的所有线程。
- **如何使用**：
- 与`notify`一样，必须在持有锁的同步块或方法中调用。
- 唤醒所有等待的线程，但这些线程只有在当前线程释放锁之后才有机会继续执行。

### 注意点

- 在调用`wait`, `notify`, 和 `notifyAll`时，必须确保线程已经持有了对象的锁。这通常意味着它们被包含在`synchronized`块或方法中。
- 使用`wait`和`notify`/`notifyAll`时，通常涉及到一种等待条件（比如，共享资源的状态）。因此，调用这些方法通常发生在一种需要线程间协作的场景中。

这些机制是Java线程间通信的基础，但它们需要谨慎使用，以避免死锁、活锁或资源浪费等问题。在许多情况下，Java的`java.util.concurrent`包提供的高级同步工具（如`ReentrantLock`, `Semaphore`, `CountDownLatch`等）可能提供更灵活和强大的功能。

# join方法

在Java中，`join`方法是线程类（`Thread`类）的一个重要方法。**当一个线程执行到另一个线程的**`**join**`**方法时，它会暂停执行，直到被**`**join**`**的线程结束其执行**。简而言之，`**join`方法允许一个线程等待另一个线程完成其执行**。

例如，假设有两个线程A和B。在A线程中调用了B线程的`join`方法，如`B.join()`。这将导致线程A暂停执行，直到线程B完成其执行。这通常用于确保程序以适当的顺序执行任务，特别是在涉及到共享资源或依赖关系时。

```Java
thread.join();     // 等待thread线程终止
thread.join(millis); // 等待thread线程至多millis毫秒
```

其中，`thread`是要等待的线程对象。第一种形式无限期等待直到线程结束，而第二种形式等待指定的毫秒数。如果线程在指定时间内结束，调用线程会继续执行；如果没有结束，调用线程也会在等待时间结束后继续执行。

当线程A在执行过程中遇到了B.join()方法时，A会暂停它当前的执行流程，并等待线程B完成其执行。一旦线程B执行完毕（即线程B的run方法执行结束），线程A就会继续执行它被暂停的部分。

这个机制非常有用于确保线程之间的协调和顺序执行，特别是在处理需要前一个线程完成的任务的情况下。例如，如果线程B正在处理某些必须在线程A执行其后续操作之前完成的数据，那么A调用B.join()就能确保这种顺序性和依赖性得到满足。

# yield方法

在Java中，`yield`方法是`Thread`类的一个静态方法，**用于暂停当前正在执行的线程**，**给其他线程运行机会**。当一个线程调用`yield`方法时，它会告诉调度器它愿意放弃当前的CPU使用权。调度器随后可以决定执行另一个线程或继续执行这个刚刚调用`yield`的线程。

需要注意的是，`yield`是一种启发式的尝试，以改善线程之间的相对进展，但**它并不能保证任何具体的行为**。具体来说，**调用**`**yield**`**的线程可能会立即再次获得CPU时间，也可能会在一段时间后再次执行**。

```Java
Thread.yield();
```

这个方法没有参数，也没有返回值。

使用`yield`方法的一个**常见场景是在想要避免CPU使用率过高的循环中**。例如，如果你有一个紧密循环的线程，它在很短的时间内重复执行大量操作，并且你想要给其他线程更多的运行机会，你可以在循环中调用`yield`。

然而，需要明白的是，`yield`并不是控制线程同步的一种可靠方式。它的行为会因为不同的操作系统和JVM的实现而有所不同。在设计多线程程序时，应该优先考虑Java并发包（如`java.util.concurrent`）提供的同步工具，而不是依赖于`yield`。

# setDaemon方法

守护线程的唯一用途是为了其他线程提供服务。

它们通常用于执行一些后台任务，如垃圾回收、JVM监控和日志记录等。守护线程的最大特点是，如果JVM中只剩下守护线程，JVM将退出。

守护线程与普通线程（用户线程）的**主要区别**在于它们的**生命周期**。**当不存在任何用户线程时，JVM会自动退出，同时会终止所有守护线程，无论它们是否正在执行**。这意味着守护线程**通常不应用于执行关键任务**，因为它们可能在任何时候被中断和终止。

# 如何使用`setDaemon`方法

要将一个线程设置为守护线程，可以使用`Thread`类的`setDaemon`方法。此方法必须在启动线程之前调用。

```Java
Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        // 守护线程执行的代码
    }
});

// 将线程设置为守护线程
thread.setDaemon(true);

// 启动守护线程
thread.start();
```

在这个例子中，我们创建了一个新线程，并通过调用`setDaemon(true)`将其设置为守护线程。然后启动这个线程。一旦JVM中所有的用户线程执行完毕，这个守护线程也会随JVM一同结束，即使它的`run`方法中的代码还没有执行完毕。

需要注意的是，一旦线程开始执行（即调用了`start()`方法后），就不能再改变它的守护状态了。尝试这样做将会引发`IllegalThreadStateException`。

# 对比

下面是`yield`和`join`方法之间的一些主要对比点：

### 1. 目的和行为

- **yield()**:
- `yield`的目的是让当前正在执行的线程暂停执行，从而允许其他具有相同优先级的线程获得执行机会。然而，它只是给线程调度器一个建议，调度器可能会忽略这个建议。调用`yield`的线程可能会很快再次获得CPU时间片。
- **join()**:
- `join`的目的是让一个线程等待另一个线程完成其任务。当一个线程在另一个线程上调用`join`时，它会停止执行，直到被`join`的线程完成执行。`join`是一种确保线程按顺序结束的机制。

### 2. 使用场景

- **yield()**:
- 通常用于调试或测试目的，或者当你想要提高线程之间的交互性和响应性时，尤其是在多线程应用中，可以让CPU更均匀地分配给其他线程。
- **join()**:
- 用于情况下，当一个线程需要等待另一个线程完成其工作才能继续执行。例如，主线程需要等待一个或多个后台线程完成所有任务后才继续执行。

### 3. 控制粒度

- **yield()**:
- `yield`是一种较为轻量级的尝试，用于改善线程之间的调度和协作，但没有强制性。
- **join()**:
- `join`提供了更精确的控制，允许一个线程等待另一个特定线程的终止。

### 4. 确定性

- **yield()**:
- `yield`不保证任何关于线程调度的确定性。线程调度器可能忽视`yield`请求。
- **join()**:
- `join`提供了确定性，确保当前线程会等待直到目标线程结束。

总的来说，`yield`和`join`都是多线程编程中控制线程执行的机制，但它们的应用场景和行为表现有很大差异。`yield`更多地被用于改善线程间的调度和响应性，而`join`用于在必须的情况下同步线程执行顺序。

# 原子性

线程中的原子性是指一个操作在执行过程中不会被其他线程干扰，它是一个不可分割的整体。在多线程环境中，原子性确保当一个线程正在执行某个操作时，没有其他线程可以同时执行这个操作或改变操作涉及的数据。

原子性在并发编程中非常重要，因为它帮助防止竞态条件。竞态条件是指程序的行为依赖于线程调度的顺序或时间间隔，这可能导致不可预测的结果和错误。

### 原子操作的特点

- **不可中断**：一旦开始，就会一直运行到结束，中途不会停下来让其他线程执行。
- **完整性**：要么完全执行，要么完全不执行，不存在部分执行的情况。
- **独立性**：其执行不依赖于其他线程的操作。

### 示例

考虑一个简单的整数增加操作：

```Java
counter++;
```

虽然这看起来是一个单一操作，但实际上它包含三个步骤：读取`counter`的值，增加1，然后写回新值。在多线程环境中，如果两个线程同时执行这个操作，可能会发生竞态条件，导致一些增加操作被覆盖，从而得到错误的结果。

### 实现原子性

在Java中，可以通过多种方式实现原子性：

1. **Synchronized**：使用`synchronized`关键字可以确保一个代码块在同一时刻只能由一个线程执行。
2. **Locks**：`java.util.concurrent.locks`包中的锁，如`ReentrantLock`，也提供了一种保证原子性的方法。
3. **原子变量**：`java.util.concurrent.atomic`包提供了一系列原子类（如`AtomicInteger`, `AtomicLong`），这些类使用高效的机器级别原子操作来保证单个变量操作的原子性。

原子性是多线程编程中保证数据一致性和完整性的关键概念，特别是在处理共享数据和资源时。正确理解和实现原子性是避免并发相关错误的重要一步。

[[线程的基本使用]]

[[锁]]

[[消费者和生产者模式]]

[[线程的生命周期]]

[[线程池]]

[[线程的原子性]]

[[并发工具类]]

[[题目]]

[[模拟面试题]]