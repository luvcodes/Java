# 线程池意义

系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，**频繁的创建和销毁线程对系统的资源消耗**有可能大于业务处理，这样就有点"舍本逐末"了。

针对这一种情况，**为了提高性能**，我们就可以采用线程池。**线程池在启动的时侯，会创建大量空闲线程**，当我们向线程池提交任务的时侯，线程池就会启动一个线程来执行该任务。

等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。

# 线程池的设计思路

线程池的思路和生产者消费者模型是很接近的

1. 准备一个任务容器
2. 一次性启动多个(2个)消费者线程
3. 刚开始任务容器是空的，所以线程都在wait
4. 直到一个外部线程向这个任务容器中扔了一个"任务"，就会有一个消费者线程被唤醒
5. 这个消费者线程取出"任务"，并且执行这个任务，执行完毕后，继续等待下一次任务的到来

在整个过程中，都**不需要创建新的线程**，而是**循环使用这些已经存在的线程**。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708431121419-3a481a3f-6551-4313-84ae-606d9ca142a9.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708431121419-3a481a3f-6551-4313-84ae-606d9ca142a9.png)

# 自定义线程池

# 自定义线程池的工作原理

看这个视频的讲解: [https://www.bilibili.com/video/BV1yW4y1Y7Ms?p=164&spm_id_from=pageDriver&vd_source=638cc86179a132cc986508a1d8c81526](https://www.bilibili.com/video/BV1yW4y1Y7Ms?p=164&spm_id_from=pageDriver&vd_source=638cc86179a132cc986508a1d8c81526)

自定义线程池的工作原理遵循Executor框架和ThreadPoolExecutor的基本规则, 主要是:

1. 线程池初始化时会创造指定个数的核心线程准备接受任务。
2. 新任务过来时, **先**尝试直接交给**核心线程**执行, 核心线程都占用则进入阻塞队列暂存。
3. 当队列满了后, 才会创建新线程, 数量不超过设定的最大线程数。
4. 线程执行完任务后, 会**重复使用**, 而不是销毁。若超过指定空闲时间, 则会终止。
5. 如果全部线程/队列都占满了, 这时会执行**拒绝策略**。比如抛异常或直接丢弃任务。

通过构造函数自定义各参数,可以控制线程池的大小、超时时间以及队列规则等,定制自己的线程池行为特征。

任务提交给线程池后,线程池完成自身的调度管理,无需我们自己管理线程生命周期,很大程度简化了多线程管理。

这就是自定义线程池的整体工作原理。可以通过不同配置来控制池化线程的调度方式。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1709515528972-841d8e0c-8188-403e-941c-1eab81e01866.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1709515528972-841d8e0c-8188-403e-941c-1eab81e01866.png)

## 线程池-Executors

概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。

我们可以使用Executors中所提供的**静态**方法来创建线程池

- static ExecutorService newCachedThreadPool() 创建一个默认的线程池
- static newFixedThreadPool(int nThreads) 创建一个指定最多线程数量的线程池

## ThreadPoolExecutor

**创建线程池对象 :**

ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);

```Java
public class MyThreadPoolDemo3 {
//    参数一：核心线程数量
//    参数二：最大线程数
//    参数三：空闲线程最大存活时间
//    参数四：时间单位
//    参数五：任务队列
//    参数六：创建线程工厂
//    参数七：任务的拒绝策略
    public static void main(String[] args) {
        ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue<>(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
        pool.submit(new MyRunnable());
        pool.submit(new MyRunnable());

        pool.shutdown();
    }
}
```

### 7个参数

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1701324200944-f9208f4d-3893-42d4-915e-44b275ae4cf0.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1701324200944-f9208f4d-3893-42d4-915e-44b275ae4cf0.png)

自定义ThreadPoolExecutor时,它一共有7个参数,默认值和含义如下:

1. corePoolSize : 核心线程池大小,默认为0
2. maximumPoolSize: 最大线程数,默认为Integer.MAX_VALUE
3. keepAliveTime: 线程空闲时间,默认为60s
4. unit: 第三个参数的时间单位,默认为TimeUnit.SECONDS
5. workQueue: 任务队列,默认为SynchronousQueue(直接提交队列)
6. threadFactory:线程工厂,默认为DefaultThreadFactory
7. handler: 拒绝策略,默认为ThreadPoolExecutor.AbortPolicy(抛出RejectedExecutionException异常)

所以在自定义时,常见的只设置前2-3个参数来控制核心池和最大池大小。后面的4-5个参数也较常用。

一般会自定义队列类型(ArrayBlockingQueue常用)、ThreadFactory和拒绝策略等。

## 核心线程与临时线程

在Java的线程池（ThreadPoolExecutor）中，线程分为两类：核心线程（Core Threads）和临时线程（Non-core Threads 或者称为额外线程）。它们之间的主要区别在于它们的创建和存活策略，以及它们如何被线程池管理。下面详细解释这两类线程的区别：

### 核心线程（Core Threads）

1. **定义**：核心线程是线程池创建并启动的初始线程，它们的数量由线程池的核心线程数（corePoolSize）参数定义。线程池在启动时可能不会立即创建所有核心线程，而是根据需要逐渐创建，直到达到核心线程数的限制。
2. **存活策略**：默认情况下，核心线程即使是空闲的（即没有任务执行），也会一直保持在线程池中，除非设置了允许核心线程超时（`allowCoreThreadTimeOut(true)`）。在允许超时的情况下，核心线程在空闲一定时间后（超过keepAliveTime指定的时间）会被终止和移除线程池。

### 临时线程（Non-core Threads）

1. **定义**：**当所有的核心线程都在忙碌时**（即都在执行任务），并且队伍当中都已经排满了，如果线程池接收到更多的任务，并且当前线程总数还没有达到线程池的最大线程数（maximumPoolSize），**线程池会创建额外的线程**，即**临时线程**，来处理这些额外的任务。
2. **存活策略**：临时线程不会像核心线程那样永久保持在线程池中。当它们完成任务后，如果在一定时间（keepAliveTime）内没有新的任务分配给它们，它们就会被终止并从线程池中移除。这个时间限制确保了在负载减轻时线程池可以缩减其大小，释放资源。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1709514793588-a1ef0279-2707-41cc-8aa0-f7d977c1ed0f.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1709514793588-a1ef0279-2707-41cc-8aa0-f7d977c1ed0f.png)

这里的任务7和任务8才会需要让线程池创建临时线程。

### 主要区别总结

- **存活时间**：核心线程默认情况下会一直存活，除非设置了超时策略；而临时线程在空闲一定时间后会被自动回收。
- **创建时机**：核心线程是线程池初始化或任务到来时创建的，直到达到corePoolSize；临时线程则是在核心线程都忙碌且当前线程数小于maximumPoolSize时创建的，用于处理额外的任务。
- **数量限制**：核心线程的数量由`corePoolSize`确定，临时线程的数量加上核心线程的总数不能超过`maximumPoolSize`。

线程池的这种设计允许它在任务负载变化时动态调整线程数量，提高资源利用率，同时减少资源消耗。

## 任务拒绝策略

任务丢弃/拒绝策略(`RejectedExecutionHandler`)决定当线程池队列和最大线程数都满了的情况下如何处理新任务。它通过构造线程池ThreadPoolExecutor对象时指定。

```Java
ThreadPoolExecutor.AbortPolicy: 		    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。
ThreadPoolExecutor.DiscardPolicy： 		   丢弃任务，但是不抛出异常 这是不推荐的做法。
ThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。
ThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。
```

主要有以下4种策略:

1. **AbortPolicy**:默认策略,直接抛出RejectedExecutionException异常。
2. **CallerRunsPolicy**:在调用者线程中直接运行任务。
3. **DiscardPolicy**:不处理,直接丢弃掉这个任务。
4. **DiscardOldestPolicy**:丢弃队列中最老的一个请求任务,然后重新提交当前任务到队列中尝试。

**推荐使用AbortPolicy**, 它不会默默丢掉任务且能明确失败notifications。

CallerRunsPolicy也可以, 它会降级到同步运行, 继续保证任务运行(但有延迟)。

两个Discard类策略一般很少使用, 它会损失一些请求。

### **AbortPolicy策略的解释**

AbortPolicy 是线程池任务拒绝策略中的默认策略,当线程池队列和最大线程数都满了时,它的工作原理是:

1. 当线程池收到新任务提交时,会首先检测核心线程池是否有空闲线程来执行这个任务。
2. 如果核心池满了,则会将任务加入到阻塞队列中等待。
3. 当阻塞队列也满了的时候,这时使用AbortPolicy策略,它会直接抛出RejectedExecutionException异常。
4. 这个异常会被主线程接收到,需要主线程自行来决定如何处理这个异常。比如记录日志、持久化存储、失败回调等。
5. 通过抛出异常的方式,AbortPolicy能够停止试图处理新任务,所以不会导致过多请求涌入QUEUE并耗尽内存。
6. 且通过抛出异常能明确通知调用者任务被拒绝的情况,失败结果可控。

所以 AbortPolicy 策略的核心工作原理是主动抛出异常,迫使应用程序严格面对任务拥塞的情况,而不是对失败请求隐藏或覆盖。这启发我们在程序中增加容错处理。

# 线程池创建多大合适呢？

## 最大并行数

跟CPU型号有关系

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1701329457898-961d06a9-2880-48e3-ac5d-7d61498b6d15.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1701329457898-961d06a9-2880-48e3-ac5d-7d61498b6d15.png)