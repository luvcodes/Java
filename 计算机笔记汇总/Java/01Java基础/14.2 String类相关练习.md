# 练习题 1

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707403746954-a6ed54a5-a6ee-4331-9b7d-e7b6533efb64.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707403746954-a6ed54a5-a6ee-4331-9b7d-e7b6533efb64.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707781257309-ca9cc46e-5d14-4073-9c59-fe4d347983bf.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707781257309-ca9cc46e-5d14-4073-9c59-fe4d347983bf.png)

# 练习题 2

```Java
String s 1 = "coder";
String s 2 = "coder";
String s 3 = "coder" + s 2;
String s 4 = "coder" + "coder";
String s 5 = s 1 + s 2;
System.Out.Println (s 3 == s 4);
System.Out.Println (s 3 == s 5);
System.Out.Println (s 4 == "codercoder");
```

在 Java 中，字符串的处理方式，特别是在字符串字面量、字符串内部化（interning）和字符串连接方面，可能有些难以理解。让我们分析一下你提供的代码片段：

1. `String s 1 = "coder";` 和 `String s 2 = "coder";` - 这里，`s 1` 和 `s 2` 都引用了字符串池中的同一个字符串字面量 "coder"。
2. `String s 3 = "coder" + s 2;` - 在这种情况下，`s 3` 通过连接一个字符串字面量和一个字符串引用（`s 2`）来创建。这是在运行时发生的，因此 `s 3` 不是引用字符串池中的字符串，而是一个新的字符串对象。
3. `String s 4 = "coder" + "coder";` - 这里，`s 4` 是通过连接两个字符串字面量创建的。Java 编译器将其优化为单个字符串字面量 "codercoder"，并将其内部化到字符串池中。
4. `String s 5 = s 1 + s 2;` - 类似于 `s 3`，`s 5` 是通过连接两个字符串引用在运行时创建的，结果是一个新的字符串对象。

现在，让我们来看看 `println` 语句：

- `System.Out.Println (s 3 == s 4);` - 这比较了 `s 3` 和 `s 4` 的引用。由于 `s 3` 是在运行时创建的字符串，而 `s 4` 是编译时的字面量，它们引用了不同的对象。输出将是 `false`。
- `System.Out.Println (s 3 == s 5);` - `s 3` 和 `s 5` 都是通过连接字符串在运行时创建的。然而，它们是分别创建的不同对象，所以这个比较也将是 `false`。
- `System.Out.Println (s 4 == "codercoder");` - 这里，`s 4` 和 `"codercoder"` 都引用了字符串池中的同一个内部化字符串。所以，这个比较将是 `true`。

总结一下，你的代码的输出将是：

```Java
False
False
True
```

# 字面量创建和 new String 创建字符串

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703251122438-e50b70cc-fc2d-44e1-92c3-12ffd27f83b9.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703251122438-e50b70cc-fc2d-44e1-92c3-12ffd27f83b9.png)

在字符串常量池中，独立于它们是如何被引用的，相同内容的字符串只会有一个实例。这就是**字符串常量池的目的**：它确保了**所有相同的字符串字面量都指向池中的同一个对象实例**，以**减少内存占用和提高性能**。

1. **栈内存中的** `**str**` **变量指向** `**"hello"**`:

- 当您使用字面量方式创建字符串，如 `String str = "hello";`，`str` 将直接指向字符串常量池中的 `"hello"`。

1. **堆内存上的** `**new String ("hello")**` **对象**:

- 当您使用 `new String ("hello")` 创建一个新的 `String` 对象，这个对象在堆上，并且内部包含一个指向字符串常量池中 `"hello"` 的引用。

在这两种情况下，字符串常量池中的 `"hello"` 是同一个对象。无论是 `str` 变量还是通过 `new` 关键字创建的 `String` 对象，它们都引用了字符串常量池中相同的 `"hello"` 字符串实例。

总结来说，**字符串常量池中的一个特定字符串（如 "hello"）只存在一个唯一的实例**，无论它被多少个变量或对象引用。这就是为什么字符串常量池可以有效地减少重复字符串的内存占用，并在字符串处理中提供性能优势。您的理解基本正确，但需要一点澄清。让我们逐步分解这两种情况：

### 当字符串常量池中不存在 "hello"

1. **栈内存**: `str` 变量存在于栈内存中。
2. **堆内存**: 使用 `new String ("hello")` 在堆上创建一个新的 `String` 对象。
3. **字符串常量池**: 字符串字面量 `"hello"` 被存储在字符串常量池中，如果它之前不存在的话。
4. **引用关系**:

- `str` 变量在栈上引用了堆上的 `String` 对象。
- 堆上的 `String` 对象包含了指向字符串常量池中 `"hello"` 的引用。

### 当字符串常量池中已存在 "hello"

1. **栈内存**: `str` 变量依然存在于栈内存中。
2. **堆内存**: 使用 `new String ("hello")` 仍然会在堆上创建一个新的 `String` 对象，即使 `"hello"` 已经存在于字符串常量池中。
3. **字符串常量池**: `"hello"` 已经存在，不会重复创建。
4. **引用关系**:

- `str` 变量在栈上引用了堆上的 `String` 对象。
- 堆上的 `String` 对象依然包含了指向字符串常量池中 `"hello"` 的引用。

总结：

- **不管字符串常量池中是否已存在** `"hello"` 字符串，使用 `new String ("hello")` **都会在堆上创建一个新的** `String` 对象，并且这个新对象会引用字符串常量池中的 `"hello"` 字符串（如果它不存在，首先会在常量池中创建）。
- `str` 变量（在栈上）总是指向堆上的这个新创建的 `String` 对象，而不是直接指向字符串常量池中的 `"hello"` 字符串。

因此，在这种情况下，即使字符串常量池中已经有了 `"hello"` 字符串，`new String ("hello")` 仍然会在堆上创建一个新的 `String` 对象，并且栈上的 `str` 变量会引用这个新创建的对象。