# 概念

- 泛型的介绍: 泛型是JDK5中引入的特性，它提供了**编译时类型安全检测机制**
- 泛型的好处

1. 把运行时期的问题提前到了编译期间
2. 避免了强制类型转换

- 泛型的定义格式
- <类型>: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如:
- <类型1,类型2…>: 指定多种类型的格式,多种类型之间用逗号隔开.例如: <E,T> <K,V>

![[截屏2024-03-16 下午6.42.32.png]]

![[截屏2024-03-16 下午6.43.07.png]]

# 泛型的细节

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710624758913-6f55a6b8-e27a-4663-b3ec-1f0274bdf7cf.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710624758913-6f55a6b8-e27a-4663-b3ec-1f0274bdf7cf.png)

# 自定义泛型

## 泛型类

![[截屏2024-03-17 上午8.35.09.png]]

```Java
public class MyArrayList<E> {
    Object[] obj = new Object[10];
    int size;

    public boolean add(E e) {
        obj[size] = e;
        size++;
        return true;
    }

    public E get(int index) {
        return (E) obj[index];
    }

    @Override
    public String toString() {
        return Arrays.toString(obj);
    }
}
```

```Java
    public static void main(String[] args) {
        MyArrayList<String> list = new MyArrayList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        System.out.println(list);
        System.out.println("--------------------------------");

        MyArrayList<Integer> list2 = new MyArrayList<>();
        list2.add(123);
        list2.add(456);
        list2.add(789);
        int i = list2.get(0);
        System.out.println(i);
        System.out.println(list2);
    }
```

## 泛型方法

![[截屏2024-03-17 上午8.55.04.png|500]]

![[截屏2024-03-17 上午8.56.20.png|500]]

![[截屏2024-03-17 上午8.57.35.png|525]]

## 泛型接口

![[截屏2024-03-17 上午9.25.44 1.png|500]]

泛型接口是指在定义接口时引入一个或多个类型参数的接口。这样的接口可以被实现为具体的类型，从而使得接口中的方法签名能够针对特定的类型进行操作，增加了接口的通用性和复用性。

### 定义泛型接口

泛型接口的定义与泛型类的定义类似。你需要在接口名称后面添加尖括号`<>`，并在其中指定一个或多个类型参数。这些类型参数随后可以在接口定义中的方法签名、返回类型或参数类型中使用。

例如，定义一个泛型接口`Repository`，用于数据存储的CRUD操作：

```Java
public interface Repository<T> {
    void add(T item);
    T get(int id);
    void update(T item);
    void delete(T item);
}
```

在这个例子中，`T`是一个类型参数，代表存储在仓库中的数据类型。实现这个接口时，你可以指定`T`的具体类型，使得`Repository`接口可以用于不同类型的数据。

### 实现泛型接口

实现泛型接口时，可以指定类型参数的具体类型。例如，如果你有一个`User`类，可以创建一个实现了`Repository<User>`的类：

```Java
public class UserRepository implements Repository<User> {
    @Override
    public void add(User item) {
        // 实现添加用户的逻辑
    }

    @Override
    public User get(int id) {
        // 实现根据id获取用户的逻辑
        return null;
    }

    @Override
    public void update(User item) {
        // 实现更新用户的逻辑
    }

    @Override
    public void delete(User item) {
        // 实现删除用户的逻辑
    }
}
```

### 泛型接口的优势

- **类型安全**：使用泛型接口可以在编译时期检查类型安全，避免运行时的类型转换错误。
- **代码复用**：通过泛型接口，相同的接口定义可以用于多种数据类型，提高了代码复用性。
- **灵活性**：泛型接口允许在实现接口时指定具体的类型，使得接口更加灵活，能够适应更多的使用场景。

泛型接口在Java的集合框架中广泛使用，例如`List<E>`、`Set<E>`、`Map<K, V>`等都是泛型接口的例子，它们允许创建类型安全的集合，以存储特定类型的对象。

## 泛型的通配符

泛型的通配符（Wildcard）是Java泛型编程中的一个重要概念，它提供了泛型代码的更多灵活性。**在Java中，泛型的通配符使用**`**?**`**符号表示**。它主要用在泛型类型的参数化类型声明中，当你不确定使用什么类型或者想表达更加通用的类型时非常有用。通配符主要有两种形式：**无界通配符**（Unbounded Wildcards）和**有界通配符**（Bounded Wildcards）。

### 无界通配符 `?`

无界通配符`?`表示未知类型。它被用于声明一个泛型类型时，你不关心实际的类型参数是什么。例如，你可以用它来编写一个方法，该方法可以接受任何类型的`List`对象：

```Java
public void printList(List<?> list) {
    for (Object elem : list) {
        System.out.println(elem);
    }
}
```

在这个例子中，`List<?>`表示“任何类型的List”，无论是`List<String>`、`List<Integer>`还是其他任何`List`类型。

### 有界通配符

有界通配符通过使用关键字`extends`（用于类和接口）和`super`（只用于类）来限制未知类型的范围。

### 上界通配符 `? extends T`

上界通配符 `? extends T` 表示类型的上限，它表示参数化类型可能是T或者是T的某个子类型。它对传递给泛型类型的类型进行了限制。例如，你可以这样定义一个方法，它接受只读的 `List`，其元素是 `Number` 类型或者 `Number` 的子类：

```Java
public void printNumbers(List<? extends Number> list) {
    for (Number elem : list) {
        System.out.println(elem);
    }
}
```

这个方法可以接受`List<Integer>`、`List<Double>`等等，因为`Integer`和`Double`都是`Number`的子类。

### 下界通配符 `? super T`

下界通配符 `? super T` 表示类型的下限，它表明参数化类型是T或者是T的某个父类型。它在你需要写入或者比较类型时非常有用。例如，你可以定义一个方法，它能够向一个 `List` 中添加元素：

```Java
public void addNumbers(List<? super Integer> list) {
    list.add(1); // 这里可以添加Integer类型的对象
}
```

这个方法可以接受 `List<Integer>`、`List<Number>` 等，因为 `Integer` 是 `Number` 的子类，所以 `Number` 和 `Object` 类型的列表可以安全地添加一个 `Integer` 值。

如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。

如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以泛型的通配符。

# 总结

![[截屏2024-03-17 上午11.58.42.png|500]]

![[截屏2024-03-17 下午12.02.20.png|500]]

