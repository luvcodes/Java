# 自增、自减运算符

## 第一题

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1694837501180-f39887d3-1bc7-492d-bf52-4e1447fef5ee.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1694837501180-f39887d3-1bc7-492d-bf52-4e1447fef5ee.png)

1. 在 `**fermin**` 方法中，参数 `**i**` 的值增加了1。但是，这里的增加只影响方法内的局部变量 `**i**`，并不会影响 `**main**` 方法中的 `**i**`。
2. 回到 `**main**` 方法，执行了 `**i = i++;**` 这行代码。这是一个后缀自增操作，但由于它的赋值操作，实际上 `**i**` 的值并没有改变。这是因为 `**i++**` 会先返回 `**i**` 的当前值（即0），然后 `**i**` 的值增加1，但由于赋值操作，`**i**` 又被重新赋值为0。
3. 最后，使用 `**System.out.println(i);**` 输出 `**i**` 的值。因此，输出结果为 `**0**`

## 第二题

![[%E6%88%AA%E5%B1%8F2023-09-03_%E4%B8%8A%E5%8D%889.17.40.png]]

1. 在 `**fermin**` 方法中，参数 `**i**` 的值增加了1。但是，这里的增加只影响方法内的局部变量 `**i**`，并不会影响 `**main**` 方法中的 `**i**`。
2. 回到 `**main**` 方法，执行了 `**i = i++;**` 这行代码。这是一个后缀自增操作，但由于它的赋值操作，实际上 `**i**` 的值并没有改变。这是因为 `**i++**` 会先返回 `**i**` 的当前值（即0），然后 `**i**` 的值增加1，但由于赋值操作，`**i**` 又被重新赋值为0。
3. 最后，使用 `**System.out.println(i);**` 输出 `**i**` 的值。因此，输出结果为 `**0**`

  

# 取模运算和取余运算

```Java
System.out.println((-3)%2);

System.out.println(4%3);

System.out.println((-3)%(-2));

System.out.println(4%(-3));
```

在Java中，`%`操作符用于取余。**取余运算的结果的符号总是与被除数（左边的数）的符号相同**。

  

1. `(-3) % 2`: 这里 -3 是被除数，2 是除数。在Java中，结果的符号与被除数相同，所以结果是 -1。
2. `4 % 3`: 这里 4 是被除数，3 是除数。4除以3得到商1余1，所以结果是 1。
3. `(-3) % (-2)`: 这里 -3 是被除数，-2 是除数。在Java中，结果的符号与被除数相同，所以结果是 -1。
4. `4 % (-3)`: 这里 4 是被除数，-3 是除数。4除以-3得到商-1余1，但由于在Java中取余结果的符号与被除数的符号相同，结果是 1。

总结来说，在Java中，**取余操作的结果**总是具有与**被除数相同**的**符号**，而与除数的符号无关。