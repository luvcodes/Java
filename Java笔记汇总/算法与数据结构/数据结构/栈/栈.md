# **栈的定义**

- 栈(stack)是限定在表尾进行插入和删除操作的线性表。这个表尾 实际就是允许插入和删除的一端，叫做栈顶(top), 另一侧叫做栈底。**后进先出**的线性表
- 栈底是固定的，最先进栈的只能在栈底

![[%E6%88%AA%E5%B1%8F2023-12-19_%E4%B8%8A%E5%8D%889.56.25.png]]

## 数组实现栈的思路:

1. 定义一个top变量来表示栈顶，初始化为-1s
2. 入栈的操作，当有数据加入到栈时，`top++`, `stack[top] = data;`
3. 出栈的操作，`int value = stack[top];` `top++`; `return value;`

## 单链表实现栈的思路

栈的每个元素都是链表的一个节点，栈顶元素是链表的头节点。这种方法的好处是它允许栈动态地增长和缩减，而不需要担心固定数组大小的限制。

先定义单链表的基本元素，**值**和**后置指针**:

### 创建节点

```Java
class Node {
    public Node next;
    public int value;

    public Node(int value) {
        this.value = value;
        this.next = null;
    }
```

### 创建链表

```Java
class LinkedListStack {
    private Node top;

    public LinkedListStack() {
        top = null;
    }
}
```

**top更多的是一个指针的含义**，哪个节点在栈顶，top就指向谁。

### 添加新节点

想要添加新节点，就是相当于在栈顶上往下压栈，新的节点的next指针，只想原来的top节点 (也就是之前在栈顶的那个节点)。然后top往上移，指向新节点。

```Java
public void push(int value) {
        Node newNode = new Node(value);
        newNode.next = top;
        top = newNode;
    }
```

`newNode.next = top;` 这行代码是关键部分，它定义了新节点如何链接到现有的链表（即栈）中。

1. **创建新节点**：首先，创建一个新的 `ListNode` 实例，名为 `newNode`，并将传入的 `value` 赋值给它。此时，`newNode` 的 `next` 属性尚未设置，意味着它不指向任何节点。
2. **链接新节点**：接下来，执行 `newNode.next = top;`。
    1. 这行代码将 `newNode` 的 `next` 指针设置为当前的 `top`。
    2. 如果栈为空（即 `top` 为 `null`），则 `newNode.next` 也会被设置为 `null`。
    3. 如果栈不为空，`top` 将是指向栈顶节点的指针，因此 `newNode.next = top;` 使得 `newNode` 指向原来的栈顶节点。
3. **更新栈顶**：最后，`top = newNode;` 这行代码更新了 `top` 指针，使其指向新的节点 `newNode`。现在，`newNode` 成为了栈的新顶部。

假设原来的栈（链表）是这样的：

```Plain
栈顶
  |
  V
[A] -> [B] -> null
```

执行 `push(C)` 后的情况：

1. 创建新节点 C
2. 将 C 的 `next` 指向 A（原栈顶）
3. 更新栈顶指针，指向 C

最终的栈（链表）：

```Plain
    栈顶
      |
      V
[C] -> [A] -> [B] -> null
```

### 删除节点

```Java
public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈空，没有数据");
        }
        int value = top.value;
        top = top.next;
        return value;  // 返回出栈的节点的值
    }
```

**为什么不需要删除节点呢？**

使用链表来实现栈不需要考虑栈满的情况，主要是因为链表的动态性质和内存分配方式。下面是详细的解释：

1. **动态大小**：链表是一种动态数据结构，意味着它可以根据需要增长或缩减。当你添加一个新元素到链表实现的栈时，你实际上是在链表的头部创建一个新节点。这个过程不受固定大小限制。
2. **内存分配**：在链表中，每个新元素都是单独分配内存的。与数组不同，链表不需要在创建时预先分配一个固定大小的内存块。每当添加新节点时，只需为该节点分配内存即可。这种方式意味着链表的大小受限于系统的总可用内存，而不是由预先定义的容量限制。
3. **没有预定义容量**：在数组实现的栈中，你通常会有一个预定义的最大容量，这是因为数组的大小在创建时就固定了。但在链表实现中，没有这样的预定义容量限制。你可以继续添加元素，直到系统的内存耗尽。
4. **系统内存限制**：实际上，链表实现的栈的唯一限制是可用内存量。当系统的内存耗尽时，尝试添加更多元素可能会导致内存分配失败。但在实际应用中，这种情况很少发生，除非栈的大小非常大。

# 前缀表达式

![[%E6%88%AA%E5%B1%8F2023-12-20_%E4%B8%8B%E5%8D%886.16.38.png]]

  

# 中缀表达式

![[%E6%88%AA%E5%B1%8F2023-12-20_%E4%B8%8B%E5%8D%886.23.09.png]]

  

# 后缀表达式

![[%E6%88%AA%E5%B1%8F2023-12-20_%E4%B8%8B%E5%8D%886.17.45.png]]

如果操作符栈为空，或栈顶操作符为左括号 (，或**当前操作符优先级高于栈顶操作符，将其压入栈中**。 否则，将栈顶的操作符弹出并添加到后缀表达式列表，直到栈为空或遇到一个优先级更低的操作符，然后将当前操作符压入栈中。

# 练习题

## 栈来实现综合计算器的功能

### 计算器的工作流程

1. **初始化两个栈**：**一个栈（numStack）用于存放数字**，**另一个栈（operStack）用于存放运算符**。
2. **遍历表达式**：
    - **处理数字**：如果遇到数字，我们需要考虑多位数的情况。所以，当遇到一个数字时，并不立即将其压入栈中，而是继续查看下一个字符，直到遇到非数字字符。这时，将完整的数字（可能是多位数）转换成整数并压入数字栈。
    - **处理运算符**：当遇到运算符时，需要比较其与运算符栈顶元素的优先级：
        - 如果运算符栈为空，或者**当前运算符**的优先级**高于栈顶运算符**的优先级，则直接将其**压入运算符栈**。
        - 如果**当前运算符**的优先级**低于或等于栈顶运算符**的优先级，则从**数字栈中弹出两个数**，从**运算符栈中弹出栈顶运算符**，进行计算，然后将计算结果压入数字栈，最后将当前运算符压入运算符栈。
3. **表达式遍历完成**：当整个表达式遍历完成后，可能运算符栈中还有剩余的运算符。此时，继续从数字栈和运算符栈中弹出元素进行计算，直到运算符栈为空。
4. **结果输出**：最后，数字栈中的唯一数字就是整个表达式的计算结果。

### 关键点解释

- **优先级判断**：通过`priority`方法来判断运算符的优先级，这里约定和`/`的优先级高于`+`和。
- **多位数处理**：字符串中的数字可能不止一位，我们通过累加字符并在遇到运算符时转换为整数来处理多位数。
- **运算符栈的作用**：该栈用于处理运算符的优先级。如果当前运算符的优先级高，它可以“等待”后续的数字；如果优先级低或相等，需要先计算栈中已有的运算符。
- **计算操作**：`calculate`方法用于执行基本的四则运算。

## 后缀表达式 - 计算器求值

## 中缀表达式转换为后缀表达式

# 两栈共享空间

### **栈的链式存储结构实现**

- 对比链栈和顺序栈
    - 时间复杂度 = O(1), 不涉及任何循环
    - 顺序栈需要事先确定一个固定的长度，有可能会造成内存资源空间浪费的问题，优势是存储时定位很方便
    - 链栈要求每个元素都有指针域，增加了一些内存开销，但对于栈的长度无限制。

  

[[算法与数据结构/数据结构/栈/练习题/练习题|练习题]]