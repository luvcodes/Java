# 相关概念

## 赫夫曼树定义

带权路径长度**WPL (weighted path length)** **最小的二叉树**称做**赫夫曼树**。

## 路径

在一棵树中，从一个节点往下可以达到的孩子活孙子节点之间的通路，称为路径。

## 路径长度

通路中分支的数目称作路径长度。如果规定根节点的层数为1，则从根节点到第L层节点的路径长度为L - 1

## 节点的权及带权路径长度

若将树中节点赋给一个有着某种含义的数值，则这个数值称为该节点的权。

节点的带权路径长度为: 从根节点到该节点之间的路径长度与该节点的权的乘积。

## 树的路径长度

**树的路径长度**: 从树根到每一节点的路径长度之和

![[/Untitled 37.png|Untitled 37.png]]

二叉树a的WPL = 5x1 + 15x2 + 40x3 + 30x4 + 10x5 = 315

二叉树b的WPL = 5x3 + 15x3 + 40x2 + 30x2 + 10x2 = 220

**WPL更小的是更优的二叉树**

# 赫夫曼树

WPL最小的就是赫夫曼树

# 赫夫曼树创建思路

## 构成赫夫曼树步骤

![[/Untitled 1 15.png|Untitled 1 15.png]]

# 示例题目

![[%E6%88%AA%E5%B1%8F2024-01-07_%E4%B8%8B%E5%8D%885.30.22.png]]

## 代码实现

```Java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class HuffmanTree {
    public static void main(String[] args) {
        int[] arr = {13, 7, 8, 3, 29, 6, 1};
        Node root = createHuffmanTree(arr);

        preOrder(root);
    }

    // 编写前序遍历的方法
    public static void preOrder(Node root) {
        if (root != null) {
            root.preOrder();
        } else {
            System.out.println("Empty tree");
        }
    }

    // 创建赫夫曼树的方法
    public static Node createHuffmanTree(int[] arr) {
        // 第一步为了操作方便
        // 1. 遍历arr数组
        // 2. 将arr的每一个元素构成一个Node
        // 3.  将Node放入到ArrayList中，便于管理
        List<Node> nodes = new ArrayList<>();
        for (int value : arr) {
            nodes.add(new Node(value));
        }

        // 循环处理
        while (nodes.size() > 1) {
            // 排序, 从小到大
            Collections.sort(nodes);
            System.out.println("After sorting: " + nodes);

            // 第二步: 取出根节点权值最小的两棵二叉树
            // 1. 取出权值最小的节点 (二叉树)
            Node leftNode = nodes.get(0);
            // 2. 取出权值第二小的节点 (二叉树)
            Node rightNode = nodes.get(1);
            // 3. 构建一棵新的二叉树
            Node parent = new Node(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;
            // 4. 从arraylist中删除处理过的二叉树，就是leftNode和rightNode
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            // 5. 将parent加入到nodes中
            nodes.add(parent);
            System.out.println("After removing: " + nodes);
        }

        // 返回赫夫曼树的根节点（二叉树）
        return nodes.get(0);
    }
}

// 定义节点类，用于存储节点权值，指向左子节点和右子节点的指针
// 为了让Node对象持续排序Collections集合排序
// 让Node实现Comparable接口
class Node implements Comparable<Node> {
    // 节点权值
    int value;
    // 指向左子节点
    Node left;
    // 指向右子节点
    Node right;

    // 前序遍历
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public Node(int value) {
        this.value = value;
    }

    // override the toString method
    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        // 表示从小到大排序
        return this.value - o.value;
    }
}
```

# 赫夫曼编码

通过一个具体的例子来展示赫夫曼编码的计算过程。假设我们有一个字符串 `"AAABBC"`，我们要对这个字符串进行赫夫曼编码。

1. **统计频率**：首先统计每个字符出现的频率。
    - 'A' 出现了 3 次
    - 'B' 出现了 2 次
    - 'C' 出现了 1 次
2. **构建赫夫曼树**：根据字符频率构建赫夫曼树。从所有字符及其频率开始，将频率最低的两个字符组合在一起，创建一个新的节点，其频率是这两个字符频率的总和。重复这个过程，直到构建出一棵完整的树。
    
    - 将 'C'(1) 和 'B'(2) 组合（总频率 3），得到节点 'BC'
    - 现在，我们有 'A'(3) 和 'BC'(3)。将它们组合（总频率 6），得到树的根节点 'ABC'
    - 赫夫曼树构建完成。
    
    赫夫曼树的结构大致如下：
    
    ```Plain
        ABC(6)
        /    \\
     A(3)    BC(3)
            /    \\
          B(2)   C(1)
    ```
    
3. **生成编码**：从赫夫曼树生成编码。对于每个字符，从根节点到该字符的叶节点的路径定义了它的编码（左为“0”，右为“1”）。
    - 'A' 的编码是 "0"
    - 'B' 的编码是 "10"
    - 'C' 的编码是 "11"
4. **编码原始数据**：使用上面得到的编码来编码原始字符串 `"AAABBC"`。
    
    - 'A' 替换为 "0"
    - 'B' 替换为 "10"
    - 'C' 替换为 "11"
    
    因此，`"AAABBC"` 用赫夫曼编码表示为 "000101011".
    

通过这个过程，原始数据 `"AAABBC"` 被转换成了更短的字符串 `"000101011"`。这就是赫夫曼编码的基本过程。这种编码特别适合于压缩不均匀分布的数据，因为它将最常见的元素编码为最短的序列。

赫夫曼树根据排序方法不同，生成的结果可能不太一样，对应的赫夫曼编码也不完全一样，但是WPL是一样的，都是最小的，最后生成的赫夫曼编码的长度是一样。

## 实践数据压缩 (创建赫夫曼树)

给出一段文本 `“i like like like java do you like a java”` 对其进行数据压缩处理

1. 创建文本对应的赫夫曼树
2. 继续完成
    1. 生成赫夫曼树对应的赫夫曼编码，如下表: `=01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011`
    2. 使用赫夫曼编码来生成赫夫曼编码数据，即按照上面的赫夫曼编码，将`“i like like like java do you like a java”`字符串生成对应的编码数据

## 数据解压 (解码)

1. 使用赫夫曼编码来解码数据
2. 使用赫夫曼编码进行解码，又重新得到原来的字符串

## 文件压缩

思路: 读取文件 → 得到赫夫曼编码表 → 完成压缩

## 文件解压

读取压缩文件 (数据和赫夫曼编码表) → 完成解压 (文件恢复)