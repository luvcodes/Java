# 临近矩阵

在数据结构中，图（Graph）是由顶点集合（Vertices）和边集合（Edges）组成的。图可以用多种方式表示，其中之一就是“邻接矩阵”（临近矩阵）。

**邻接矩阵**（Adjacency Matrix）是**表示图中顶点间关系的一种二维数组**。如果你有n个顶点，那么这个矩阵就是一个n x n的矩阵。

- 对于无向图：如果顶点i和顶点j之间有一条边，则矩阵中的元素\[i\]\[j\]和\[j\]\[i\]的值为1，否则为0。
- 对于有向图：如果从顶点i到顶点j有一条有向边，则矩阵中的元素\[i\]\[j\]的值为1，而\[j\]\[i\]为0，除非另有从j到i的有向边。
- 对于带权图（即边上有权值的图）：矩阵中的值不仅仅是1或0，而是具体的边权值。如果i和j之间没有边，则通常会使用一个特定的值（如无穷大）来代表两点之间没有直接连接。

![[%E6%88%AA%E5%B1%8F2024-01-12_%E4%B8%8A%E5%8D%887.32.09.png]]

**邻接矩阵的一个缺点是它可能会浪费空间**，特别是当图是稀疏的（即只有少数边）时。这种情况下，邻接列表是一种更节省空间的替代方法。

# 邻接表

邻接表（Adjacency List）是用于表示图的另一种常见方法。与邻接矩阵相比，邻接表**只存储有实际连接的边，而不是所有可能的边**。

**邻接表的基本结构**：对于图中的每一个顶点，都有一个与之关联的列表。这个列表中包含了与该顶点直接相连的所有其他顶点。

具体实现方式可以有多种，常见的是：

1. **数组+链表**：图的每个顶点对应数组的一个位置，该位置存储一个链表，链表中的每个节点代表与该顶点直接相连的其他顶点。
2. **数组+动态数组**：图的每个顶点对应数组的一个位置，该位置存储一个动态数组（例如Python中的列表），动态数组中的元素代表与该顶点直接相连的其他顶点。

![[%E6%88%AA%E5%B1%8F2024-01-12_%E4%B8%8A%E5%8D%887.33.43.png]]

**相比邻接矩阵，邻接表通常更为节省空间**（特别是对于稀疏图），且在某些图算法中，基于邻接表的操作也更为高效。但它可能不如邻接矩阵直观，特别是当需要快速判断两个特定顶点之间是否存在边时。

# 快速入门案例

![[%E6%88%AA%E5%B1%8F2024-01-12_%E4%B8%8A%E5%8D%888.24.12.png]]

在带权图中，`edges` 数组确实存储的是图中各条边的实际权值，而不仅仅是用 0 和 1 来表示是否存在边。

在无权图（或者说不带权图）中，通常使用 0 和 1 来表示顶点之间是否相连：0 表示没有边，1 表示有边。这种表示法对于简单的图结构来说足够了。

但在带权图中，边不仅仅表示连接，还包含了额外的信息，即权重（或称为“成本”、“距离”等）。在这种情况下，`edges` 数组中的每个元素会存储一个具体的数值，表示连接两个顶点的边的权重。例如，如果 `edges[i][j]` 的值是 5，那么这表示顶点 i 和顶点 j 之间的边的权重是 5。

这种存储方法使得带权图能够表示更加复杂和丰富的信息，如网络的带宽、道路的长度、航线的费用等。因此，带权图在很多实际应用中非常重要，如最短路径问题、网络流问题等。

是否还有其他方面你想要进一步了解或探讨的？我很乐意帮助你深入理解这些概念。

# 十字链表

![[/Untitled 39.png|Untitled 39.png]]

十字链表是一种用于存储稀疏矩阵的数据结构。它是双向链表的一种扩展，主要用于存储非零元素的位置和值。十字链表的主要特点是它有两个方向的链表：一个按行链接，另一个按列链接。

十字链表的结构如下：

1. **节点结构**：每个节点包含以下部分：
    - 数据域：存储矩阵中的非零元素值。
    - 行指针：指向下一个行节点。
    - 列指针：指向下一个列节点。
    - 行号和列号：表示该非零元素在矩阵中的位置。
2. **头结点**：十字链表有一个头结点数组，其中包含两个部分：
    - 行头结点：指向每一行的第一个非零元素。
    - 列头结点：指向每一列的第一个非零元素。

通过这种结构，我们可以快速地访问矩阵中的任何非零元素，而不需要遍历整个矩阵。此外，十字链表也可以有效地进行矩阵的基本操作，如加法、乘法等。

  

十字链表**主要是为了解决有向图的存储问题**。

在有向图中，每个顶点都有入度和出度。十字链表正是利用这一特点来存储有向图的。在十字链表中，每个节点不仅包含数据信息，还包含指向其后继节点和前驱节点的指针。这样，我们可以从任何一个顶点出发，很容易地找到它的所有后继顶点和前驱顶点。

具体来说，十字链表中的每个节点包含以下部分：

1. 数据域：存储顶点的信息。
2. 出边表头指针：指向该顶点的第一个出边节点。
3. 入边表头指针：指向该顶点的第一个入边节点。

出边节点和入边节点都包含：

1. 尾顶点和头顶点的位置。
2. 指向下一个出边或入边的指针。

通过这种结构，我们可以有效地存储有向图，并进行各种图的操作，如查找某个顶点的所有后继顶点、前驱顶点，计算顶点的入度和出度等。

## 邻接多重表

邻接多重表是一种数据结构，用于表示无向图。它结合了邻接矩阵和邻接表的特点，旨在优化存储空间并提供高效的图操作。

### 基本概念：

1. **节点**：与邻接表相似，邻接多重表中的每个节点都有一个链表。
2. **边**：与邻接表不同，邻接多重表中的每条边在链表中只出现一次。这是因为无向图中的边是双向的，所以只需要存储一次。

### 结构组成：

1. **顶点数组**：存储图中的所有顶点。
2. **边表**：每个顶点都有一个边表，存储与该顶点相邻的所有边。

### 优点：

1. **空间效率**：与邻接矩阵相比，邻接多重表更加空间有效。它只存储实际存在的边，而不是所有可能的边。
2. **操作效率**：与邻接表相比，邻接多重表提供了更高效的边操作，如添加、删除和查找边。

### 缺点：

1. **复杂性**：邻接多重表的结构比邻接表更复杂，可能更难理解和实现。
2. **不适用于有向图**：邻接多重表主要用于无向图。对于有向图，通常使用邻接表或邻接矩阵。

### 示例：

考虑以下无向图：

```Plain
A - B
|   |
D - C
```

邻接多重表的表示为：

```Plain
A -> B, D
B -> A, C
C -> B, D
D -> A, C
```

每个顶点后面的链表表示与该顶点相邻的所有顶点。注意，每条边只出现一次。

总之，邻接多重表是一种特殊的数据结构，用于表示无向图。它结合了邻接矩阵和邻接表的优点，提供了空间和操作效率的优势。

## 边集数组

边集数组（Edge Set Array）是图的一种存储结构。它主要用于存储图中的边的信息。边集数组由两个一维数组组成：一个存储边的起点，另一个存储边的终点。

边集数组既可以用于有向图也可以用于无向图：

1. **有向图**：在有向图中，边集数组中的每一对值（起点和终点）表示一个有向边。例如，如果数组中有一个元素表示从顶点A到顶点B的边，那么这表示有一个从A指向B的有向边。
2. **无向图**：在无向图中，边集数组中的每一对值（起点和终点）表示一个无向边。无向边的起点和终点是没有固定顺序的，所以从顶点A到顶点B的边和从顶点B到顶点A的边是相同的。

总的来说，边集数组既可以用于有向图也可以用于无向图，但在实际应用中，选择使用哪种存储结构通常取决于具体的应用需求和操作的效率。例如，如果经常需要查找某个顶点的所有邻接点，那么邻接表可能是更好的选择。而如果只是需要知道图中是否存在某条边，那么边集数组可能更为合适。