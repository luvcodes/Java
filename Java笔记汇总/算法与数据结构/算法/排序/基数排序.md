# 基本思想

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703650738931-26ea629d-e6ca-4cde-826b-cbdaf6fe2e29.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703650738931-26ea629d-e6ca-4cde-826b-cbdaf6fe2e29.png)

基数排序是对桶排序的扩展，速度很快，但是它是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成`OutOfMemoryError`

# 示例

共有3轮排序。这个轮数有一个规律就是，最大的数字有几位，一般就有几轮排序。

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703654880551-5b8921f9-ec6b-4fb0-acaf-c1538fcdaac1.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703654880551-5b8921f9-ec6b-4fb0-acaf-c1538fcdaac1.png)

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703654900019-81a52683-8d64-441a-b90a-192dd3245a66.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703654900019-81a52683-8d64-441a-b90a-192dd3245a66.png)

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703654917523-5fd7b1f0-f07c-4bf2-963d-07a165f324d1.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703654917523-5fd7b1f0-f07c-4bf2-963d-07a165f324d1.png)

# 代码实现

```Java
import java.util.Arrays;

public class RadixSort {
    public static void main(String[] args) {
        int[] arr = {53, 3, 542, 748, 14, 214};
        radixSort(arr);
    }


    public static void radixSort(int[] arr) {

        // 1. 得到数组中最大的数的位数
        int max = arr[0]; // 假设第一数是最大数
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }

        // 得到最大数是几位数
        int maxLength = (max + "").length(); // max + ""就是max加空串转换成了一个字符串
        int[][] bucket = new int[10][arr.length];
        int[] bucketElementCounts = new int[10];

        for (int i = 0, n = 1; i < maxLength; i++, n*=10) {
            // 针对每个元素的对应位进行排序，第一次是个位，第二次是十位，第三次是百位
            for (int j = 0; j < arr.length; j++) {
                // 去除每个元素的对应位的值
                int digitOfElement = arr[j] / n % 10;
                // 放入到对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }

            // 按照规则，将桶中的数据，放入到原数组
            int index = 0;
            // 遍历每一个桶，并将桶中的数据，放入到原数组
            for (int k = 0; k < bucketElementCounts.length; k++) {
                // 如果桶中有数据，才放入到原数组
                if (bucketElementCounts[k] != 0) {
                    // 循环该桶，也就是第k个桶，也就是第k个一维数组。放入数据
                    for (int l = 0; l < bucketElementCounts[k]; l++) {
                        // 将数据放入到原数组
                        arr[index] = bucket[k][l];
                        index += 1;
                    }
                    // 第i+1轮处理后需要将每个bucketElementCounts[k] = 0
                    // 现在这步就相当于是清理数据，以备填入新的数据
                    bucketElementCounts[k] = 0;
                }
            }

            System.out.println("第" + (i + 1) + "轮 对数字的排序arr = " + Arrays.toString(arr));
        }

    }
}
```

在基数排序中，`bucket` 是一个二维数组，用于临时存储排序过程中的元素。这个数组的每一行代表一个“桶”，用于存储具有相同特定位数值的元素。例如，个位数为 `1` 的所有元素将被存储在同一个桶中。

这个表达式的两个部分 `digitOfElement` 和 `bucketElementCounts[digitOfElement]` 分别表示：

1. `**digitOfElement**`：

- 这是通过 `arr[j] / n % 10` 计算得到的，表示当前元素 `arr[j]` 在正在排序的位（比如个位、十位等）上的值。
- 例如，如果 `arr[j]` 是 `53`，且当前正在对个位进行排序，那么 `digitOfElement` 就是 `3`。
- `digitOfElement` 的值用作二维数组 `bucket` 的第一个索引。这意味着它决定了当前元素应该放入哪个桶中。

1. `**bucketElementCounts[digitOfElement]**`：

- 这是一个计数器数组，用于跟踪每个桶当前已经存储了多少元素。
- 每次将元素放入桶中时，相应桶的计数器就会增加。
- 这个值用作二维数组 `bucket` 中对应桶的第二个索引。这意味着它决定了元素在该桶中的具体位置。

因此，`bucket[digitOfElement][bucketElementCounts[digitOfElement]]` 的含义是：

- 在 `digitOfElement` 指定的桶中，
- 将当前元素 `arr[j]` 放在 `bucketElementCounts[digitOfElement]` 指定的位置上。

这个表达式确保了元素根据其在当前位的值被正确地放入相应的桶中，同时保持了桶内元素的顺序。每次放入一个元素后，相应桶的计数器 `bucketElementCounts[digitOfElement]` 就会增加，以便下一个具有相同位值的元素可以被放在下一个位置上。

# 示例2

基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数进行比较排序。通常来说，基数排序的方法有两种：最高位优先（MSD）和最低位优先（LSD）。这里我们讨论最低位优先的基数排序。

### 基数排序的原理

1. **准备工作**：准备10个桶，对应数字0-9。
2. **排序过程**：从最低位开始，根据每个数字的当前位上的数值，将其放入对应的桶中。然后按顺序从桶中取出，重新排列数字。对于更高位重复此过程。
3. **完成排序**：经过最高位的排序后，数组变得有序。

### 示例

假设有一个数组：`[170, 45, 75, 90, 802, 24, 2, 66]`，我们对其进行基数排序：

1. **排序个位数**：
    - 0桶：170, 90
    - 2桶：802, 2
    - 4桶：24
    - 5桶：45, 75
    - 6桶：66
    - 数组变为：[170, 90, 802, 2, 24, 45, 75, 66]
2. **排序十位数**：
    - 0桶：802, 2
    - 4桶：24, 45
    - 6桶：66
    - 7桶：170, 75
    - 9桶：90
    - 数组变为：[802, 2, 24, 45, 66, 170, 75, 90]
3. **排序百位数**：
    - 0桶：002, 024, 045, 066, 075, 090
    - 1桶：170
    - 8桶：802
    - 数组变为：[2, 24, 45, 66, 75, 90, 170, 802]

### 总结

基数排序适用于整数排序，特别是当数字范围很大，但数字位数不多时。它的优点是稳定且效率较高，但缺点是需要额外的存储空间和对位数的依赖。在实际应用中，基数排序通常用于整数或者某些特定类型的字符串排序。