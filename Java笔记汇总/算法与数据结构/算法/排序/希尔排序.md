图解说明 - [【算法】排序算法之希尔排序 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/122632213)

  

因为发现了简单的插入排序可能存在的问题。

例如数组`arr = {2,3,4,5,6,1}`, 这时需要插入的数是最后一位，1.

那么前面的元素后移的次数明显增多，对效率有影响。

**由此，提出希尔排序**

希尔排序是一种**改进的插入排序**，它是基于插入排序的以下两点性质而提出的：

1. 插入排序对于几乎已经排好序的数据操作效率高，即可以达到线性排序的效率。
2. 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

希尔排序的基本思想是使数组中任意间隔为 `h` 的元素都是有序的。这样的数组被称为 `h` 有序数组。换句话说，在进行排序时，会先使数组变成一个 `h` 有序数组，然后逐渐减小 `h` 的值，直到 `h=1`，也就是普通的插入排序。不过，此时的数组已经是部分排序的了，所以最后一步的插入排序效率较高。

[https://www.bilibili.com/video/BV1Dv4y147ai/?vd_source=638cc86179a132cc986508a1d8c81526](https://www.bilibili.com/video/BV1Dv4y147ai/?vd_source=638cc86179a132cc986508a1d8c81526)

# 交换法实现

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703503725034-ce69cbf4-4d7f-49f0-9fd0-db69525e8044.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703503725034-ce69cbf4-4d7f-49f0-9fd0-db69525e8044.png)

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703503768120-79f156b2-0042-46c0-8838-276f8156a615.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703503768120-79f156b2-0042-46c0-8838-276f8156a615.png)

# 代码中的希尔排序

```Java
public static void main(String[] args) {
	int[] arr = {8,9,1,7,2,3,5,4,6,0};
    shellSort(arr);
}
```

```Java
public static void shellSort(int[] arr) {
    int temp = 0;
    int count = 0;
    // 使用循环处理
    // 希尔排序时，对有序序列在插入时使用采用交换法
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < arr.length; i++) {
            for (int j = i - gap; j >= 0; j -= gap) {
                if (arr[j] > arr[j + gap]) {
                    temp = arr[j];
                    arr[j] = arr[j + gap];
                    arr[j + gap] = temp;
                }
            }
        }
        System.out.println("希尔排序第" + (++count) + "轮 = " + Arrays.toString(arr));
    }
}
```

在这个例子中，数组长度为10。那么处理的第一个操作就是10 / 2 = 5，那么第一轮的gap就是5，i也就是从index为5 (第六个元素)开始向数组的终端遍历，每走一个元素，都需要执行一次j循环，对比这个当前i这个位置的元素与gap为5的左边的元素比较大小，看是否需要交换，如果需要，就第一时间交换了。

### 内层循环的作用

即使在某些情况下，内层循环可能只执行一次迭代就结束，它仍然对排序过程至关重要，因为：

1. **每次迭代都可能执行比较和交换**：在每次迭代中，当前元素（`arr[i]`）都与它之前步长距离的元素（`arr[j]`）进行比较。如果条件满足（即 `arr[j] > arr[j + 步长]`），则发生交换。这些交换是希尔排序中逐步建立部分有序序列的关键步骤。
2. **逐渐覆盖整个数组**：随着外层循环的进行，更多的元素被逐步考虑进来。初始几次迭代可能只涉及到数组的一小部分，但随着 `i` 的增加，越来越多的元素参与比较和交换。

重点就是如果按照实际的数字代入进方法中，会发现，最内层循环每次都是只执行一次，然后就会推出到上一级循环，在最内层循环

### gap = 1的情况

当 `gap = 1` 时，在希尔排序中的操作确实与冒泡排序相似，因为它们都涉及到比较相邻的两个元素。然而，关键的区别在于这两种排序方法中元素移动的方式。

1. **冒泡排序**:

- 在冒泡排序中，如果相邻的两个元素顺序错误（即左边的元素大于右边的元素），我们就交换它们的位置。
- 这个过程在整个数组中重复进行，直到没有更多需要交换的元素为止。
- 每一轮中，最大（或最小，根据排序顺序）的元素会“冒泡”到数组的一端。

1. **希尔排序（**`**gap = 1**`**）**:

- 当 `gap = 1` 时，这实际上是执行了标准的插入排序。在这个过程中，我们会取出一个元素，并将它与它左边的元素进行比较。
- 如果这个元素小于它左边的元素，我们会将它继续向左移动，直到找到它正确的位置。这不是简单的交换，而是一个将元素插入到正确位置的过程。
- 这种方式可能会导致多个元素移动，而不仅仅是两个相邻元素交换位置。

因此，尽管在 `gap = 1` 的希尔排序中操作看起来很像冒泡排序，实际上它是在进行插入排序。这种方法通常比纯粹的冒泡排序更有效率，因为它利用了数组在之前希尔排序阶段中已经部分排序的特性。

# 移动法实现

```Java
public static void shellSort2(int[] arr) {
    // 增量gap，并逐步地缩小增量
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        // 从第gap个元素，逐个对其所在的组进行直接插入排序
        for (int i = gap; i < arr.length; i++) {
            int j = i;
            int temp = arr[j];
            if (arr[j] < arr[j - gap]) {
                while (j - gap >= 0 && temp < arr[j - gap]) {
                    // 移动, j - gap的元素移到j的位置
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                // 当退出while后，就给temp找到插入的位置
                arr[j] = temp;
            }
        }
        // System.out.println(Arrays.toString(arr));
        // System.out.println("gap = " + gap);
    }
}
```

让我更准确地解释一下移位法在 `shellSort2` 中的作用，以及如何区分它和简单的元素交换。

在 `shellSort2` 中，移位法的关键在于它不是单纯地交换两个元素，而是逐步地将元素向右移动，为当前考虑的元素（`temp`）腾出空间，最终将 `temp` 插入到合适的位置。这个过程涉及到多个元素的移动，而不仅仅是两个元素之间的交换。

让我们回顾一下前面的例子 `[3, 5, 1, 7, 4, 2, 8, 6]` 并重点关注 `i = 5`（元素 `2`）的情况来阐明这一点：

### 移位操作的步骤

1. **初始化**:

- `j = i = 5`，`temp = arr[j] = 2`。

1. **第一次比较**:

- 比较 `temp`（2）和 `arr[j - gap]`（即 `arr[1] = 5`）。
- 发现 `2` < `5`，所以需要移动。

1. **移动而非交换**:

- 将 `arr[1]`（5）移动到 `arr[5]` 的位置。现在数组是 `[3, 5, 1, 7, 4, 5, 8, 6]`。
- 这不是 `arr[1]` 和 `arr[5]` 之间的简单交换。相反，我们实际上是将 `5` 向右移动，为 `2` 腾出空间。重点就在这里，其实我个人理解更多的像是移动过去以后，然后再等待后面临时变量放置到之前的`arr[1]`的位置。

1. **更新** `**j**` **并继续**:

- 更新 `j` 为 `j - gap`，即 `1`。
- 因为现在 `j` 指向数组起始附近，所以没有更多元素可以比较。这表明 `temp` 应该放在当前 `j` 的位置。

1. **插入** `**temp**`:

- 将 `temp`（2）插入到 `arr[1]`。现在数组是 `[3, 2, 1, 7, 4, 5, 8, 6]`。

### 总结

在这个过程中，我们并没有直接交换 `arr[5]` 和 `arr[1]` 的值。相反，**我们先是将** `**arr[1]**` **向右移动到** `**arr[5]**` **的位置，然后在** `**arr[1]**` **的位置插入** `**temp**`。这种方法实际上是一连串的移动操作，为 `temp` 找到正确的位置，而不是两个特定元素间的简单交换。