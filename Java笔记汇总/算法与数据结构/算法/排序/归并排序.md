图解说明 - [【算法】排序算法之归并排序 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/124356219)

# 图解

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703637156555-9651bd5d-1b2a-4cb5-9405-8ca675e2a0d5.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703637156555-9651bd5d-1b2a-4cb5-9405-8ca675e2a0d5.png)

归并排序是一种高效的排序算法，它采用了分治法的策略。这种算法将数组分成更小的数组，直到每个小数组只包含一个元素，然后将这些数组合并成一个有序的数组。

[https://www.bilibili.com/video/BV1hs4y1a7aM/?vd_source=638cc86179a132cc986508a1d8c81526](https://www.bilibili.com/video/BV1hs4y1a7aM/?vd_source=638cc86179a132cc986508a1d8c81526)

当归并排序在递归过程中分解并合并了 `{8, 4}` 为 `{4, 8}`，接下来的步骤是回到处理 `{8, 4, 5, 7}` 这个更大子数组的递归层次。在这个层次，函数接下来会处理另一半 `{5, 7}` 的分解和合并。

这个过程的具体步骤是：

1. **递归调用处理** `**{8, 4}**`：当 `mergeSortRecursive` 首次处理 `{8, 4, 5, 7}` 时，它将数组分为两部分 - `{8, 4}` 和 `{5, 7}`。首先对 `{8, 4}` 进行递归排序。
2. **分解** `**{8, 4}**`：在递归调用中，`{8, 4}` 继续被分解为单独的元素 `{8}` 和 `{4}`，然后通过 `merge` 函数合并为 `{4, 8}`。
3. **返回上一递归层次**：一旦 `{8, 4}` 被成功排序和合并为 `{4, 8}`，控制流返回到处理 `{8, 4, 5, 7}` 的递归层次。
4. **开始处理** `**{5, 7}**`：此时，`mergeSortRecursive` 函数继续执行，开始处理 `{5, 7}`。与 `{8, 4}` 相似，这部分同样被分解为 `{5}` 和 `{7}`，然后合并。
5. **合并** `**{4, 8}**` **和** `**{5, 7}**`：完成对 `{5, 7}` 的排序和合并后，`mergeSortRecursive` 函数再次回到处理 `{8, 4, 5, 7}` 的层次，并使用 `merge` 函数将 `{4, 8}` 和 `{5, 7}` 合并成一个有序数组。

这样，控制流按照递归调用的自然顺序，从处理 `{8, 4}` 返回到处理 `{8, 4, 5, 7}` 的层次，然后继续处理 `{5, 7}`。在每个递归层次中，函数会处理当前范围内的数组部分，然后返回到上一层以继续合并过程。

一旦 `{4, 8}` 和 `{5, 7}` 被合并成一个有序数组，归并排序的过程会回到处理整个数组 `{8, 4, 5, 7, 1, 3, 6, 2}` 的最顶层递归调用。在这个层次，程序会以同样的方法处理数组的右侧部分 `{1, 3, 6, 2}`。

以下是处理整个数组的步骤：

1. **处理左半部分** `**{8, 4, 5, 7}**`：这部分先被分割成 `{8, 4}` 和 `{5, 7}`，然后这些小部分分别被排序和合并。最终，它们被合并成一个有序数组 `{4, 5, 7, 8}`。
2. **转到处理右半部分** `**{1, 3, 6, 2}**`：完成左半部分的处理后，归并排序的递归逻辑转到处理右半部分。这部分同样被分割成更小的部分，例如 `{1, 3}` 和 `{6, 2}`，这些部分再被进一步分割、排序和合并。
3. **合并右半部分**：右半部分的小部分经过排序和合并后，最终形成另一个有序数组，例如 `{1, 2, 3, 6}`。
4. **最终合并**：当左半部分 `{4, 5, 7, 8}` 和右半部

# 代码实现

```Java
public class MergeSortMethod1 {
    public static void main(String[] args) {
        int[] array = { 12, 11, 13, 5, 6, 7 };

        System.out.println("原始数组:");
        printArray(array);

        mergeSortArray(array); // 数组排序

        System.out.println("\n排序后的数组:");
        printArray(array);
    }

    // 主要的归并排序函数
    private static void mergeSortArray(int[] arr) {
        if (arr.length <= 1) {
            return;
        }
        mergeSortRecursive(arr, 0, arr.length - 1);
    }

    // 用于递归的归并排序函数
    private static void mergeSortRecursive(int[] arr, int left, int right) {
        if (left < right) {
            // 计算的中点是相对于由 left 到 right 索引定义的数组段的中点，而不一定是整个数组的中点
            // 因为 left 可能不是从数组的第一个元素（索引为 0）开始的。
            int mid = left + (right - left) / 2;
            mergeSortRecursive(arr, left, mid); // 这里重点是right为1的时候 (right - left) / 2结果是0
            mergeSortRecursive(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    // 合并两个子数组的函数
    private static void merge(int[] arr, int left, int mid, int right) {
        int[] temp = new int[right - left + 1]; // 用来存储结果
        int i = left, j = mid + 1, k = 0;

        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++]; // 先把i指向的元素放入数组，再把i指针往后移
            } else {
                temp[k++] = arr[j++]; // 先把j指向的元素放入数组，再把j指针往后移
            }
        }

        while (i <= mid) {
            temp[k++] = arr[i++];
        }

        while (j <= right) {
            temp[k++] = arr[j++];
        }

        System.arraycopy(temp, 0, arr, left, temp.length); // 临时数组元素复制回原始数组相应位置。这里source position是0，所以复制temp中的全部内容
    }

    // 打印数组的辅助函数
    private static void printArray(int[] arr) {
        for (int value : arr) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}
```