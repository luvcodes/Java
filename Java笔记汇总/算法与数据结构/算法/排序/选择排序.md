# 原理

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703368612534-0d9614b4-c130-43f9-a119-928c723a67bf.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1703368612534-0d9614b4-c130-43f9-a119-928c723a67bf.png)

重点在于选定一开始的元素是101，然后一次和34，119，1对比，101 > 1，就把1和101调换位置;

然后再从34开始, 一次与119，101对比;

以此类推，直到整个的序列都是从小到大的

概念上与插入排序唯一相通的部分就是会使用到“未排序”部分和“已排序”部分。选择排序最大的特点就是需要一次又一次地遍历序列，每次只能选出来一个min值，然后最后的结果就是从左往右不断地循环选出来min值。

# 为什么要在第一个元素后面找更小值？

## 包含第一个元素的情况

如果内层循环从 `i` 开始而不是 `i + 1`，那么在每次循环的开始，它会将 `arr[i]` 与自身进行比较。由于任何元素和自身比较总是相等，这种比较是多余的。这不会影响排序的结果，但会使得算法执行了一些无用的操作，从而略微降低效率。

## 不包含第一个元素的情况

当内层循环从 `i + 1` 开始时，它避开了对 `arr[i]` 的无用比较。在这种情况下，我们假设 `arr[i]` 是当前未排序部分的最小值，然后只在剩下的未排序部分中寻找是否存在更小的值。如果找到更小的值，就进行交换；如果没有找到，就说明 `arr[i]` 已经是未排序部分的最小值了，不需要任何操作。