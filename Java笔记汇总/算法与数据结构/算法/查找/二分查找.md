# 有序数组

## 二分查找只针对有序数组

二分查找专门用于在**有序**数组中查找元素。这种方法依赖于数组的有序性来高效地确定搜索范围。二分查找算法每次将搜索范围缩小一半，大幅减少了必须检查的元素数量，因此比顺序查找快得多。

在二分查找中，你比较数组中间元素和目标元素：

- 如果中间元素是目标值，查找成功。
- 如果中间元素小于目标值，在数组的右半部分继续查找。
- 如果中间元素大于目标值，在数组的左半部分继续查找。

这个过程重复进行，直到找到目标值或搜索范围为空。

但是，二分查找无法直接应用于**无序**数组。在无序数组中进行查找通常需要使用顺序查找，即逐个检查每个元素，直到找到目标值或确认数组中没有该元素。对于无序数组，二分查找的假设条件——数组已排序——不成立，因此无法正确运作。

## 思路分析

二分查找是一种在有序数组中查找特定元素的高效算法。它的基本思想是将查找范围分为两半，然后根据中间元素与目标元素的比较结果决定下一步搜索的范围。二分查找的时间复杂度为 O(log n)，比线性搜索快得多。

1. **初始化指针**: 设置两个指针，一个指向数组的起始位置（`low`），另一个指向数组的结束位置（`high`）。
2. **循环条件**: 当 `low` 小于或等于 `high` 时，继续循环。这保证了搜索区间内至少有一个元素。
3. **找到中间位置**: 计算中间位置 `mid = low + (high - low) / 2`。这种计算方式可以防止大数相加时的溢出。
4. **比较中间元素**: 检查中间元素是否是要找的目标元素。

- 如果 `array[mid]` 等于目标值，则找到元素，返回 `mid`。
- 如果 `array[mid]` 小于目标值，则将 `low` 设置为 `mid + 1`。
- 如果 `array[mid]` 大于目标值，则将 `high` 设置为 `mid - 1`。

1. **未找到**: 如果循环结束还没有找到目标元素，则表示数组中不存在该元素，返回 -1 或其他标志值。

## 代码实现 (查找单个数字)

```Java
public class BinarySearchExample {

    // 二分查找方法
    public static int binarySearch(int[] array, int target) {
        int low = 0;
        int high = array.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (array[mid] == target) {
                return mid; // 目标元素找到
            } else if (array[mid] < target) {
                low = mid + 1; // 搜索右半部分
            } else {
                high = mid - 1; // 搜索左半部分
            }
        }

        return -1; // 未找到目标元素
    }

    // 主方法，用于测试二分查找
    public static void main(String[] args) {
        int[] array = {1, 3, 5, 7, 9}; // 已排序的数组

        // 测试不同的目标值
        int[] targets = {3, 7, 8};

        for (int target : targets) {
            int result = binarySearch(array, target);

            if (result != -1) {
                System.out.println("元素 " + target + " 找到在索引: " + result);
            } else {
                System.out.println("元素 " + target + " 在数组中未找到");
            }
        }
    }
}
```

在这个代码中，`binarySearch` 方法实现了标准的二分查找算法。在 `main` 方法中，我们定义了一个已排序的数组 `array`，并测试了几个不同的目标值（3，7，8）。对于每个目标值，我们调用 `binarySearch` 方法，并打印出结果。

- 对于 `3` 和 `7`，我们期望输出它们在数组中的位置。
- 对于 `8`（不在数组中），我们期望输出表明它未在数组中找到的信息。

## 代码实现 (查找多个相同数字)

```Java
import java.util.ArrayList;
import java.util.List;

public class BinarySearchAllInstances {
    public static List<Integer> binarySearchAll(int[] array, int target) {
        List<Integer> resultIndices = new ArrayList<>();
        int index = binarySearch(array, target, 0, array.length - 1);

        if (index != -1) {
            resultIndices.add(index);
            // 查找左侧匹配项
            int leftIndex = index;
            while ((leftIndex = binarySearch(array, target, 0, leftIndex - 1)) != -1) {
                resultIndices.add(leftIndex);
            }

            // 查找右侧匹配项
            int rightIndex = index;
            while ((rightIndex = binarySearch(array, target, rightIndex + 1, array.length - 1)) != -1) {
                resultIndices.add(rightIndex);
            }
        }

        return resultIndices;
    }

    private static int binarySearch(int[] array, int target, int low, int high) {
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (array[mid] == target) {
                return mid;
            } else if (array[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] array = {1, 3, 3, 3, 5, 7, 9, 9};
        int target = 3;
        List<Integer> resultIndices = binarySearchAll(array, target);

        if (!resultIndices.isEmpty()) {
            System.out.println("元素 " + target + " 找到在索引: " + resultIndices);
        } else {
            System.out.println("元素 " + target + " 在数组中未找到");
        }
    }
}
```