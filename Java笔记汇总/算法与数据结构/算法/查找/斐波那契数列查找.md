# 原理

[https://blog.csdn.net/X_T_S/article/details/109864988](https://blog.csdn.net/X_T_S/article/details/109864988)

假设我们有一个已经排序的数组，我们要在这个数组中查找特定的元素。例如，考虑这个数组：`[2, 3, 5, 8, 10, 12, 15, 18, 21, 24]`，数组的长度是10。现在假设我们要在这个数组中查找元素 `15`。

1. **生成斐波那契数列**：首先，我们生成一个斐波那契数列 `[0, 1, 1, 2, 3, 5, 8, 13, 21, ...]`，直到数列中的数值大于或等于数组的长度。在这个例子中，数组长度是10，所以我们需要一个大于或等于10的斐波那契数。在数列中，`13` 是第一个大于10的数。
2. **扩展数组**：因为我们选取的斐波那契数（13）大于数组长度（10），我们需要将数组扩展到长度13。可以通过复制数组的最后一个元素（这里是24）来实现：`[2, 3, 5, 8, 10, 12, 15, 18, 21, 24, 24, 24, 24]`。
3. **应用斐波那契规则进行查找**：

- 斐波那契数列中13前面的两个数是8和5。所以我们首先比较数组中索引为8（斐波那契数8的位置）的元素（这里是21）与目标值15。
- 由于15小于21，我们知道目标值必须在索引0到8之间的数组部分。现在我们的搜索范围缩小到数组的前8个元素。
- 接着，在新的范围内，我们再次使用斐波那契数来确定分割点。现在我们的斐波那契数是8和5，所以我们看索引5的元素（这里是12）。
- 15大于12，所以我们知道目标值在索引5到8之间。现在我们的搜索范围进一步缩小。
- 这个过程重复进行，每次都根据斐波那契数列来调整搜索范围，直到找到目标值或者确定它不在数组中。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1704069952561-a1e15037-ee21-4fba-a8f1-e4b27d83ee4a.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1704069952561-a1e15037-ee21-4fba-a8f1-e4b27d83ee4a.png)

# 举例说明

假设我们有一个数组 `arr = {1, 8, 10, 89, 1000, 1234}`，我们要在这个数组中查找数字 `key = 89`。

1. **初始化：**

- 首先，我们生成一个斐波那契数列。假设我们已经生成了数列，例如 `{1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...}`。

1. **确定斐波那契分割点 k：**

- 我们需要找到一个斐波那契数，**这个数大于或等于数组的长度**。这里，数组 `arr` 的长度是 6，所以我们选择斐波那契数列中的第一个大于等于 6 的数，这个数是 8。因此，`k = 5`。

1. **创建扩展数组：**

- 因为斐波那契数 8 大于数组长度 6，我们需要**扩展数组** `**arr**` **到长度 8**。新数组是 `{1, 8, 10, 89, 1000, 1234, 1234, 1234}`。注意，**扩展部分用数组的最后一个元素填充**。

1. **开始搜索：**

- 初始 `low = 0` 和 `high = 5`

1. **第一次循环：**

- 计算 `mid = low + fib[k - 1] - 1`。这里，`fib[k - 1]` 的值是 5，因此 `mid = 0 + 5 - 1 = 4`。
- **比较** `**arr[mid]**` **与** `**key**`。由于 `arr[4] = 1000`，而 `key = 89`，因此我们知道 `**key**` **在数组的前半部分**。现在，`**high**` **变成** `**mid - 1 = 3**`。
- 更新 `k` 为 `k - 1`，k变成4了。

1. **第二次循环：**

- 再次计算 `mid = low + fib[k - 1] - 1`。现在 `fib[k - 1] = 3`，所以 `mid = 0 + 3 - 1 = 2`。
- 比较 `arr[mid]` 与 `key`。由于 `arr[2] = 10`，而 `key = 89`，因此我们知道 `key` 在数组的后半部分。现在，`low` 变成 `mid + 1 = 3`。
- 更新 `k` 为 `k - 2`（现在 `k = 2`）。

1. **第三次循环：**

- 再次计算 `mid = low + fib[k - 1] - 1`。现在 `fib[k - 1] = 1`，所以 `mid = 3 + 1 - 1 = 3`。
- 比较 `arr[mid]` 与 `key`。由于 `arr[3] = 89`，而 `key = 89`，我们找到了 `key`。

1. **返回结果：**

- `key` 在数组中的索引是 3，这就是搜索的结果。

# 代码实现

```Java
import java.util.Arrays;

public class FibonacciSearch2 {
    private static int maxSize = 20;
    public static void main(String[] args) {
        int[] arr = {1, 8, 10, 89, 1000, 1234};

        System.out.println("index = " + fibSearch(arr, 1));
    }

    // 因为后面mid = low + F(k - 1) - 1, 需要使用斐波那契数列，因此需要先获取一个斐波那契数列
    // 非递归方法获取
    public static int[] fib() {
        int[] fib = new int[maxSize];
        fib[0] = 1;
        fib[1] = 1;
        for (int i = 2; i < 20; i++) {
            fib[i] = fib[i - 1] + fib[i - 2];
        }
        return fib;
    }

    public static int fibSearch(int[] arr, int key) {
        int low = 0;
        int high = arr.length - 1;
        int k = 0; // 表示斐波那契分割点的下标
        int mid = 0;
        int[] fib = fib(); // 获取斐波那契数列
        // 获取到斐波那契分割数组的下标
        while (high > fib[k] - 1) {
            k++;
        }
        // 因为f[k]可能大于数组的长度，因此需要使用Arrays类，构造新的数组，并指向a[]
        // 不足的部分使用0填充
        int[] temp = Arrays.copyOf(arr, fib[k]);
        // 实际上是应该用数组最后的一位数来填充不足的部分
        for (int i = high + 1; i < temp.length; i++) {
            temp[i] = arr[high];
        }

        // 使用while来循环处理，来找到目标数 key
        while (low <= high) {
            mid = low + fib[k - 1] - 1;
            if (key < temp[mid]) { // 向数组的前面查找
                high = mid - 1;
                // 为什么k--？
                k--;
            } else if (key > temp[mid]) { // 向数组的后面查找
                low = mid + 1;
                // 为什么k-2？
                k -= 2;
            } else {
                if (mid <= high) {
                    return mid;
                } else {
                    return high;
                }
            }
        }
        return -1; // 未找到元素
    }
}
```

## 为什么小于查找值小于mid值就是k--

在斐波那契搜索中，将搜索区间分为“大小为 `fib[k - 1]` 的前半区间和大小为 `fib[k - 2]` 的后半区间”，而不是相反（大小为 `fib[k - 2]` 的前半区间和大小为 `fib[k - 1]` 的后半区间），是由斐波那契数列的性质和搜索算法的逻辑决定的。

1. **斐波那契数列的递增性质：**

- 斐波那契数列是一个递增序列，每个数都是前两个数的和。因此，对于任何 `k`，`fib[k - 1]` 总是大于 `fib[k - 2]`。

1. **搜索区间的逻辑：**

- 在斐波那契搜索中，我们使用 `fib[k]` 来近似表示整个搜索区间的大小。然后我们用 `fib[k - 1]` 来定位一个“中点”，这个中点实际上是前半部分区间的末尾。
- 这种划分方式使得前半部分始终大于或等于后半部分。这是因为在斐波那契数列中，每个数（除了最开始的两个数）都至少是前一个数的两倍。

1. **为什么前半部分大于后半部分：**

- 当我们在搜索过程中减少 `k` 的值时，我们实际上是在逐步缩小搜索区间。如果我们先考虑更小的区间（即 `fib[k - 2]`），那么我们可能会错过更大的潜在搜索区域（`fib[k - 1]`）。
- 通过首先考虑 `fib[k - 1]` 作为前半部分，我们确保了搜索过程中不会错过可能包含目标值的较大区域。

总结来说，这种将搜索区间分为“较大的前半区间和较小的后半区间”的方法是基于斐波那契数列的递增性质