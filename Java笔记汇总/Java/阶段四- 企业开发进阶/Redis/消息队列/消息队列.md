# 概念

消息队列是一种用于跨进程或网络异步交换数据的技术。它允许应用程序或服务将消息发送到队列，而不需要直接与接收应用程序进行交互。这些消息存储在队列中，直到被接收方处理。消息队列提供了一种松耦合的通信方式，有利于提高系统的可伸缩性和响应性。

  

**消息队列** 就像是一个邮局，你可以把它想象成一个地方，人们（或电脑程序）可以把他们要发送的消息（或数据）放进去。这些消息会留在那里，直到收件人（或另一个程序）准备好来拿它们。

# Redis中的消息队列

Redis的消息队列是指使用Redis这个内存中的数据结构存储系统来实现消息队列的功能。Redis本身是一个键值对数据库，但它也支持发布/订阅（pub/sub）模式，这使得它可以用作消息队列。在Redis中，生产者可以将消息发布到特定的频道，消费者则订阅这些频道来接收消息。由于Redis的高性能和低延迟特性，它常被用于需要快速响应的消息传递场景。

**Redis的消息队列** 可以想象成一个特别快的电子邮局。Redis是一个电脑程序，它用来快速存储和取回数据。当它被用作消息队列时，就像是在用一个非常快速的方式来发送和接收这些消息。因为Redis很快，所以它特别适合在需要迅速交换信息的情况下使用。

## 特点

1. **快速和高效**：由于Redis是基于内存的，因此消息的发布和接收都非常快速。
2. **支持多种数据结构**：Redis不仅支持简单的字符串，还支持列表、集合、哈希等多种数据结构，使得在消息队列中可以实现更复杂的功能。
3. **可持久化**：尽管Redis是内存中的，但它提供了数据持久化的选项，确保在系统崩溃时不会丢失重要数据。
4. **支持多种编程语言**：Redis有多种编程语言的客户端，方便集成到不同的应用程序中。
5. **简单易用**：Redis的使用相对简单，易于设置和维护。

  

Redis 提供了几种可以被用作消息队列的机制，其中三种比较常见的是：**列表（Lists）、发布/订阅（Pub/Sub）和流（Streams）**。

## **列表（Lists）**

- Redis 列表是简单的字符串列表，按插入顺序排序。
- 可以用作消息队列，通过 `LPUSH` 命令将消息添加到列表的一端，然后消费者可以从另一端使用 `BRPOP` 或 `BLPOP` 命令来移除并获取消息。在 Redis 中，`BRPOP` 和 `BLPOP` 是两个用于从列表中移除并返回元素的命令。它们是 `RPOP` 和 `LPOP` 的阻塞版本，分别用于列表的右端（尾部）和左端（头部）。
- **阻塞操作**：这些命令是阻塞的，意味着如果列表为空，它们会等待，直到有元素可弹出或达到指定的超时时间。这在处理消息队列时非常有用，因为消费者可以等待消息到达而不必持续查询列表。`BRPOP` 和 `BLPOP` 与非阻塞的 `RPOP` 和 `LPOP` 相比，更适用于消息队列场景，因为它们在等待新消息时不会消耗过多资源。
- 这种方式简单易用，但功能较为基础，主要用于简单的任务队列或消息缓冲。

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%884.22.22.png]]

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%884.24.29.png]]

## **发布/订阅（Pub/Sub）**

- 这是一种消息广播机制。
- 发布者（publisher）发送消息到一个频道，而订阅了那个频道的订阅者（subscriber）可以接收到这些消息。
- Pub/Sub 模式适用于实时消息广播和通知，但它不保证消息的持久化或者顺序，一旦消息发布，不在线的订阅者将无法接收到这些消息。

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%884.34.28.png]]

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%884.38.49.png]]

## **流（Streams）**

- Redis 流是一个更复杂、功能更强大的消息队列实现，引入了更多的特性，如消息持久化、消费者群组和消息确认。
- 流可以被视为一个日志文件，其中包含一系列的消息条目。
- 它适用于更复杂的应用场景，如消息队列、事件溯源或者日志记录。

每种类型的消息队列都适用于不同的场景，可以根据具体的应用需求和环境选择适合的机制。

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%886.48.57.png]]

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%886.55.14.png]]

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%886.56.14.png]]

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%886.57.25.png]]

  

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%886.59.32.png]]

### 基于stream的消息队列 - 消费者组

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%887.08.58.png]]

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%887.54.41.png]]

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%887.59.40.png]]

在 Redis 的 Stream 数据结构中，消费者组（Consumer Groups）是一个重要的概念，它允许多个消费者协作处理同一个 Stream 中的消息。这对于构建可伸缩的消息队列系统非常有用，特别是在需要多个消费者共同处理大量消息的情况下。在这种机制中，"Pending List" 是一个关键的部分。

### 消费者组 (Consumer Groups)

1. **概念**:
    - 消费者组允许将 Stream 中的消息**分发给多个消费者**，这些消费者可以是不同的线程、进程或者服务器。
    - 一个消费者组中的多个消费者共享消息流，但每个消息只会被组内的一个消费者处理。
2. **工作方式**:
    - 当一个消息被消费者组内的某个消费者读取时，它会被标记为 "已投递"，但不会从 Stream 中删除。
    - 这允许其他消费者（即使不属于同一个组）也能读取同一个消息，确保消息不会在处理前丢失。
3. **确认机制**:
    - 消费者处理完消息后应该对其进行**确认**。这样，消息就会从 "Pending List" 中移除，表示已经被成功处理。

### Pending List

1. **定义**:
    - "Pending List" 是消费者组内部的一个数据结构，用来跟踪那些已经被消费者**读取但尚未被确认**的消息。
    - **每当消费者从消费者组获取消息时，这些消息就会被加入到 "Pending List"。**
2. **用途**:
    - 它**用于确保消息的可靠处理**。如果一个消费者读取了消息但因崩溃或其他原因未能处理，那么这个消息仍然会留在 "Pending List" 中。
    - 这**允许其他消费者或同一消费者在恢复后重新处理**这些消息。
3. **处理未确认消息**:
    - 消费者组可以检查 "Pending List" 来找出那些长时间未被确认的消息。
    - 这些消息可以被重新投递给消费者组中的任一消费者进行处理，确保所有消息最终都被正确处理。

### 总结

在基于 Stream 的消息队列中，消费者组和 "Pending List" 提供了一种可靠的方式

来处理和监控消息。消费者组允许多个消费者共同处理同一个消息流，而 "Pending List" 确保了消息在被成功处理之前不会丢失。这种机制非常适合于那些需要高度可靠性和可伸缩性的消息处理系统。

- 消费者从 Stream 中读取消息后，消息就被加入到 "Pending List"。
- 如果消费者成功处理消息，它会发送确认，消息就会从 "Pending List" 中移除。
- 如果消费者失败或崩溃，未确认的消息保留在 "Pending List"，可以由其他消费者重新处理。

这种机制提高了消息处理的可靠性，确保即使在出现故障的情况下，消息也不会丢失，并且能够被及时处理。

# 对比总结3种消息队列

![[%E6%88%AA%E5%B1%8F2024-01-16_%E4%B8%8B%E5%8D%888.01.00.png]]