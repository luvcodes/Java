Java中要设置包装类的原因有以下几点：

- **使基本数据类型具有对象的特性**。Java是一门面向对象的语言，所有的类型都是引用类型，只有基本数据类型是值类型。为了使基本数据类型也具有对象的特性，Java提供了包装类。包装类将基本数据类型包装成对象，使其可以使用面向对象的编程思想来进行操作。
- **实现可空类型**。基本数据类型不能为空，而包装类可以为空。这使得包装类可以表示不确定的值，例如未知的数字或字符串。
- **提高代码的兼容性**。Java的早期版本不支持自动装箱和拆箱，需要手动将基本数据类型转换为包装类或将包装类转换为基本数据类型。自动装箱和拆箱的引入使得代码更加简洁和方便，提高了代码的兼容性。

Java中使用包装类的方法如下：

- **创建包装类对象**。可以使用构造方法或静态方法valueOf()来创建包装类对象。例如，可以使用以下代码创建一个Integer对象：

`Integer i = new Integer(10);`

- **使用包装类对象的方法**。包装类对象具有丰富的方法，可以用于对基本数据类型进行操作。例如，可以使用以下代码获取Integer对象的值：

`int value = i.intValue();`

- **拆箱和装箱**。拆箱是将包装类对象转换为基本数据类型，装箱是将基本数据类型转换为包装类对象。在JDK 1.5之前，需要手动进行拆箱和装箱。在JDK 1.5之后，引入了自动装箱和拆箱，使得拆箱和装箱更加简洁和方便。

拆箱和装箱的原理如下：

- **拆箱**。拆箱是将包装类对象转换为基本数据类型。在JDK 1.5之前，需要使用包装类的xxxValue()方法来进行拆箱。例如，可以使用以下代码将Integer对象转换为int类型：

`int value = i.intValue();`

在JDK 1.5之后，可以使用自动拆箱来进行拆箱。自动拆箱是指将包装类对象直接赋值给基本数据类型变量。例如，以下代码将Integer对象直接赋值给int类型变量：

`int value = i;`

- **装箱**。装箱是将基本数据类型转换为包装类对象。在JDK 1.5之前，需要使用包装类的valueOf()方法来进行装箱。例如，可以使用以下代码将int类型转换为Integer对象：

`Integer i = Integer.valueOf(10);`

在JDK 1.5之后，可以使用自动装箱来进行装箱。自动装箱是指将基本数据类型直接赋值给包装类变量。例如，以下代码将int类型直接赋值给Integer变量：

`Integer i = 10;`

在实际开发中，包装类可以用在以下场合：

- **集合**。Java的集合框架中，所有的元素都是引用类型。因此，在将基本数据类型添加到集合中时，需要将其转换为包装类。
- **函数式编程**。Java的函数式编程 API 中，许多函数接受的参数或返回值都是包装类。
- **异常处理**。Java的异常处理中，许多异常的参数都是包装类。

  

## 例子

以下是一个使用包装类的例子：

```Java
public class Example {

    public static void main(String[] args) {
        // 创建一个Integer对象
        Integer i = new Integer(10);

        // 获取Integer对象的值
        int value = i.intValue();

        System.out.println(value); // 10

        // 将Integer对象转换为int类型
        int j = i;

        System.out.println(j); // 10
    }
}
```

这段代码首先创建了一个Integer对象，然后使用intValue()方法获取对象的值。然后，使用自动拆箱将对象转换为int类型。最后，输出结果。

以下是一个使用包装类的另一个例子：

```Java
public class Example {

    public static void main(String[] args) {
        // 创建一个ArrayList对象
        ArrayList<Integer> list = new ArrayList<>();

        // 将基本数据类型添加到集合中
        list.add(10);
        list.add(20);

        // 遍历集合
        for (Integer i : list) {
            System.out.println(i);
        }

        // 输出：
        // 10
        // 20
    }
}
```

这段代码创建了一个ArrayList对象，然后将基本数据类型添加到集合中。然后，使用for循环遍历集合，并输出结果。

### 但是我看上面都是使用的基本数据类型add到了ArrayList中呀？

但是问题就在于，ArrayList要求元素都是引用类型，不能直接添加基本数据类型。

### 解答:

上面这段示例代码中，看似好像把基本数据类型加入到了ArrayList中，但其实，在`add()`的过程中由于jdk 1.5版本后进行类自动装箱。这是因为ArrayList是Java集合框架中的一种列表（List）接口实现类，List接口要求其实现类中的元素都是引用类型。

在Java中，基本数据类型是值类型，而引用类型是对象类型。值类型存储在内存的栈中，而引用类型存储在内存的堆中。

ArrayList在底层使用数组来存储元素，因此元素必须是引用类型才能在数组中存储。如果元素是值类型，则必须将其转换为引用类型才能存储在ArrayList中。

在JDK 1.5之前，Java不支持自动装箱，因此必须手动将基本数据类型转换为包装类才能添加到ArrayList中。在JDK 1.5之后，Java引入了自动装箱，可以将基本数据类型直接赋值给包装类变量。因此，在JDK 1.5之后，可以直接将基本数据类型添加到ArrayList中，但实际上是将基本数据类型自动装箱成包装类对象，然后添加到集合中。

### 那么如果我就是不想使用自动装箱呢？应该怎么实现？

```Java
// 创建一个ArrayList对象
ArrayList<Integer> list = new ArrayList<>();

// 将基本数据类型添加到集合中
list.add(Integer.valueOf(10));
list.add(Integer.valueOf(20));
```

如果不使用自动装箱，则需要使用valueOf()方法来将基本数据类型转换为包装类，然后添加到集合中。

总之，ArrayList只能添加引用类型，基本数据类型需要使用包装类才能添加到集合中。

  

  

## 再看一段包装类的代码

```Java
package CommonClasses_.Wrapper_1;

public class WrapperExercise02 {
    public static void main(String[] args) {
        Integer i = new Integer(1);
        Integer j = new Integer(1);
        System.out.println(i == j); // False

        Integer m = 1; //  底层Integer.valueOf(1) -> 需要看源码
        Integer n = 1; // 底层Integer.valueOf(1) -> 需要看源码
        System.out.println(m == n); // T
        // 所以这里主要是看范围 -128 ~ 127 就是直接返回
        /**
         * 1. 如果i在IntegerCache.low(-128) - IntegerCache.high(127), 就直接从数组返回
         * 2. 如果不在，-128 - 127，就直接new Integer(i)
         * public static Integer valueOf(int i) {
         *  if (i >= IntegerCache.low && i <= IntegerCache.high) {
         *      return IntegerCache.cache[i + (-IntegerCache.low)];
         *  }
         *  return new Integer(i);
         * }
         * */

        Integer m = 128; //  底层Integer.valueOf(1) -> 需要看源码
        Integer n = 128; // 底层Integer.valueOf(1) -> 需要看源码
        System.out.println(m == n); // T
        /**
         * 意思就是说，如果 i 在 IntegerCache.low (-128) 和 IntegerCache.high (127) 之间，
         * 则从缓存中获取Integer对象。
         * 如果 i 超出这个范围，则创建一个新的Integer对象。
         * 128超出了-128到127的范围，所以对于每个赋值都会创建一个新的Integer对象。
         * 因此，m 和 n 会引用内存中的两个不同的Integer对象。
         * */


        // 否则，就new Integer(xx)
        Integer x = 128; // 底层Integer.valueOf(1)
        Integer y = 128; // 底层Integer.valueOf(1)
        System.out.println(x == y); // F
    }
}
```

这里就说明了不同的包装类 在底层规定的范围也是不同的。在上面这个例子中，Integer的规定类型是-128到127，那么当我使用Integer类型来初始化一个变量的时候，赋值128超过了这个范围，那么我在下面使用双等于号来判断地址，它在底层实际上就已经开辟了两块内存空间了，那么在使用双等于号的时候必然得到的就是False

  

## 再看另一个包装类型并且使用`==`方法判断相等的例子

```Java
Integer i11 = 127;
int i12 = 127;
System.out.println(i11 == i12); // 只要有基本数据类型，就是在判断值是否相等

Integer i13 = 128;
int i14 = 128;
System.out.println(i13 == i14); // 只要有基本数据类型，等于就是在判断值是否相等
```

```Java
Integer i9 = 127;
Integer i10 = new Integer(127);
System.out.println(i9 == i10);
```

在这里，`i9` 是由缓存获得的127的实例，因为127是在-128到127的范围内。而 `i10` 是通过`new`关键字明确创建的新对象。因此，`i9` 和 `i10` 引用了两个不同的对象，即使它们的值是相同的。所以，`i9 == i10` 返回 `false`。

```Java
Integer i11 = 127;
int i12 = 127;
System.out.println(i11 == i12);
```

当我们使用`==`运算符比较一个`Integer`对象和一个`int`基本类型时，`Integer`对象会自动拆箱成基本数据类型。因此，上述比较实际上是在比较两个基本数据类型的值，而这两个值都是127，所以它们是相等的。所以，`i11 == i12` 返回 `true`。

```Java
Integer i13 = 128;
int i14 = 128;
System.out.println(i13 == i14);
```

与前面的情况相似，`i13` 会被自动拆箱成基本数据类型，然后与 `i14` 进行比较。因为它们的值都是128，所以它们是相等的。所以，`i13 == i14` 返回 `true`。

综上所述，这段Java代码的输出是：

```Plain
false
true
true
```