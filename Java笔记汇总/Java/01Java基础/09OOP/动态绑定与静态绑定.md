# 动态绑定与静态绑定对比

**静态绑定 (Static Binding)：**

1. 又称为早期绑定或编译时绑定。
2. 在编译时，方法调用与方法体之间的关联就已经确定了。
3. 静态绑定主要涉及到私有、静态和final方法，因为这些方法不能被子类覆盖。
4. 静态绑定使用类型信息进行绑定。这意味着绑定是基于类的，而不是基于对象的。

**动态绑定 (Dynamic Binding)：**

1. 又称为晚期绑定或运行时绑定。
2. 在运行时，基于对象的实际类（而不是引用变量的类型）来决定哪个方法应该被调用。
3. 动态绑定涉及到方法重写，因为子类中的方法在运行时才与父类中的方法进行区分。
4. 动态绑定使用对象来进行绑定。这意味着绑定是基于对象的实际类的，而不是基于引用变量的类型。

```Java
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

public class TestBinding {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.sound();  // 动态绑定，输出 "Dog barks"
    }
}
```

在上述示例中，尽管`myDog`的引用类型是`Animal`，但由于它实际引用的是`Dog`对象，因此`Dog`类中的`sound()`方法被调用，这是动态绑定的一个例子。

总的来说，静态绑定发生在编译时，而动态绑定发生在运行时。静态绑定关注方法或成员的类型，而动态绑定关注对象的实际类。

# 详细说明静态绑定

以下是一个静态绑定的例子：

```Java
class StaticBindingExample {
    static class SuperClass {
        static void print() {
            System.out.println("Print in SuperClass.");
        }
    }

    static class SubClass extends SuperClass {
        static void print() {
            System.out.println("Print in SubClass.");
        }
    }

    public static void main(String[] args) {
        SuperClass obj1 = new SuperClass();
        SuperClass obj2 = new SubClass();

        obj1.print();  // 静态绑定，输出 "Print in SuperClass."
        obj2.print();  // 静态绑定，输出 "Print in SuperClass."
    }
}
```

在上述例子中，我们有一个`SuperClass`和它的子类`SubClass`。两个类都有一个静态方法`print()`。

在`main`方法中，我们创建了两个对象：`obj1`是`SuperClass`的实例，而`obj2`虽然是`SubClass`的实例，但其引用类型是`SuperClass`。

当我们调用`obj1.print()`和`obj2.print()`时，都会调用`SuperClass`中的`print()`方法，而不是`SubClass`中的方法。这是因为静态方法与类相关，而不是与实例相关。因此，这种方法调用是在编译时确定的，这就是静态绑定的一个例子。

需要注意的是，**静态方法不能被重写**，所以当子类有一个与父类相同名称的静态方法时，它不是重写父类的方法，而只是隐藏了它。

### obj2.print()进行输出的时候，是因为subclass继承了superClass，而静态方法是在类加载的时候就执行了，所以先执行的就是Superclass的print方法，是这样子吗？

1. **静态方法与类关联**：静态方法与类（而不是对象）关联。这意味着**静态方法不能被子类重写**。当子类定义了一个与父类相同名称的静态方法时，它不是重写父类的方法，而是隐藏了它。
2. **方法调用与引用类型关联**：当您调用一个静态方法时，实际调用的方法是与引用变量的类型（而不是对象的实际类型）关联的。在我们的例子中，`obj2`的引用类型是`SuperClass`，因此`obj2.print()`调用的是`SuperClass`中的`print()`方法。
3. **类加载与静态方法执行**：当一个类被加载到JVM中时，其静态方法不会被自动执行。只有当您明确调用这些方法时，它们才会执行。在我们的例子中，`SuperClass`和`SubClass`的`print()`方法都不会在类加载时执行。它们只在`main`方法中被明确调用时执行。

所以，`obj2.print()`输出`"Print in SuperClass."`的原因**是因为**`**obj2**`**的引用类型是**`**SuperClass**`，而**不是因为**`**SubClass**`**继承了**`**SuperClass**`**或类加载时的行为**。

# 怎么判断见到什么样的代码是动态绑定，什么样子的是静态绑定呢？

**静态绑定：**

1. **涉及静态方法**：静态方法总是静态绑定的。调用的方法版本是基于引用变量的类型决定的，而不是对象的实际类型。

```Java
class StaticExample {
    static void staticMethod() {
        System.out.println("This is a static method.");
    }
}

public class Test {
    public static void main(String[] args) {
        StaticExample.staticMethod();  // 静态绑定
    }
}
```

1. **涉及私有方法**：私有方法是隐式地`final`的，它们不能在子类中被重写。因此，私有方法总是静态绑定的。

```Java
class PrivateExample {
    private void privateMethod() {
        System.out.println("This is a private method.");
    }

    void callPrivateMethod() {
        privateMethod();  // 静态绑定
    }
}

public class Test {
    public static void main(String[] args) {
        PrivateExample example = new PrivateExample();
        example.callPrivateMethod();
    }
}
```

1. **涉及**`**final**`**方法**：`final`方法不能被重写，所以它们总是静态绑定的。

```Java
class FinalExample {
    final void finalMethod() {
        System.out.println("This is a final method.");
    }
}

public class Test {
    public static void main(String[] args) {
        FinalExample example = new FinalExample();
        example.finalMethod();  // 静态绑定
    }
}
```

1. **涉及构造函数**：构造函数总是静态绑定的，因为它们不能被重写。

```Java
class ConstructorExample {
    ConstructorExample() {
        System.out.println("This is a constructor.");
    }
}

public class Test {
    public static void main(String[] args) {
        ConstructorExample example = new ConstructorExample();  // 静态绑定
    }
}
```

1. **涉及数据成员**：数据成员（变量）的访问总是静态绑定的。

```Java
class DataMemberExample {
    static int staticVar = 10;
    int instanceVar = 20;
}

public class Test {
    public static void main(String[] args) {
        System.out.println(DataMemberExample.staticVar);  // 静态绑定

        DataMemberExample example = new DataMemberExample();
        System.out.println(example.instanceVar);  // 静态绑定
    }
}
```

**动态绑定：**

1. **涉及重写的方法**：如果一个方法在子类中被重写，那么哪个版本的方法被调用将取决于对象的实际类型，而不是引用变量的类型。这是动态绑定的一个关键特点。
2. **使用**`**instanceof**`**关键字**：当您使用`instanceof`关键字检查对象的类型时，这是动态绑定的一个例子，因为检查是基于对象的实际类型进行的。

```Java
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

public class TestBinding {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.sound();  // 动态绑定
    }
}
```

在上述示例中，`sound()`方法是动态绑定的，因为它在子类中被重写，并且被调用的方法版本取决于对象的实际类型。

总的来说，要判断是动态绑定还是静态绑定，您**需要查看涉及的方法和变量，以及它们是否在子类中被重写或隐藏**。