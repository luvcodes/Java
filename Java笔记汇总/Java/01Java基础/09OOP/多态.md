# 多态的定义和前提

**多态**： 是指同一行为，具有多个不同表现形式。

从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。

**前提【重点】**

1. 有继承或者实现关系
2. 方法的重写【意义体现：不重写，无意义】
3. 父类引用指向子类对象【格式体现】

父类类型：指子类对象继承的父类类型，或者实现的父接口类型。

# 多态的好处

使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利。

# 多态的运行特点

一个对象的编译类型和运行类型可以不一致: 等号左边是编译类型，等号右边是运行类型。

调用成员变量时：编译看左边，运行看左边

调用成员方法时：编译看左边，运行看右边

```Java
Fu f = new Zi()；
//编译看左边的父类中有没有name这个属性，没有就报错
//在实际运行的时候，把父类name属性的值打印出来
System.out.println(f.name);
//编译看左边的父类中有没有show这个方法，没有就报错
//在实际运行的时候，运行的是子类中的show方法
f.show();
```

# 向上与向下转型

# 为什么要转型？

**多态的写法就无法访问子类独有功能了。**

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，**不能调用**子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。

回顾基本数据类型转换

- 自动转换: 范围小的赋值给范围大的.自动完成:double d = 5;
- 强制转换: 范围大的赋值给范围小的,强制转换:int i = (int)3.14

  

多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。

[https://juejin.cn/post/6993341672755036173](https://juejin.cn/post/6993341672755036173)

# 向上转型

父类的引用指向子类的对象。向上转型是将子类的对象赋值给父类的引用。这是自动的，并且总是安全的，因为子类对象总是是其父类类型的一个实例。

```Java
父类类型  变量名 = new 子类类型();
如：Animal a = new Cat();
```

总之，**向上转型时不能调用子类特有的成员是因为这样做会破坏类型安全和编译时的类型检查机制**。这是面向对象设计原则中的一部分，旨在确保代码的健壮性和可维护性。如果需要调用子类特有的方法，可以通过向下转型（Downcasting）先将父类引用转型为具体的子类引用，但这需要在运行时进行类型检查以确保类型转换的安全性。

### 案例演示

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，**不能调用**子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。

```Java
abstract class Animal {
    abstract void eat();
}

class Cat extends Animal {
    public void eat() {
        System.out.println("吃鱼");
    }
    public void catchMouse() {
        System.out.println("抓老鼠");
    }
}

class Dog extends Animal {
    public void eat() {
        System.out.println("吃骨头");
    }
    public void watchHouse() {
        System.out.println("看家");
    }
}
```

```Java
public class Test {
    public static void main(String[] args) {
        // 向上转型
        Animal a = new Cat();
        a.eat(); 				// 调用的是 Cat 的 eat

        // 向下转型
        Cat c = (Cat)a;
        c.catchMouse(); 		// 调用的是 Cat 的 catchMouse
    }
}
```

# 向下转型

`子类类型 引用名 =（子类类型）父类引用` 父类类型向子类类型向下转换的过程，这个过程是强制的。

**向下转型 (Downcasting)** 一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。

```Java
子类类型 变量名 = (子类类型) 父类变量名;
如:Aniaml a = new Cat();
   Cat c =(Cat) a;
```

如果尝试向下转型到一个不合适的类型，运行时会抛出 `ClassCastException`。

总的来说，**向上转型**是将子类的引用转换为其父类的引用，这**是自动的**并且**总是安全的**。而向下转型是将父类的引用转换为其子类的引用，这需要手动进行并且可能是不安全的，所以在进行向下转型之前，建议先使用 `instanceof` 进行类型检查。

**属性没有重写之说！属性的值看编译类型**

# 转型的异常

```Java
public class Test {
    public static void main(String[] args) {
        // 向上转型
        Animal a = new Cat();
        a.eat();               // 调用的是 Cat 的 eat

        // 向下转型
        Dog d = (Dog)a;
        d.watchHouse();        // 调用的是 Dog 的 watchHouse 【运行报错】
    }
}
```

这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。

# instanceOf关键字

为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下：

- 变量名 instanceof 数据类型
- 如果变量属于该数据类型或者其子类类型，返回true。
- 如果变量不属于该数据类型或者其子类类型，返回false。

```Java
public class Test {
    public static void main(String[] args) {
        // 向上转型
        Animal a = new Cat();
        a.eat();               // 调用的是 Cat 的 eat

        // 向下转型
        if (a instanceof Cat){
            Cat c = (Cat)a;
            c.catchMouse();        // 调用的是 Cat 的 catchMouse
        } else if (a instanceof Dog){
            Dog d = (Dog)a;
            d.watchHouse();       // 调用的是 Dog 的 watchHouse
        }
    }
}
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707401343849-522597f9-f118-4a0f-a78b-b7201287abe8.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707401343849-522597f9-f118-4a0f-a78b-b7201287abe8.png)

`instanceof` 运算符在 Java 中用于测试一个对象是否为特定类的实例，或者是否是一个实现了特定接口的类的实例，或者是否是一个子类的实例。

- A: 一个类的实例 —— 正确。`instanceof` 可以用来判断一个对象是否是特定类的实例。
- B: 一个实现指定接口的类的实例 —— 正确。`instanceof` 也可以用来判断一个对象是否是实现了特定接口的类的实例。
- C: 全部正确 —— 正确。因为 A 和 B 都是正确的。
- D: 一个子类的实例 —— 正确。`instanceof` 还可以用来判断一个对象是否是特定类的子类的实例。