# 哈希值与哈希值特点

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404315826-3c7f8130-1b9b-43c6-ae3b-1065db088e21.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404315826-3c7f8130-1b9b-43c6-ae3b-1065db088e21.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404326959-56923aee-8623-4252-9700-4270b6ca8eb0.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404326959-56923aee-8623-4252-9700-4270b6ca8eb0.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404352552-e1112d82-5b78-42aa-a6e4-3211529e91c2.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404352552-e1112d82-5b78-42aa-a6e4-3211529e91c2.png)

# HashSet

## HashSet键可以重复吗？

在HashSet中，**元素必须是唯一的，不能有重复**。

与HashMap不同，**HashSet没有键值对**（Key-Value Pair）。它**只存储单一的元素**。你**可以把HashSet看作是只有键（Key）而没有值（Value）的HashMap**。

在HashSet中，元素本身就是唯一标识，而在HashMap中，键（Key）是用来唯一标识值（Value）的。在HashSet中，你**只关心元素是否存在于集合中**，因此**每个元素必须是唯一**的。

## 设计目的

HashSet 的**设计重点在于快速查找元素是否存在**，而**不是按顺序访问元素**。因此，它不提供索引访问，因为索引访问在无序集合中没有实际意义，也无法高效实现。

# 底层数据结构

数组 + 链表 + 红黑树

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404375982-d01e2da7-6818-438d-a1ea-5cdd053c10c8.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404375982-d01e2da7-6818-438d-a1ea-5cdd053c10c8.png)

## HashSet添加元素的过程？

HashSet添加元素的过程可以总结如下：

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404395099-c3aa1b78-d26c-41c8-bf1a-2ea25e83dede.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404395099-c3aa1b78-d26c-41c8-bf1a-2ea25e83dede.png)

1. 通过元素的哈希值经过计算得到该元素在HashSet内部存储结构中的位置，通常是通过取模等方式得到索引位置。
2. 如果该位置上已经有元素存在（发生了哈希冲突），则会调用元素的equals方法进行判重，如果equals方法判断为相等，则不会添加该元素；如果不相等，则会进行链表或红黑树的操作来存储新的元素[3]。
3. 如果该位置上没有元素存在，则直接将新元素存储在该位置上[3]。

总之，HashSet添加元素的过程涉及到计算元素的哈希值、确定存储位置以及处理哈希冲突。这也解释了为什么在重写equals方法时需要重写hashCode方法，以确保相等的对象具有相同的哈希值，从而能够正确地存储和定位。

## HashSet的扩容机制

HashSet 的扩容取决于其内部 HashMap 的初始容量和负载因子。默认情况下，HashMap 的负载因子是 0.75。这意味着一旦 HashSet 中的元素数量达到其容量的 75%，就会发生扩容。举几个具体的例子来说明：

假设 HashSet 的初始容量是 16（这是 HashMap 的默认初始容量），并且使用默认的负载因子 0.75：

1. **初始容量为 16：**

- 扩容阈值 = 初始容量 × 负载因子 = 16 × 0.75 = 12。
- 当 HashSet 中的元素数量增加到 12 时，就会发生第一次扩容。

1. **第一次扩容后，容量变为 32：**

- 扩容阈值 = 新容量 × 负载因子 = 32 × 0.75 = 24。
- 当 HashSet 中的元素数量增加到 24 时，就会发生第二次扩容。

1. **第二次扩容后，容量变为 64：**

- 扩容阈值 = 新容量 × 负载因子 = 64 × 0.75 = 48。
- 当 HashSet 中的元素数量增加到 48 时，就会发生第三次扩容。

这个模式会持续下去，**每次扩容都会使容量翻倍**，新的扩容阈值也随之增加。需要注意的是，实际的扩容时机可能受到哈希碰撞和具体实现的影响，这些例子只是理论上的计算。

## HashSet链表转换成红黑树

在Java 8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD (默认是8)，并且table的大小 >= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)。

**两个条件都需要满足，才会进行树化**，就是把这个链表树化，这个64的意思指的是，table的length超过了64。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404425886-4fec6393-89b9-4c1d-82f2-0632a1c8ee6a.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404425886-4fec6393-89b9-4c1d-82f2-0632a1c8ee6a.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404437243-8d0fc944-44e8-4eac-b4fb-49074e0a1819.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1707404437243-8d0fc944-44e8-4eac-b4fb-49074e0a1819.png)

1. HashSet实际上是HashMap
2. 可以存放null值，但是只能有一个null
3. HashSet不保证元素是有序的，取决于hashCode，再确定索引的结果 (即，不保证存放元素的顺序和取出顺序一致)
4. **不能有重复元素**

# HashSet的相关问题解答

## 为什么存和取的顺序不一样？

`HashSet`在Java中是基于`HashMap`实现的，它不保证元素的存储顺序。这是**因为**`**HashSet**`**主要设计用于快速查找，插入和删除操作，而不是保持元素的顺序**。

1. **哈希码的使用**：`HashSet`使用对象的哈希码来确定对象在内部数据结构中的存储位置。**由于不同对象的哈希码可能不同，这导致它们在**`**HashSet**`**内部的存储位置也不同**。即使是相似的对象，如果它们的哈希码不同，它们也可能被存储在集合中的不同位置。
2. **哈希冲突处理**：当**两个或更多对象有相同的哈希码**（即哈希冲突）时，`HashSet`通过某种**冲突解决机制**（如链表或红黑树）**在同一个哈希位置存储这些对象**。这种处理方式**进一步破坏了元素的原始添加顺序**。
3. **扩容重新哈希**：随着`HashSet`中元素数量的增加，底层的`HashMap`可能需要扩容以保持效率。扩容时，所有现有元素都会被重新哈希到新的存储位置。这个过程可能会改变元素的顺序，使得元素的遍历顺序与添加顺序不同。

如果你需要保持插入顺序，可以使用`LinkedHashSet`，它是`HashSet`的一个子类，内部使用链表来维护元素的插入顺序。`LinkedHashSet`在保持`HashSet`的查找效率的同时，还能确保遍历顺序与元素的添加顺序一致。

因此，`HashSet`的设计重点是提供高效的存储、查找和删除操作，而不是保持元素的添加顺序。如果顺序很重要，应该考虑使用其他类型的集合，如`LinkedHashSet`或`ArrayList`。

## HashSet为什么没有索引？

1. **Set集合的定义**

根据Set的定义,它是一种不允许重复元素的集合。Set的设计初衷就是为了存储互不相同的元素,因此Set中的元素是无序的,不存在通过索引去访问特定元素的需求。

1. **基于HashMap实现**

HashSet的实现是基于HashMap的,HashMap内部使用哈希表存储数据。哈希表的存储机制是通过计算元素的哈希码,将元素插入到对应的存储桶中。这种存储方式决定了元素在内部是无序的,无法通过索引直接访问。

1. **不支持索引操作**

由于HashSet内部元素无序存储,也就无法保证每次遍历时元素的顺序都是一致的。因此,HashSet集合类并不提供任何类似于`get(index)`这样的索引访问操作,这些操作对于Set集合来说是没有意义的。

1. **Set的设计哲学**

Set集合的设计哲学是"集合无序、元素唯一"。引入索引的概念会增加Set的复杂性,也会给人误解,似乎Set中的元素是有序的。这与Set的初衷相违背。

如果确实需要通过索引访问元素,我们可以使用List集合,如ArrayList。List中的元素是有序的,可以通过索引直接访问。而如果只需要无序存储唯一元素,那么HashSet就是更好的选择,因为它的实现更加高效。

总之,HashSet没有索引的设计,正是基于Set作为一种存储唯一元素的无序集合的初衷,保持了Set的简单性和高效性。

## 利用什么机制保证去重的？

通过结合HashCode和 equals() 方法，HashSet 能够有效地识别和排除重复元素，从而维护集合中元素的唯一性。这是 HashSet 实现去重的核心机制。

HashSet 在 Java 中利用了几个关键机制来保证元素的唯一性，从而实现去重：

**避免重复：** 当尝试添加一个新元素时，HashSet 首先计算该元素的哈希码，然后检查是否有具有相同哈希码的元素已经存在。如果存在这样的元素，HashSet 进一步使用 equals() 方法来检查这两个元素是否真的相等。如果是，新元素不会被添加，以此来避免重复。

# 存入自定义类型到HashSet

如果是存入自定义的对象类型到HashSet中，必须要重写equals和HashCode方法。

## 为什么重写equals方法一定要重写hashcode方法？

在Java中，`hashCode()` 和 `equals()` 方法在 `HashSet` 和 `HashMap` 这样的集合类中起着非常重要的作用。当你重写这些集合中元素的 `hashCode()` 方法时，强烈建议也重写 `equals()` 方法，原因如下：

### 保持一致性

根据Java的约定，如果两个对象相等（即 `equals()` 方法返回 `true`），那么它们的 `hashCode()` 方法必须返回相同的整数值。这是因为 `HashSet` 和 `HashMap` 使用 `hashCode()` 值来确定元素的存储位置。如果两个对象相等，但它们的 `hashCode()` 值不同，这将违反 `HashSet` 和 `HashMap` 的基本协议，导致数据结构无法正确地识别对象的存在，从而影响集合的准确性和性能。

### 确保元素唯一性

`HashSet` 和 `HashMap` 都依赖 `hashCode()` 和 `equals()` 方法来确保元素的唯一性。当你向 `HashSet` 添加元素或向 `HashMap` 添加键值对时，它会首先使用 `hashCode()` 方法来查找桶位置。如果在这个位置发现了元素（或键），它会使用 `equals()` 方法来检查待添加的元素（或键）是否真的与现有元素（或键）相等。只有当 `equals()` 方法返回 `false` 时，待添加的元素（或键值对）才会被添加到集合中。如果没有重写 `equals()` 方法，那么即使两个对象逻辑上等同，它们也可能被错误地视为不同的元素，从而违反了集合元素唯一性的预期。

### 避免逻辑错误

不重写 `equals()` 方法而只重写 `hashCode()` 方法可能会导致逻辑上的错误。例如，两个内容相同的对象可能会产生相同的 `hashCode` 值，但如果没有重写 `equals()` 方法，它们在使用 `equals()` 方法比较时仍然会返回 `false`（因为默认的 `equals()` 方法检查的是对象的引用是否相同）。这会导致在使用集合操作时出现意料之外的行为，比如无法正确地查找、删除或检查对象的存在。

# **LinkedHashSet**

## 概念

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710749821296-3e0b6275-3a02-439a-8319-67eddd8de739.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1710749821296-3e0b6275-3a02-439a-8319-67eddd8de739.png)

1. LinkedHashSet是HashSet的子类，底层是一个LinkedHashMap，底层维护了一个hash表和双向链表
2. LinkedHashSet根据元素的hashCode值来决定元素的存储位置，使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的
3. LinkedHashSet**不允许添重复元素**

LinkedHashSet是Java集合框架中的一种集合，它继承自HashSet，底层基于LinkedHashMap实现，具有以下特点和知识点

- LinkedHashSet插入性能略低于HashSet，但在迭代访问Set里的全部元素时有较好的性能[1]。
- 底层是一个LinkedHashMap，维护的链表是一个双向链表[1][2]。
- 元素看起来是以插入顺序保存的，这是因为底层使用链表维护元素的次序[2]。
- LinkedHashSet继承自HashSet，底层使用LinkedHashMap来实现，新增加了一个双向链表来确保迭代有序[5]。

因此，LinkedHashSet通过继承自HashSet并基于LinkedHashMap实现，使用双向链表来维护元素的次序，从而保证了元素的有序性和插入顺序的保存。