# Volatile关键字

理解`volatile`关键字的"立即可见性"特性，有助于明白为何它在多线程环境中是重要的。在我提供的例子中：

```Java
public class SharedObject {
    private volatile boolean flag = false;

    public void setFlag(boolean value) {
        flag = value;
    }

    public boolean isFlagSet() {
        return flag;
    }
}
```

这里的`flag`变量被声明为`volatile`。这意味着，无论何时一个线程改变了`flag`的值，这个改变对于其他所有线程来说是立即可见的。这里的“立即可见”指的是内存可见性，确保所有线程都看到相同的值，而不是某些线程看到旧值，某些线程看到新值。

### 如何体现“立即可见”？

- 假设有两个线程，线程A和线程B，都访问同一个`SharedObject`实例。
- 线程A调用`setFlag(true)`方法，将`flag`的值设置为`true`。
- 由于`flag`是`volatile`的，一旦线程A更新了`flag`的值，这个新值会立即被写入主内存（main memory）。
- 然后，当线程B去访问`flag`值时（通过调用`isFlagSet()`方法），它会从主内存中读取`flag`的值，而不是从线程B自己的缓存（线程的本地内存副本）中读取。
- 这就保证了线程B读到的是`flag`的最新值，即线程A刚刚设置的`true`。

### 没有`volatile`的情况

如果`flag`不是`volatile`的，情况可能就完全不同了：

- 线程A更新了`flag`的值后，这个新值可能会停留在线程A的本地内存（缓存）中，并不会立即写入主内存。
- 同时，线程B可能会从它自己的本地内存读取`flag`的值，这可能是一个旧值。
- 这样，线程B就无法立即看到线程A对`flag`所做的更改，导致线程之间的数据不一致。

### 总结

通过使用`volatile`关键字，可以保证一个线程对共享变量的修改对其他所有线程都是立即可见的，这有助于确保在并发环境下的数据一致性和可见性。这是`volatile`的关键用途之一，尤其是在你需要读取和写入变量，但不需要执行复杂操作（如自增）时。

# 锁的解释

在Java中，`synchronized`锁不是绑定在特定的`synchronized`块或方法上，而是绑定在对象本身上。这个锁通常被称为对象锁或监视器锁。`synchronized`锁是上在对象上的，而不是每个`synchronized`块或方法各自有一个锁。

### 锁的关联对象

- **对于实例方法**：当`synchronized`关键字用于实例方法时，锁是与包含该方法的对象实例关联的。也就是说，每个实例有其自己的锁。
- **对于静态方法**：当`synchronized`用于静态方法时，锁是与该方法所在的类的`Class`对象关联的。
- **对于同步块**：对于`synchronized(this)`块，锁是与包含该块的实例对象关联的。而对于`synchronized(Obj)`形式的同步块，锁是与括号内指定的对象（`Obj`）关联的。

### 如何工作

- **锁的获取和释放**：当线程进入`synchronized`方法或块时，它会自动尝试获取关联对象的锁。如果锁已被其他线程持有，则当前线程会被阻塞直到锁被释放。
- 当线程离开`synchronized`方法或块时，它会自动释放锁。

### 示例说明

假设有两个线程T1和T2，以及两个对象实例Obj1和Obj2，每个对象都有一个`synchronized`方法。

- 如果T1正在Obj1的`synchronized`方法中执行，T2可以同时在Obj2的`synchronized`方法中执行，因为每个对象有自己的锁。
- 但如果T2尝试访问Obj1的另一个`synchronized`方法，它将被阻塞，直到T1完成并释放Obj1的锁。

# 释放锁

下面的操作会释放锁

1. 当前线程的同步方法、同步代码块执行结束。
2. 当前线程在同步代码块、同步方法中遇到break、return。
3. 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。
4. 当前线程在同步代码块、同步方法中执行了线程对象的wait方法，档案线程暂停。

下面的操作不会释放锁

1. 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁
2. 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁。suspend()和resume()方法不再推荐使用。

# 可重用锁

可重入锁(Reentrant Lock)指的是同一个线程在外层方法获取锁之后,内层nested方法仍然可以获取该锁的机制。也就是说,线程可以重复获取已持有的锁。

其主要特征包括:

1. 线程可以多次获取同一个锁
2. 必须是同一个线程
3. 每获取一次锁,内部计数加1;每退出一次,计数减1
4. 当计数为0时,表示锁已完全释放。其它线程可以获取该锁

而**synchronized就是一种可重入锁**。当一个线程执行synchronized标记的方法时,执行方法时已经获得了该锁。如果**在synchronized方法中调用本类的其他synchronized方法, 是允许的**。这是因为synchronized是可重入锁。即线程可以再次获取自己已经持有的锁。这是通过计数的方式来实现重入的。

这避免了死锁,也使得synchronized在同一个类中, 多个方法相互调用成为可能。重复获取已持有锁指的是,当一个线程获得了某个锁时, 它可以再次获取这个锁。Java中的重入锁(如synchronized)允许这种重复获取。

```Java
public class Test {
    public synchronized void method1() {
        // 取得锁,然后调用method2
    }
    public synchronized void method2() {
       // 方法2
    }
}
```

**上面这段代码两个同步方法，是两把锁？**

您提到的点非常精准!对于同一个对象的不同synchronized方法, 确实加的不是同一把锁。Java中的每一个对象都与一个可称为"监视器锁"的东西相关联。每一个synchronized函数都与该监视器锁相关联。那么当method1获取锁时,它获得的是该对象监视器的锁。

当其然后调用method2时,由于method2也标记了synchronized,因此它试图再次获取与该对象相关的同一监视器锁。

这是一次对同一锁的获取,所以就是重入场景。您的例子中若method1和method2标记在两个对象中,那么确实是分别获取两个监视器的锁,不属于同一锁的重入。

所以,结论是:**重入必须是同一个对象监视器上同一把锁的再次获取**,这一点您说的非常对!这正是其可重入的前提条件。

### 给予当前线程优先级？

重入锁机制给予了已经获取锁的线程一种“优先级”,使其可以一直重入地获得该锁。

其背后的原理在于锁的持有者只有一个,那就是第一个成功获取的线程。在重入场景下,该线程可以反复获取自己已持有的锁。

这相当于获得了一种优先访问和占有锁的权限。因为:

1. 它不会像其他线程一样被阻塞
2. 它可以缩短或跳过等待队列
3. 它可以持续占有锁定进入重入

所以,没错,可重入锁机制给了原锁占有线程比其他线程更高的锁访问优先权。这使得重入场景成为可能。

当然这种优先级也是有限制的,超出同步范围还是会释放锁。但在同一个synchronize控制流下,的确是一种优先级。