# 生产者和消费者模式

Object类的等待和唤醒方法

|   |   |
|---|---|
|**方法名**|**说明**|
|void wait()|导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法|
|void notify()|唤醒正在等待对象监视器的单个线程|
|void notifyAll()|唤醒正在等待对象监视器的所有线程|

# 等待唤醒机制

生产者和消费者问题是一个经典的并发问题，通常用于说明多线程之间的协作与同步。在这个问题中，有两种角色：生产者和消费者，它们共享一个有限的缓冲区。

**基本概念：**

1. **生产者（Producer）：** 生产者负责向缓冲区生产（产生）数据，并将数据放入缓冲区。
2. **消费者（Consumer）：** 消费者从缓冲区中取出数据并进行消费。

**问题的关键点：**

1. **共享缓冲区：** 生产者和消费者共享一个有限的缓冲区，用于存放生产者产生的数据。
2. **同步问题：** 生产者和消费者需要进行同步，以避免以下问题：

- 缓冲区溢出：当缓冲区满时，生产者需要等待，直到有空间可用。
- 缓冲区空：当缓冲区为空时，消费者需要等待，直到有数据可用。

**等待唤醒机制：**

等待唤醒机制是解决生产者消费者问题的一种常见方法。在Java中，可以使用`wait()`, `notify()`, 和 `notifyAll()`方法来实现等待唤醒机制。

- **wait():** 当线程调用`wait()`方法时，它会释放持有的锁，并进入等待状态，直到其他线程调用相同对象的`notify()`或`notifyAll()`方法来唤醒它。
- **notify():** 当线程调用`notify()`方法时，它会唤醒等待队列中的一个线程，使其进入就绪状态。具体唤醒哪个线程由调度器决定。
- **notifyAll():** 与`notify()`类似，但是会唤醒等待队列中的所有线程。

在生产者消费者问题中，通常会使用两个条件变量，一个用于表示缓冲区非空，另一个用于表示缓冲区非满。生产者在缓冲区非满时生产数据，而消费者在缓冲区非空时消费数据。等待唤醒机制的使用可以确保生产者和消费者之间的协调，避免了竞争条件和死锁的发生。

### 消费者等待

当缓冲区为空时, **消费者**线程需要**等待生产者**往缓冲区添加数据。

具体实现是, 消费者线程会执行wait()方法, 释放锁并进入等待状态。在等待状态下, 该线程不会占用CPU时间, 也不会执行任何操作, 直到被另一个线程调用notify/notifyAll方法唤醒。

### 生产者等待

当缓冲区满时, 生产者线程需要等待消费者从缓冲区消费数据以腾出空间。

实现方式也是调用wait()方法释放锁并进入等待状态, 直到消费者线程消费数据并调用notify/notifyAll唤醒生产者线程。

### 常见方法

生产者和消费者问题通常用wait/notifyAll来实现等待唤醒。生产者生产数据后调用notifyAll, 消费者消费数据后也调用notifyAll来唤醒对方。

1. notify()方法只会随机唤醒一个等待在该对象上的线程, 继续让其执行。
2. notifyAll()会唤醒所有等待在该对象上的线程。

通常来说, 使用notifyAll()要比notify()更安全, 可以防止某些线程无法被唤醒的情况。

# 阻塞队列

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1701316407771-9316072e-ce2b-4a8b-9599-2be8c1393c32.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1701316407771-9316072e-ce2b-4a8b-9599-2be8c1393c32.png)

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708408343125-37527bb2-a4c6-4ad0-811e-daf53a6f917d.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708408343125-37527bb2-a4c6-4ad0-811e-daf53a6f917d.png)

常见BlockingQueue:

- ArrayBlockingQueue: 底层是数组,有界
- LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值

BlockingQueue的核心方法:

- put(anObject): 将参数放入队列,如果放不进去会阻塞
- take(): 取出第一个数据,取不到会阻塞

阻塞队列(BlockingQueue)是一个支持两个附加操作的队列:

1. 在队列为空时,获取元素的线程会等待队列变为非空。
2. 当队列满时,存储元素的线程会等待队列可用。

# 阻塞队列的实现原理

核心思想是通过一个等待池(Wait Pool)来使线程等待,等待池基于锁和条件变量实现。

1. 定义一个共享的阻塞队列,可以是数组或链表等,用于缓冲数据;
2. 队列需要被一个锁保护,以保证互斥访问;
3. 生产者线程放入数据前,必须先获取锁;如果队列已满,不能放入数据,该线程进入等待池wait();
4. 消费者线程取出数据前,必须先获取锁;如果队列为空,不能取出数据,该线程也进入等待池wait();
5. notifyAll() 用来唤醒等待池内的线程;
6. 生产者线程添加完数据后,调用notifyAll()唤醒消费者;
7. 消费者线程消费完数据后,调用notifyAll()唤醒生产者;

这样通过锁保护队列,配合等待池的等待与唤醒,就可以实现一个阻塞队列,使生产者和消费者遵循阻塞队列的访问规则有序地使用队列。

# 阻塞队列代码实现

```Java
    public static void main(String[] args) {
       /*
       *    需求：利用阻塞队列完成生产者和消费者（等待唤醒机制）的代码
       *    细节：生产者和消费者必须使用同一个阻塞队列
       * */

        //1.创建阻塞队列的对象
        ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<>(1);

        //2.创建线程的对象，并把阻塞队列传递过去
        Cook c = new Cook(queue);
        Foodie f = new Foodie(queue);

        //3.开启线程
        c.start();
        f.start();
    }
```

```Java
public class Foodie extends Thread {

    ArrayBlockingQueue<String> queue;

    public Foodie(ArrayBlockingQueue<String> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        while (true) {
            //不断从阻塞队列中获取面条
            try {
                String food = queue.take();
                System.out.println(food);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```Java
public class Cook extends Thread {

    ArrayBlockingQueue<String> queue;

    public Cook(ArrayBlockingQueue<String> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        while (true) {
            //不断的把面条放到阻塞队列当中
            try {
                queue.put("面条");
                System.out.println("厨师放了一碗面条");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```