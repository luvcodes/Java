# Volatile关键字

[https://juejin.cn/post/6844903656274264078](https://juejin.cn/post/6844903656274264078)

volatile通常被比喻成"轻量级的synchronized"，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。

volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。

当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题

1. 堆内存是唯一的，每一个线程都有自己的线程栈。
2. 每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。
3. 在线程中，每一次使用是从变量的副本中获取的。

**Volatile关键字 :** 强制线程每次在使用的时候，都会看一下共享区域最新的值

## 区分volatile和synchronized

1. **volatile（可见）**：

- 想象一下，你有一个告示板（这就是一个变量），很多人（线程）都在看这个告示板。如果你把这个告示板标记为 `volatile`，这就意味着无论何时你更改了告示板上的内容，所有看告示板的人都能立即看到最新的内容。
- `volatile` 的**重点在于“看见”**。它确保当一个人更改了告示板，其他所有人都能看到这个变化。
- 但是，`volatile` 并不能防止多个人同时更改告示板上的内容。如果两个人同时尝试更改告示板，可能会出现混乱。

1. **synchronized（同步）**：

- 现在想象一下，你有一个房间（一段代码），你不希望多个人同时进入这个房间。`synchronized` 就像是一个锁，它确保在某一时刻，只有一个人（线程）可以进入这个房间（执行这段代码）。
- 当一个人进入房间时，门会锁上。其他人必须等待，直到房间里的人离开并且门再次打开。
- `synchronized` 的**关键在于“顺序”和“独占”**。它确保同一时间只有一个人能做某件事（比如更新一个变量），这样就避免了混乱。

简而言之：

- 使用 `volatile` 是为了让每个人都能实时看到告示板上的最新内容，但它不能防止多人同时更改告示板。
- 使用 `synchronized` 是为了确保一次只有一个人能进入房间（执行代码），从而避免同时做同一件事带来的混乱。

在以下两个场景中可以使用volatile来代替synchronized：

1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。

2、变量不需要与其他状态变量共同参与不变约束。

## volatile的意义

`synchronized` 主要是为了确保线程安全，而 `volatile` 的**重点在于保证变量的可见性**。

1. **可见性的重要性**：

- 在多线程环境中，每个线程可能有自己的内存缓存。如果一个线程在不知道其他线程对某个变量的修改的情况下读取这个变量，它可能会得到一个旧值。
- `volatile` 确保当一个线程修改了一个变量时，**这个新值会被立即写入主内存中**，同时确保**其他线程读取这个变量时从主内存中读取，从而得到最新的值**。

1. **使用场景**：

- `volatile` 通常用于那些只由一个线程写入，但可能被多个线程读取的变量。
- 比如，一个标志变量用于指示一个事件是否发生（例如，一个停止线程的信号）。如果这个变量被声明为 `volatile`，那么一旦一个线程更新了这个变量，其他所有线程都会立即知道这个事件已经发生。

1. **性能考量**：

- 相比 `synchronized`，`volatile` 对性能的影响较小，因为它不涉及锁机制。`synchronized` 会阻止多个线程同时访问同一块代码区域，这可能会导致性能下降，特别是在高并发的场景下。
- `volatile` 仅确保数据的可见性，没有额外的线程等待或锁定开销，因此在适当的场景下使用 `volatile` 可以提高程序的性能。

总结来说，`volatile` 的价值在于它提供了一种轻量级的方式来确保变量在多线程环境中的**实时可见性**，这对于编写正确的并发程序是非常关键的。然而，它不适用于那些涉及多个变量或需要原子性操作的场景，这时就需要使用 `synchronized` 或其他更复杂的并发控制机制。

# 原子性

**概述 :** 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。

**代码实现:**

```Java
package com.itheima.threadatom;

public class AtomDemo {
    public static void main(String[] args) {
        MyAtomThread atom = new MyAtomThread();

        for (int i = 0; i < 100; i++) {
            new Thread(atom).start();
        }
    }
}
class MyAtomThread implements Runnable {
    private volatile int count = 0; //送冰淇淋的数量

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            //1,从共享数据中读取数据到本线程栈中.
            //2,修改本线程栈中变量副本的值
            //3,会把本线程栈中变量副本的值赋值给共享数据.
            count++;
            System.out.println("已经送了" + count + "个冰淇淋");
        }
    }
}
```

**代码总结 :** count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断。

`count++`操作实际上不是一个原子操作，它包含三个步骤：读取`count`值、增加1、写回新值。因为这三个步骤不是原子性完成的，在多线程环境中，可能会导致线程之间互相覆盖更新，从而导致`count`变量最终的值小于预期的10000（100个线程*每个线程100次增加）。

## volatile关键字不能保证原子性

解决方案 : 我们可以给`count++`操作添加锁，那么`count++`操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以`count++`就变成了原子操作。

```Java
package com.itheima.threadatom2;

public class AtomDemo {
    public static void main(String[] args) {
        MyAtomThread atom = new MyAtomThread();

        for (int i = 0; i < 100; i++) {
            new Thread(atom).start();
        }
    }
}
class MyAtomThread implements Runnable {
    private volatile int count = 0; //送冰淇淋的数量
    private Object lock = new Object();

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            //1,从共享数据中读取数据到本线程栈中.
            //2,修改本线程栈中变量副本的值
            //3,会把本线程栈中变量副本的值赋值给共享数据.
            synchronized (lock) {
                count++;
                System.out.println("已经送了" + count + "个冰淇淋");
            }
        }
    }
}
```

# 原子性 AtomicInteger

`AtomicInteger`是Java并发包`java.util.concurrent.atomic`中的一个类，它提供了一种在**单个变量**上进行原子操作的方式。

- **原子操作**指的是一种**无法被线程调度机制中断的操作**；一旦开始，就一直运行到完成，中间不会被其他线程打断。

`AtomicInteger`**主要用于多线程环境下的计数器或者序列号生成等场景**，它通过使用底层的非阻塞算法保证了操作的原子性，从而避免了使用锁（`synchronized`）带来的性能开销。

`AtomicInteger`提供了多种方法，包括但不限于：

- `get()`：返回当前的值。
- `set(int newValue)`：设置为给定的值。
- `getAndIncrement()`：原子地将当前值增加1，返回旧值。
- `incrementAndGet()`：原子地将当前值增加1，返回新值。
- `getAndDecrement()`：原子地将当前值减少1，返回旧值。
- `decrementAndGet()`：原子地将当前值减少1，返回新值。
- `addAndGet(int delta)`：原子地将给定的值加到当前值上，返回新值。
- `compareAndSet(int expect, int update)`：如果当前值等于预期值（`expect`），则原子地将该值设置为给定的更新值（`update`），返回是否成功。

`AtomicInteger`内部通过CAS（Compare-And-Swap）操作实现原子性。

- CAS是一种硬件对并发操作共享数据的支持，涉及三个操作数：内存位置（在这里是变量值）、预期原值和新值。
- CAS操作自动检测内存中的值是否与预期原值相等，如果相等，处理器会自动将该位置值更新为新值，否则，操作失败。

使用`AtomicInteger`而不是`int`加锁（使用`synchronized`关键字或`Lock`接口）的好处是，对于简单的原子操作，`AtomicInteger`提供了一种更轻量级和更高效的方式，特别是在高度竞争的环境中，因为它减少了上下文切换和调度延迟。

## AtomicInteger-内存解析

**AtomicInteger原理 :** 自旋锁 + CAS 算法

**CAS算法：**

- 有3个操作数（内存值V， 旧的预期值A，要修改的值B）
- 当旧的预期值A == 内存值 此时修改成功，将V改为B
- 当旧的预期值A！=内存值 此时修改失败，不做任何操作
- 并重新获取现在的最新值（这个重新获取的动作就是自旋）

# 悲观锁和乐观锁

## **synchronized和CAS的区别**

### **相同点**

在多线程情况下，都可以保证共享数据的安全性。

### **不同点**

synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每次操作共享数据之前，都会上锁（悲观锁）

CAS是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。

- 如果别人修改过，那么我再次获取现在最新的值。
- 如果别人没有修改过，那么我现在直接修改共享数据的值 (乐观锁）

## CAS

CAS代表**比较并交换**（Compare-And-Swap），它是一种用于实现多线程同步的原子指令。CAS操作涉及三个操作数：内存位置的当前值（V）、预期原值（A），以及新值（B）。如果内存位置的当前值与预期原值相匹配，那么处理器会自动将该位置更新为新值（B）。这整个过程是原子的，即中间不会被其他线程打断，从而保证了操作的原子性。

### CAS的目的和用途

1. **实现线程安全的数据操作**：在多线程环境中，同步是保证数据一致性和线程安全的关键。CAS提供了一种无锁的同步机制，用于保证对共享变量操作的原子性，避免了使用传统的锁机制（如`synchronized`关键字或`Lock`接口）可能引起的性能问题。
2. **提高并发性能**：相比于传统的锁机制，CAS由于其非阻塞的特性，可以在多核处理器上提供更高的并发性能。使用CAS，线程在执行数据更新操作时不需要挂起等待锁的释放，从而减少了上下文切换和调度延迟，提高了系统的整体吞吐量。
3. **实现原子操作**：CAS是实现原子操作的基础，许多并发工具类（如`java.util.concurrent.atomic`包中的类）底层就是通过CAS来实现的。这些原子类为开发高效且线程安全的并发程序提供了强大的工具。

### CAS的操作流程

- **Step 1**: 读取内存位置的当前值（V）。
- **Step 2**: 检查当前值（V）是否等于预期原值（A）。如果不相等，说明其他线程已经修改了这个值，那么操作失败；如果相等，进入下一步。
- **Step 3**: 将内存位置的值更新为新值（B）。

### CAS的问题

虽然CAS提高了并发性能，但它也有一些缺点，如ABA问题、循环时间长和资源消耗的问题。ABA问题是指如果一个变量原来是A，变成了B，然后又变回A，CAS将无法识别出这个变化。为了解决这个问题，一些CAS操作引入了版本号或时间戳（如原子标记引用`AtomicStampedReference`）。

总之，CAS是一种高效的同步手段，目的是在不使用锁的情况下，通过原子操作保证数据的一致性和线程的安全，从而在多线程环境中实现高效的并发控制。