# 线程生命周期

在 Java 中，线程生命周期可以由以下几个状态来描述，这些状态定义在 `java.lang.Thread.State` 枚举中：

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708427819160-d630bc29-7e38-44d2-bb48-0e81041aa7ac.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1708427819160-d630bc29-7e38-44d2-bb48-0e81041aa7ac.png)

1. **新建（NEW）**:

- 当创建了线程的实例，但是还没有调用 `start()` 方法时，线程处于这个状态。

1. **就绪（RUNNABLE）**:

- 当调用了线程的 `start()` 方法之后，线程进入就绪状态。在这个状态下，线程已经准备好运行，并等待 CPU 的调度。

1. **运行（RUNNING）**:

- 当线程获取到 CPU 时间并执行其 `run()` 方法时，实际上它处于运行状态。就绪（RUNNABLE）和运行（RUNNING）在 `Thread.State` 枚举中是作为同一个状态存在的，因为从操作系统的角度看，它们两者都可以被视为可运行的。

1. **阻塞（BLOCKED）**:

- 当线程试图获取一个锁（比如进入一个同步方法），而该锁被其他线程持有，则线程会进入阻塞状态。

1. **等待（WAITING）**:

- 当线程等待其他线程执行一个特定动作时，比如调用了 `wait()`、`join()` 无超时参数的方法，或者 `LockSupport.park()`，线程将进入等待状态。

1. **超时等待（TIMED_WAITING）**:

- 类似于等待状态，但有最大等待时间的限制。调用 `sleep(long millis)`、`wait(long timeout)`、`join(long millis)`、`LockSupport.parkNanos()`、`LockSupport.parkUntil()` 等方法会让线程进入这个状态。

1. **终止（TERMINATED）**:

- 当线程的 `run()` 方法执行完成，或者线程由于异常结束，它会进入终止状态。

在这些状态中，线程的状态转换通常由 JVM 和线程调度器控制，也可以通过调用特定的方法来引发。例如，`Object.wait()`、`Thread.sleep()`、`Thread.join()` 方法可以导致线程进入等待或超时等待状态；而 `Object.notify()` 或 `Object.notifyAll()` 则可以使等待的线程回到就绪状态。

要注意的是，有些方法，如 `Thread.suspend()`、`Thread.resume()` 和 `Thread.stop()` 已经被弃用，因为它们是不安全的并且可能会导致死锁或者其他线程安全问题。开发者应当避免使用它们，而是采用其他线程控制机制，如使用 `wait()`、`notify()`、`Condition`、`Lock` 等来安全地管理线程的状态。