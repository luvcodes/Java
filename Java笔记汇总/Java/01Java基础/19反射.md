# 1.1 反射的概述

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696115326352-5697d80f-56e9-4f4a-8609-1b5678b6cca7.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696115326352-5697d80f-56e9-4f4a-8609-1b5678b6cca7.png)

**专业的解释（了解一下）：**

是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；

对于任意一个对象，都能够调用它的任意属性和方法；

这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。

**通俗的理解：（掌握）**

- 利用**反射**创建的对象**可以无视修饰符**调用类里面的内容
- 可以跟**配置文件结合起来使用**，把要创建的对象信息和方法写在配置文件中。
    
    读取到什么类，就创建什么类的对象
    
    读取到什么方法，就调用什么方法
    
    此时当需求变更的时候不需要修改代码，只要修改配置文件即可。
    

# 1.2 学习反射到底学什么？

反射都是从class字节码文件中获取的内容。

- 如何获取class字节码文件的对象
- 利用反射如何获取构造方法（创建对象）
- 利用反射如何获取成员变量（赋值，获取值）
- 利用反射如何获取成员方法（运行）

# 1.3 获取字节码文件对象的三种方式

- Class这个类里面的静态方法forName（“全类名”）**（最常用）**
- 通过class属性获取
- 通过对象获取字节码文件对象

```Java
//1.Class这个类里面的静态方法forName
Class clazz1 = Class.forName("com.itheima.reflectdemo.Student");

// 2.通过class属性获取
Class clazz2 = Student.class;
System.out.println(clazz1 == clazz2);//true

// 3.通过Student对象获取字节码文件对象
Student s = new Student();
Class clazz3 = s.getClass();
System.out.println(clazz1 == clazz2);//true
System.out.println(clazz2 == clazz3);//true
```

# 1.4 字节码文件和字节码文件对象

java文件：就是我们自己编写的java代码。

字节码文件：就是通过java文件编译之后的class文件（是在硬盘上真实存在的，用眼睛能看到的）

字节码文件对象：当class文件加载到内存之后，虚拟机自动创建出来的对象。

这个对象里面至少包含了：构造方法，成员变量，成员方法。

而我们的反射获取的是什么？**字节码文件对象**，这个对象**在内存中是唯一**的。

# 1.5 获取构造方法

规则：

get表示获取

Declared表示私有

最后的s表示所有，复数形式

如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用

|   |   |
|---|---|
|**方法名**|**说明**|
|Constructor<?>[] getConstructors()|获得所有的构造（只能public修饰）|
|Constructor<?>[] getDeclaredConstructors()|获得所有的构造（包含private修饰）|
|Constructor<T> getConstructor(Class<?>... parameterTypes)|获取指定构造（只能public修饰）|
|Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)|获取指定构造（包含private修饰）|

# 1.6 获取构造方法并创建对象

涉及到的方法：newInstance

代码示例：

```Java
//测试类中的代码：
//需求1：
//获取空参，并创建对象

//1.获取整体的字节码文件对象
Class clazz = Class.forName("com.itheima.a02reflectdemo1.Student");
//2.获取空参的构造方法
Constructor con = clazz.getConstructor();
//3.利用空参构造方法创建对象
Student stu = (Student) con.newInstance();
System.out.println(stu);
System.out.println("=============================================");


// 测试类中的代码：
// 需求2：
// 获取带参构造，并创建对象
// 1. 获取整体的字节码文件对象
Class clazz = Class.forName("com.itheima.a02reflectdemo1.Student");
// 2. 获取有参构造方法
Constructor con = clazz.getDeclaredConstructor(String.class, int.class);
// 3. 临时修改构造方法的访问权限（暴力反射）
con.setAccessible(true);
// 4. 直接创建对象
Student stu = (Student) con.newInstance("zhangsan", 23);
System.out.println(stu);
```

  

# 1.7 获取成员变量

规则：

- get表示获取
- Declared表示私有
- 最后的s表示所有，复数形式
- 如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用

方法名：

| **方法名**                             | **说明**                    |
| ----------------------------------- | ------------------------- |
| Field[] getFields()                 | 返回所有成员变量对象的数组（只能拿public的） |
| Field[] getDeclaredFields()         | 返回所有成员变量对象的数组，存在就能拿到      |
| Field getField(String name)         | 返回单个成员变量对象（只能拿public的）    |
| Field getDeclaredField(String name) | 返回单个成员变量对象，存在就能拿到         |

  

# 1.8 获取成员变量并获取值和修改值

| **方法**                             | **说明** |
| ---------------------------------- | ------ |
| void set(Object obj, Object value） | 赋值     |
| Object get(Object obj)             | 获取值    |

# 1.9 获取成员方法

规则：

get表示获取

Declared表示私有

最后的s表示所有，复数形式

如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用

| **方法名**                                                           | **说明**                    |
| ----------------------------------------------------------------- | ------------------------- |
| Method[] getMethods()                                             | 返回所有成员方法对象的数组（只能拿public的） |
| Method[] getDeclaredMethods()                                     | 返回所有成员方法对象的数组，存在就能拿到      |
| Method getMethod(String name, Class<?>... parameterTypes)         | 返回单个成员方法对象（只能拿public的）    |
| Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象，存在就能拿到         |

# 1.10 获取成员方法并运行

方法

- Object invoke(Object obj, Object... args) ：运行方法
- 参数一：用obj对象调用该方法
- 参数二：调用方法的传递的参数（如果没有就不写）

返回值：方法的返回值（如果没有就不写）

```Java
  		  //1.获取字节码文件对象
        Class clazz = Class.forName("com.itheima.a02reflectdemo1.Student");
		
        //2.获取一个对象
        //需要用这个对象去调用方法
        Student s = new Student();
        
        //3.获取一个指定的方法
        //参数一：方法名
        //参数二：参数列表，如果没有可以不写
        Method eatMethod = clazz.getMethod("eat",String.class);
        
        //运行
        //参数一：表示方法的调用对象
        //参数二：方法在运行时需要的实际参数
        //注意点：如果方法有返回值，那么需要接收invoke的结果
        //如果方法没有返回值，则不需要接收
        String result = (String) eatMethod.invoke(s, "重庆小面");
        System.out.println(result);
```

## Invoke方法详解

先看一段示例代码:

```Java
public class InvokeMethod {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Class<?> name = Class.forName("com.itheima.practice.Student");
        Method method = name.getDeclaredMethod("eat", String.class);

        // 创建实例运行方法
        Student student = new Student();
        method.setAccessible(true);
        String invoked = (String) method.invoke(student, "汉堡包");
        System.out.println(invoked);
    }
}
```

它演示了如何使用Java反射（Reflection）API来动态地调用一个类的方法。

1. **加载类**: 首先，通过`Class.forName("com.itheima.practice.Student")`动态加载了`com.itheima.practice.Student`这个类。这个方法返回了`Student`类的`Class`对象，这个对象在Java反射中非常重要，因为它代表了正在运行的Java应用程序中的一个类或接口。
2. **获取方法**: 接着，通过调用`getDeclaredMethod("eat", String.class)`方法获取`Student`类中声明的名为`eat`、并且参数类型为`String`的方法。这里的`"eat"`是方法名，`String.class`指定了方法的参数类型，表示这个方法接受一个`String`类型的参数。
3. **创建实例**: 然后，使用`Student student = new Student();`创建了`Student`类的一个实例。这个实例将用于调用`eat`方法。
4. **设置方法可访问性**: 通过`method.setAccessible(true);`将这个方法对象的访问性设置为可访问。在Java中，**如果一个方法是私有的（private），那么在不使用反射的情况下，它不能被类的外部调用**。这一步骤**确保即使是私有方法也能被调用**。
5. **调用方法**: 最后，使用`method.invoke(student, "汉堡包");`调用了`student`实例的`eat`方法，并传入了一个参数`"汉堡包"`。`invoke`方法是`Method`类的一个实例方法，它允许你动态地调用某个对象的方法。
    
    `invoke`方法的第一个参数是要调用方法的对象，后续参数是调用方法时传递给方法的参数。在这个例子中，`invoke`方法返回了`eat`方法的返回值，这个返回值被转换成了`String`类型，并保存在变量`invoked`中。
    

### invoke方法的工作原理

- **动态方法调用**: `invoke`方法的核心作用是实现动态方法调用。这意味着**程序在编译时不需要知道要调用哪个方法，它可以在运行时决定调用哪个方法**。
- **反射机制**: `invoke`方法利用Java的反射机制，允许程序在运行时访问、检查和修改它自己的结构（比如类、接口、字段和方法）。

在使用`invoke`方法进行反射调用时，程序确实是在运行时，根据`invoke`方法提供的参数来确定要调用的具体方法。

在传统的Java程序中，如果你想要调用一个类的方法，你需要在编写代码时就明确指出要调用的方法名称和参数类型。这种调用是静态的，编译器在编译时就会检查方法的存在性和参数的匹配性，如果有错误，编译就会失败。

而通过反射和`invoke`方法调用，则完全不同：

- **动态决定**：直到程序运行到`invoke`方法这一步，它才会根据`invoke`方法的参数（即方法名称和参数类型）动态地决定要调用的确切方法**。这就意味着，你可以根据运行时的条件或者配置来选择调用不同的方法，甚至可以在程序运行时从外部输入或者文件中读取要调用的方法名称和参数。
- **运行时解析**：`invoke`方法在执行时会进行方法解析，检查目标类是否有符合名称和参数类型的方法，然后调用该方法。如果这个过程中出现问题（比如没有找到对应的方法，或者方法访问权限不够），`invoke`会抛出相应的异常。
- **灵活性与风险并存**：这种动态方法调用机制极大增强了Java程序的灵活性，使得可以编写更加通用和动态的代码。但同时，它也带来了风险，因为错误可能只有在程序运行时才会暴露出来，而且反射调用通常比直接调用方法要慢，因为涉及到运行时类型检查和方法查找等额外开销。

# 反射优点和缺点

1. 优点: 可以动态的创建和使用对象，使用灵活，没有反射机制，框架技术就是去底层支撑。
2. 缺点: 使用反射基本是解释执行，对执行速度有影响。

# 反射调用优化 - 关闭访问检查

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696117205087-eaa8655b-856a-4df7-88c5-c1685b0b7946.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696117205087-eaa8655b-856a-4df7-88c5-c1685b0b7946.png)
# 类加载

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696119915468-66b985e3-c33c-478d-ba12-671485dbb79c.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696119915468-66b985e3-c33c-478d-ba12-671485dbb79c.png)
## 静态加载

1. **编译时决定**: 类和方法在编译时就确定了，不能在运行时改变。
2. **类型安全**: 编译器会检查类型，减少运行时错误。
3. **性能**: 通常有更好的性能，因为所有东西都是在编译时解析的。
4. **依赖**: 需要在编译时就有所有依赖的类和方法。
5. **灵活性**: 较低。如果需要改变行为（例如，使用不同的类或方法），需要更改源代码并重新编译。
6. **示例**: `Dog dog = new Dog(); dog.cry();`

## 动态加载

1. **运行时决定**: 类和方法在运行时动态加载，可以在运行时改变。
2. **类型安全**: 缺乏编译时类型检查，增加了运行时错误的风险。
3. **性能**: 通常性能稍差，因为需要在运行时解析类和方法。
4. **依赖**: 可以在运行时添加或更改依赖。
5. **灵活性**: 高。可以不更改源代码而改变行为，例如从配置文件中加载类或方法。
6. **示例**: 
    
    ```Java
    Class cls = Class.forName("Person"); 
    Object o = cls.newInstance(); 
    Method m = cls.getMethod("hi"); 
    m.invoke(o);
    ```
## 应用场景

- **静态加载**: 当你知道在编译时需要什么，并且不需要改变它时，使用静态加载。
- **动态加载**: 当你需要更多的灵活性，或者在运行时决定使用哪个类或方法时，使用动态加载。

## 类加载时机

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696119963647-e95b53be-b585-48dc-975d-34a61ad02eb4.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696119963647-e95b53be-b585-48dc-975d-34a61ad02eb4.png)
## 类加载过程图

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696120007614-6c697058-895f-4d7d-860e-f889ec37bf05.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696120007614-6c697058-895f-4d7d-860e-f889ec37bf05.png)
[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696202753616-3830df77-c460-41be-a790-f9c5ee01fd36.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1696202753616-3830df77-c460-41be-a790-f9c5ee01fd36.png)

