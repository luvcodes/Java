## id生成策略控制

### 不同的表应用不同的id生成策略

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235946543-a7bf698c-0b18-4bbc-a781-37171227507f.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235946543-a7bf698c-0b18-4bbc-a781-37171227507f.png)

这里面所有的TableName和IdType都可以提取出来

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235946611-efd525c2-ff32-40b0-aabd-cfb1a2a44362.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235946611-efd525c2-ff32-40b0-aabd-cfb1a2a44362.png)

转换成全局配置

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235946617-506ddf3f-a79e-4625-844b-9b74fca3558a.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235946617-506ddf3f-a79e-4625-844b-9b74fca3558a.png)

## 多记录操作

### 多数据删除

```Java
@Test
    void testDelete() {
        List<Long> list = new ArrayList<Long>();
        list.add(1721033084409384962L);
        list.add(1721035040897036290L);
//        userDao.deleteById(4L);
        userDao.deleteBatchIds(list);
    }
```

### 逻辑删除

- 删除操作业务问题: 业务数据从数据库中丢弃
- 逻辑删除: 为数据设置是否可用状态字段，删除时设置状态字段为不可用状态，数据保留在数据中

逻辑删除是在数据库管理中的一种做法，它涉及将数据标记为已删除，而不是从数据库中物理删除它。在逻辑删除的做法中，通常会有一个字段用来指示某行数据是否被“删除”。例如，可以有一个名为 is_deleted 或 deleted_at 的字段，当记录不再需要时，这个字段会被设置为 true 或者标记为删除的时间戳，而不是实际上从数据库表中移除那行数据。

逻辑删除的优势包括：

1. **数据恢复：** 如果有数据被误删除，逻辑删除使得恢复数据变得相对简单。
2. **数据完整性：** 保持了数据库的引用完整性，因为即使数据被“删除”，它的外键仍然可以指向有效的记录。
3. **安全和合规：** 某些情况下出于审计或合规要求，需要保留记录的历史。

在实现逻辑删除时，需要在查询数据时总是考虑到这个逻辑删除的字段，确保“删除”的数据不会在应用程序中显示。在一些现代ORM（对象关系映射）工具中，如MyBatis Plus，提供了内置的支持来方便地处理逻辑删除，例如通过自动过滤掉标记为删除的记录。

**逻辑删除案例**

1. 数据库表中添加逻辑删除标记字段

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235946617-f0ffa334-0a7b-4b95-97c5-f7062f498e77.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235946617-f0ffa334-0a7b-4b95-97c5-f7062f498e77.png)

1. 实体类中添加对应字段，并设定当前字段为逻辑删除标记字段

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235946559-1a9a8046-cd09-478b-a584-7eb12ef5e077.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235946559-1a9a8046-cd09-478b-a584-7eb12ef5e077.png)

1. 配置逻辑删除字面值

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235947936-21fcf5b8-6e8a-4ec3-aeff-1f87ad5eecd8.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235947936-21fcf5b8-6e8a-4ec3-aeff-1f87ad5eecd8.png)

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235948061-0d0e126b-16e0-4d3a-9393-42815d03df25.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235948061-0d0e126b-16e0-4d3a-9393-42815d03df25.png)

## 乐观锁

需要进行并发控制的时候

### 乐观锁案例

1. 数据库表中添加锁标记字段

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235948044-a428939f-edd4-4177-8769-ebfb019981e4.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235948044-a428939f-edd4-4177-8769-ebfb019981e4.png)

1. 实体类中添加对应字段，并设定当前字段为逻辑删除字段

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235948200-bc4ad9a5-b9d9-40ff-b30b-84d7edd11cd5.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235948200-bc4ad9a5-b9d9-40ff-b30b-84d7edd11cd5.png)

1. 配置乐观锁拦截器实现锁机制对应的动态SQL语句拼装

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235949460-639cfe05-db73-4155-916b-f8d0c6340a3b.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235949460-639cfe05-db73-4155-916b-f8d0c6340a3b.png)

1. 使用乐观锁机制在修改前必须先获取到对应数据的version就可以执行了

[![](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235949101-fe84c849-88ac-4dc8-8424-3e7dc2f5eca5.png)](https://cdn.nlark.com/yuque/0/2023/png/38953059/1699235949101-fe84c849-88ac-4dc8-8424-3e7dc2f5eca5.png)

这些代码确实实现了乐观锁的概念。下面我会逐段解释：

1. User 类定义了一个实体，并且使用了 **@Version** **注解**。这在MyBatis-Plus中**标识****version****字段作为****乐观锁****的版本号字段**。每当对数据进行更新操作时，MyBatis-Plus会检查这个版本号，并在更新时自动增加版本号。
2. MyBatisPlusConfig 类中创建了一个 MybatisPlusInterceptor 的Bean，它用于添加多个MyBatis拦截器。其中，OptimisticLockerInnerInterceptor 是乐观锁拦截器，**它确保在进行update时应用乐观锁逻辑**，这通常意味着只有当数据库中的版本号与实体类中的版本号相匹配时，更新操作才会成功。
3. testUpdate 方法中展示了如何使用乐观锁。首先，通过ID查询出两个相同的用户记录 user1 和 user2。接着，修改 user2 的名字并调用 updateById 方法尝试更新。如果 user2 的更新成功，数据库中对应记录的版本号将会增加（比如，如果之前是1，现在会变成2）。

然后，尝试同样更新 user1（注意，此时 user1 的版本号还是旧的）。因为数据库中的版本号已经被 user2的操作增加了，user1 的更新将会失败，因为它的版本号不再与数据库中的版本号匹配。这正是乐观锁的工作原理：只有当版本号匹配时，更新操作才会成功，否则会失败，从而避免了并发修改的数据冲突。

**版本号加一的操作？**

在使用MyBatis-Plus框架时，带有 @Version 注解的字段（在您的例子中是 version 字段），在进行更新操作时，**框架会自动处理这个字段的增加**。可以理解成OptimisticLockerInnerInterceptor 乐观锁拦截器来处理+1的任务。

当您调用 userDao.updateById(user) 方法时，如果user对象中包含一个通过 @Version 注解的字段，MyBatis-Plus将生成一个类似下面的SQL更新语句：

```SQL
UPDATE user SET name = 'newName', version = version + 1 WHERE id = ? AND version = ?
```

在这个更新语句中：

- name = 'newName' 是您想要更新的字段。
- version = version + 1 是由MyBatis-Plus自动生成的，用于确保乐观锁的版本控制。
- WHERE id = ? 确保您只更新指定的记录。
- AND version = ? 是乐观锁的关键，它检查当前记录的版本号是否与您尝试更新的记录的版本号相同。如果不相同，更新将失败。

在MyBatis-Plus框架中，OptimisticLockerInnerInterceptor 乐观锁拦截器确保每次在执行带有 @Version 注解的字段的更新操作时，该字段的值会自动加1。这个操作是自动发生的，确保每次数据库记录被成功更新时，对应的版本号都会递增，这样来避免并发问题。

### 详细讲解

乐观锁（Optimistic Locking）是一种在数据库管理系统中处理并发问题的技术。与悲观锁不同，它的基本假设是冲突发生的概率较低，因此在数据访问时不会立即锁定资源。乐观锁通常通过数据版本控制来实现，例如，给记录添加一个时间戳或版本号。

在**更新或删除操作发生**时，系统会检查**数据**在读取和操作**期间**是否**被其他事务**修改：

- 如果数据**未被修改**，操作会成功，并且**版本号会增加**。
- 如果数据在此期间已**被其他事务修改**（即版本号不一致），**操作将会失败**，通常会抛出一个并发异常。

乐观锁适用于并发冲突较少的场景，因为它避免了频繁的锁定和解锁操作，从而在某些情况下可以提供更好的性能。在具有高并发读取和较少写入操作的应用程序中，乐观锁是一种有效的并发控制策略。

**简单示例**

假设有一个用户表，其中有以下列：

- id: 用户的唯一标识
- username: 用户名
- email: 电子邮件地址
- version: 用于实现乐观锁的版本号

现在，你想更新ID为123的用户的电子邮件地址。下面是使用乐观锁的步骤：

1. 从数据库读取用户记录及其版本号。假设当前版本号是5。
2. 显示用户信息给终端用户进行编辑。
3. 当用户完成编辑提交更改时，你的更新操作不仅会尝试更改电子邮件地址，还会检查版本号是否仍然是5。 **"仍然是5"**指的是在您准备更新数据时，数据的版本号应该和您最初读取该数据时的版本号相同，即版本号没有发生变化。这意味着没有其他操作修改过这条记录。 如果在您编辑期间有其他人也在编辑同一条记录，并且他们先于您提交了更改，那么他们的操作将会导致版本号发生变化。
4. 如果版本号是5，更新操作会成功，并且版本号增加到6。
5. 如果版本号不是5，表示其他人已经更新了这条记录，你的操作会失败。

在SQL语句中，这可能看起来像这样：

```SQL
UPDATE users
SET email = 'newemail@example.com', version = version + 1
WHERE id = 123 AND version = 5;
```

如果这个UPDATE操作影响的行数是0（意味着没有记录满足id=123和version=5的条件），则表示有冲突发生，乐观锁阻止了更新。此时，应用程序通常会通知用户冲突的发生，并可能会重新读取最新的数据，让用户决定如何操作。