1. **全局锁**：

- **全局读锁（FLUSH TABLES WITH READ LOCK）**：这种锁影响整个系统，当它被激活时，不允许其他会话进行写操作，但读取仍然可以进行。它主要用于备份数据库等场景。

1. **表锁**：

- **读锁（READ LOCK）**：允许其他事务进行读取，但不允许写入。
- **写锁（WRITE LOCK）**：不允许其他事务进行读取和写入。

1. **行锁**：行锁是最小的锁定粒度，只锁定被访问的数据行。InnoDB 存储引擎使用了行级锁。
2. **意向锁**：InnoDB 存储引擎使用意向锁来表示事务稍后要请求的锁的类型（行锁或表锁）。意向锁是表级锁，但它们并不冲突。例如，一个事务可以持有表的意向共享锁，同时持有该表中某些行的共享锁。
3. **记录锁**：锁定满足某条件的行。例如，通过某个索引检索数据时，会锁定检索到的索引条目。
4. **Gap锁**：Gap 锁不锁定记录，而是锁定索引之间的间隙。这是为了防止其他事务在该范围内插入新的记录。
5. **Next-Key锁**：Next-Key 锁是记录锁和 Gap 锁的组合。这意味着它会锁定一个索引记录，同时还锁定该记录之前的间隙。
6. **自增锁**：当执行 INSERT 操作时，InnoDB 存储引擎使用自增锁确保自增 ID 的连续性。
7. **元数据锁（MDL锁）**：当访问（或更改）表结构时，MySQL 会使用元数据锁。这确保在一个会话更改表结构的同时，其他会话不能对该表进行操作。

锁的实现和行为可能会根据存储引擎的不同而有所不同。例如，InnoDB 和 MyISAM 就有不同的锁策略和实现。通常，InnoDB 由于其行锁特性而更适合于并发写入的环境，而 MyISAM 由于表锁可能更适合读密集型的应用。