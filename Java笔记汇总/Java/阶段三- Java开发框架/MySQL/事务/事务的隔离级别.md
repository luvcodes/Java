# **读未提交**: read uncommitted

- 事务A可以读取到事务B未提交的数据
- **脏读**现象
- 这种隔离级别一般都是理论上的

# **读已提交**: read committed

- 事务A只能读取到事务B提交之后的数据
- 这种隔离级别**解决了脏读**的现象
- 存在什么问题？
- 不可重复读取数据
- 在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是4条，3不等于4称为不可重复读取。也就是说每一次读到的数据不一样
- 这种隔离级别是比较真实的数据

# **可重复读**: repeatable read

- 什么是可重复读取？
- 事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且事务B提交了，事务A读取到的数据还是而没有发生改变，这就是可重复读，如果想要查到事务B新提交的数据，事务A需要commit之后才可以访问到。
- 解决了不可重复读取数据的问题
- 可能会出现**幻读**。每一次读取到的数据都是幻象，不够真实。
- 早晨9点开启事务，到晚上9点，读到的数据还是那样，读到的是假象，不够真实
- **MySQL中默认的事务隔离级别**就是这个

# **序列化读**/串行化: serializable

- 最高隔离级别
- 表示事务排队，不能并发。就是相当于比如事务A开启事务，向表中添加一条数据。再在事务B中开启事务，想要读取表中的数据，是会卡在命令上的。就是因为事务A必须要commit，事务B就能不需要commit直接读出表中的数据了。
- synchronized，线程同步 (事务同步)
- 每一次读取到的数据都是最真实的，并且效率是最低的