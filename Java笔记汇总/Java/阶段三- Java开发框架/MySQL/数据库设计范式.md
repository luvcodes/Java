按照以上范式进行，可以避免表中数据的冗余，节省空间

# 第一范式

**任何一张表必须有主键，每一个字段原子性不可再分**

最核心，最重要的范式，所有表的设计都需要满足。

第一范式要求数据表中的每一列都是原子值，不能再分解。也就是说，表中的每一列都只能包含一个值，不能包含多个值。

例如，如果我们有一个表来存储员工信息，其中有一个列是“地址”，那么这个列就不能包含“北京市海淀区中关村”这样一个值，而是应该拆分为“省份”、“城市”、“区/县”三个列。

# 第二范式

**建立在第一范式的基础上，要求所有非主键字段完全依赖主键，不要产生部分依赖**

第二范式要求数据表中的每一列都直接依赖于主键。也就是说，表中的每一列都应该完全由主键决定，不能只由主键的一部分决定。

例如，如果我们有一个表来存储订单信息，其中有一个列是“商品名称”，那么这个列就不能完全由“订单编号”决定，还应该由“商品编号”决定。

以下是一个使用联合主键，并且同时证明第二范式的表：

**SQL**

```SQL
CREATE TABLE products (
  product_id INT NOT NULL,
  product_name VARCHAR(255) NOT NULL,
  product_price DECIMAL(10,2) NOT NULL,
  PRIMARY KEY (product_id, product_name)
);
```

该表使用联合主键 `product_id` 和 `product_name` 来唯一标识一个产品。 `product_id` 和 `product_name` 都完全依赖于联合主键，它们是联合主键的附加信息。因此，该表满足第二范式。

以下是一个不满足第二范式的表，使用联合主键：

**SQL**

```SQL
CREATE TABLE products (
  product_id INT NOT NULL,
  product_name VARCHAR(255) NOT NULL,
  product_price DECIMAL(10,2) NOT NULL,
  product_category VARCHAR(255)
);
```

该表使用联合主键 `product_id` 和 `product_name` 来唯一标识一个产品。 `product_category` 不是完全依赖于联合主键的。 `product_category` 是与联合主键相关联的，但它并不完全依赖于联合主键。例如，如果一个产品的 `product_id` 和 `product_name` 没有改变，但它的类别改变了，那么 `product_category` 将会改变。

要使该表满足第二范式，需要将 `product_category` 从该表中分离出来，创建一个新的表 `categories`：

**SQL**

```SQL
CREATE TABLE categories (
  category_id INT NOT NULL,
  category_name VARCHAR(255) NOT NULL,
  PRIMARY KEY (category_id)
);

CREATE TABLE products (
  product_id INT NOT NULL,
  product_name VARCHAR(255) NOT NULL,
  product_price DECIMAL(10,2) NOT NULL,
  category_id INT NOT NULL,
  FOREIGN KEY (category_id) REFERENCES categories (category_id)
);
```

在新的表 `categories` 中，`category_name` 完全依赖于主键 `category_id`。这样，该表就满足了第二范式。

### product_category为什么不是完全依赖于联合主键的呢？

`product_category` 不是完全依赖于联合主键的，因为它只依赖于联合主键的一部分。如果 `product_id` 不变，但是 `product_name` 改变了，那么 `product_category` 仍然会保持不变。

在第二范式中，一个属性必须完全依赖于主键，也就是说，属性的值必须由主键的值完全决定。在本例中，`product_category` 的值并不由联合主键的值完全决定。因此，`product_category` 不是完全依赖于联合主键的。

为了使 `product_category` 完全依赖于联合主键，可以将 `product_category` 从表 `products` 中分离出来，创建一个新的表 `categories`，并将 `product_category` 作为 `categories` 的主键。这样，`product_category` 的值将完全由 `category_id` 决定，`product_category` 就完全依赖于主键了。

# 第三范式

**建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖**

第三范式要求数据表中的每一列都不能依赖于其他非主键列。也就是说，表中的每一列都应该直接依赖于主键，不能间接依赖于主键。

例如，如果我们有一个表来存储订单信息，其中有一个列是“订单总价”，那么这个列就不能依赖于“商品名称”列，而应该直接依赖于“订单编号”列。

# 多对多怎么设计？

- 多对多，三张表，关系表两个外键

# 一对多怎么设计？

- 一对多，两张表，多的表加外键

# 一对一怎么设计？

- 一对一放到一张表不就行了吗？为啥还要拆分表？
- 在实际的开发中，可能存在一张表字段太多，太庞大。这个时候要拆分表。
- 怎么设计？
- 没有拆分表之前: 一张表
- 一对一，外键唯一 (第二张表上添加foreign key + unique)