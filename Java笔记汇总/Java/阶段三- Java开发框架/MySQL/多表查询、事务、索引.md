# 多表查询

## 概述

### 数据准备

```SQL
#建议：创建新的数据库
create database db04;
use db04;

-- 部门表
create table tb_dept
(
  id          int unsigned primary key auto_increment comment '主键ID',
  name        varchar(10) not null unique comment '部门名称',
  create_time datetime    not null comment '创建时间',
  update_time datetime    not null comment '修改时间'
) comment '部门表';
-- 部门表测试
insert into tb_dept (id, name, create_time, update_time)
values (1, '学工部', now(), now()),
       (2, '教研部', now(), now()),
       (3, '咨询部', now(), now()),
       (4, '就业部', now(), now()),
       (5, '人事部', now(), now());

-- 员工表
create table tb_emp
(
  id          int unsigned primary key auto_increment comment 'ID',
  username    varchar(20)      not null unique comment '用户名',
  password    varchar(32) default '123456' comment '密码',
  name        varchar(10)      not null comment '姓名',
  gender      tinyint unsigned not null comment '性别, 说明: 1 男, 2 女',
  image       varchar(300) comment '图像',
  job         tinyint unsigned comment '职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师',
  entrydate   date comment '入职时间',
  dept_id     int unsigned comment '部门ID',
  create_time datetime         not null comment '创建时间',
  update_time datetime         not null comment '修改时间'
) comment '员工表';
-- 员工表测试数据
INSERT INTO tb_emp(id, username, password, name, gender, image, job, entrydate,dept_id, create_time, update_time)
VALUES
(1,'jinyong','123456','金庸',1,'1.jpg',4,'2000-01-01',2,now(),now()),
(2,'zhangwuji','123456','张无忌',1,'2.jpg',2,'2015-01-01',2,now(),now()),
(3,'yangxiao','123456','杨逍',1,'3.jpg',2,'2008-05-01',2,now(),now()),
(4,'weiyixiao','123456','韦一笑',1,'4.jpg',2,'2007-01-01',2,now(),now()),
(5,'changyuchun','123456','常遇春',1,'5.jpg',2,'2012-12-05',2,now(),now()),
(6,'xiaozhao','123456','小昭',2,'6.jpg',3,'2013-09-05',1,now(),now()),
(7,'jixiaofu','123456','纪晓芙',2,'7.jpg',1,'2005-08-01',1,now(),now()),
(8,'zhouzhiruo','123456','周芷若',2,'8.jpg',1,'2014-11-09',1,now(),now()),
(9,'dingminjun','123456','丁敏君',2,'9.jpg',1,'2011-03-11',1,now(),now()),
(10,'zhaomin','123456','赵敏',2,'10.jpg',1,'2013-09-05',1,now(),now()),
(11,'luzhangke','123456','鹿杖客',1,'11.jpg',5,'2007-02-01',3,now(),now()),
(12,'hebiweng','123456','鹤笔翁',1,'12.jpg',5,'2008-08-18',3,now(),now()),
(13,'fangdongbai','123456','方东白',1,'13.jpg',5,'2012-11-01',3,now(),now()),
(14,'zhangsanfeng','123456','张三丰',1,'14.jpg',2,'2002-08-01',2,now(),now()),
(15,'yulianzhou','123456','俞莲舟',1,'15.jpg',2,'2011-05-01',2,now(),now()),
(16,'songyuanqiao','123456','宋远桥',1,'16.jpg',2,'2007-01-01',2,now(),now()),
(17,'chenyouliang','123456','陈友谅',1,'17.jpg',NULL,'2015-03-21',NULL,now(),now());
```

### 介绍

多表查询：**查询时从多张表中获取所需数据**

单表查询的SQL语句：select  字段列表  from  表名;

那么要执行多表查询，只需要使用逗号分隔多张表即可，如： select   字段列表  from  表1, 表2;

查询用户表和部门表中的数据：

```SQL
select * from  tb_emp , tb_dept;
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321236-d0a89f59-170c-4573-91ee-5e513c07d138.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321236-d0a89f59-170c-4573-91ee-5e513c07d138.png)

此时,我们看到查询结果中包含了大量的结果集，总共85条记录，而这其实就是**员工表所有的记录(17行)与部门表所有记录(5行)的所有组合情况**，这种现象称之为**笛卡尔积**。

### 笛卡尔积

笛卡尔积：笛卡尔乘积是指在数学中，两个集合(A集合和B集合)的所有组合情况。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321369-a485dcaf-329c-4e07-86cd-2d6ebc6f4c17.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321369-a485dcaf-329c-4e07-86cd-2d6ebc6f4c17.png)

在多表查询时，需要消除无效的笛卡尔积，只保留表关联部分的数据

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321485-b57f624e-75fe-4433-98bc-65c012ceb079.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321485-b57f624e-75fe-4433-98bc-65c012ceb079.png)

在SQL语句中，**如何去除无效的笛卡尔积**呢？只需要**给多表查询加上连接查询的条件**即可。

```SQL
select * from tb_emp , tb_dept where tb_emp.dept_id = tb_dept.id ;
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321609-1e68e2c4-486b-47d2-9100-835ba86e30ec.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321609-1e68e2c4-486b-47d2-9100-835ba86e30ec.png)

由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询到。

## 内连接

内连接查询：查询两表或多表中**交集**部分数据。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321700-7c4f8042-d8de-47c6-89e7-865204a102c6.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321700-7c4f8042-d8de-47c6-89e7-865204a102c6.png)

内连接从语法上可以分为：

- 隐式内连接
- 显式内连接

### 案例

查询员工的姓名及所属的部门名称

```Plain
-- 查询员工的姓名，及所属的部门名称 (隐式内连接实现)
select tb_emp.name, tb_dept.name from tb_emp, tb_dept WHERE tb_emp.dept_id = tb_dept.id;

-- 查询员工的姓名，及所属的部门名称 (显式内连接实现)
select tb_emp.name, tb_dept.name from tb_emp inner join tb_dept on tb_emp.dept_id = tb_dept.id;
```

### 多表查询时给表起别名

- tableA as 别名1 , tableB as 别名2 ;
- tableA 别名1 , tableB 别名2 ;

使用了别名的多表查询：

```SQL
-- 起别名
select e.name, d.name from tb_emp e, tb_dept d where e.dept_id = d.id;
```

注意事项:

一旦为表起了别名，就**不能再使用表名来指定对应的字段**了，此时**只能够使用别名来指定字段**。

## 外连接

外连接分为两种：左外连接 和 右外连接。

### 左外连接语法

```SQL
select  字段列表   from   表1  left  [ outer ]  join 表2  on  连接条件 ... ;
```

左外连接相当于**查询表1(左表)的所有数据**，当然也**包含表1和表2交集**部分的数据。

### 案例

查询员工表中所有员工的姓名, 和对应的部门名称

```SQL
-- 左外连接
select e.name, d.name from tb_emp e left join tb_dept d on e.dept_id = d.id;
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321990-b2344815-e519-4102-a8e8-2cb60204ca6d.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260321990-b2344815-e519-4102-a8e8-2cb60204ca6d.png)

### 右外连接语法

```SQL
select  字段列表   from   表1  right  [ outer ]  join 表2  on  连接条件 ... ;
```

右外连接相当于**查询表2(右表)的所有数据**，当然也**包含表1和表2交集**部分的数据。

### 案例

查询部门表中所有部门的名称, 和对应的员工名称

```SQL
-- 右外连接查询部门表 所有部门的名称和对应的员工名称
select e.name, d.name from tb_emp e right join tb_dept d on e.dept_id = d.id;
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322075-eb9319b5-7438-4a96-bda9-c7fe2dca84e5.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322075-eb9319b5-7438-4a96-bda9-c7fe2dca84e5.png)

这里出现两个null的原因是因为，emp中只使用了dept表中的3个部门，有两个部门是没有对应的emp的。

注意事项：

**左外连接和右外连接是可以相互替换**的，只需要调整连接查询时SQL语句中表的先后顺序就可以了。而我们在日常开发使用时，更**偏向于左外连接**。

## 子查询

### 介绍

**SQL语句中嵌套select语句**，称为嵌套查询，又称**子查询**。

```SQL
SELECT  *  FROM   t1   WHERE  column1 =  ( SELECT  column1  FROM  t2 ... );
```

子查询外部的语句可以是insert / update / delete / select 的任何一个，最常见的是 select。

根据子查询结果的不同分为：

1. 标量子查询（子查询结果为单个值[一行一列]）
2. 列子查询（子查询结果为一列，但可以是多行）
3. 行子查询（子查询结果为一行，但可以是多列）
4. 表子查询（子查询结果为多行多列[相当于子查询结果是一张表]）

子查询可以书写的位置：

1. where之后
2. from之后
3. select之后

### 标量子查询

子查询**返回的结果是单个值** (数字、字符串、日期等)，最简单的形式，这种子查询称为标量子查询。

常用的操作符： =   <>   >    >=    <   <=

案例1：查询"教研部"的所有员工信息

可以将需求分解为两步：

1. 查询 "教研部" 部门ID
2. 根据 "教研部" 部门ID，查询员工信息

```SQL
-- 1.查询"教研部"部门ID
select id from tb_dept where name = '教研部';    #查询结果：2
-- 2.根据"教研部"部门ID, 查询员工信息
select * from tb_emp where dept_id = 2;

-- 合并出上两条SQL语句
select * from tb_emp where dept_id = (select id from tb_dept where name = '教研部');
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322185-1251a5bf-2d3d-4963-abdb-2f679f7aca89.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322185-1251a5bf-2d3d-4963-abdb-2f679f7aca89.png)

案例2：查询在 "方东白" 入职之后的员工信息

可以将需求分解为两步：

1. 查询 方东白 的入职日期
2. 查询 指定入职日期之后入职的员工信息

```SQL
-- 1.查询"方东白"的入职日期
select entrydate from tb_emp where name = '方东白';     #查询结果：2012-11-01
-- 2.查询指定入职日期之后入职的员工信息
select * from tb_emp where entrydate > '2012-11-01';

-- 合并以上两条SQL语句
select * from tb_emp where entrydate > (select entrydate from tb_emp where name = '方东白');
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322280-45f9d9f8-db28-47e9-979a-c0f2c57748c2.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322280-45f9d9f8-db28-47e9-979a-c0f2c57748c2.png)

### 列子查询

子查询**返回的结果是一列** (可以是**多行**)，这种子查询称为列子查询。

常用的操作符：

|   |   |
|---|---|
|**操作符**|**描述**|
|IN|在指定的集合范围之内，多选一|
|NOT IN|不在指定的集合范围之内|

案例：查询"教研部"和"咨询部"的所有员工信息

分解为以下两步：

1. 查询 "销售部" 和 "市场部" 的部门ID
2. 根据部门ID, 查询员工信息

```SQL
-- 1.查询"销售部"和"市场部"的部门ID
select id from tb_dept where name = '教研部' or name = '咨询部';    #查询结果：3,2
-- 2.根据部门ID, 查询员工信息
select * from tb_emp where dept_id in (3,2);

-- 合并以上两条SQL语句
select * from tb_emp where dept_id in (select id from tb_dept where name = '教研部' or name = '咨询部');
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322376-797f41cd-cb91-4629-8c6a-9845789a461c.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322376-797f41cd-cb91-4629-8c6a-9845789a461c.png)

### 行子查询

子查询返回的结果是一行(可以是多列)，这种子查询称为行子查询。

常用的操作符：= 、<> 、IN 、NOT IN

案例：查询与"韦一笑"的入职日期及职位都相同的员工信息

可以拆解为两步进行：

1. 查询 "韦一笑" 的入职日期 及 职位
2. 查询与"韦一笑"的入职日期及职位相同的员工信息

```SQL
-- 查询"韦一笑"的入职日期 及 职位
select entrydate , job from tb_emp where name = '韦一笑';  # 查询结果： 2007-01-01 , 2
-- 查询与"韦一笑"的入职日期及职位相同的员工信息
select * from tb_emp where (entrydate,job) = ('2007-01-01',2);

-- 合并以上两条SQL语句
select * from tb_emp where (entrydate,job) = (select entrydate , job from tb_emp where name = '韦一笑');
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322482-9763ee1c-09f1-42bb-9c3c-fc227742f049.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322482-9763ee1c-09f1-42bb-9c3c-fc227742f049.png)

### 表子查询

**子查询返回的结果**是**多行多列**，常**作为临时表**，这种子查询称为表子查询。

案例：查询入职日期是 "2006-01-01" 之后的员工信息 , 及其部门信息

分解为两步执行：

1. 查询入职日期是 "2006-01-01" 之后的员工信息
2. 基于查询到的员工信息，在查询对应的部门信息

```SQL
select * from emp where entrydate > '2006-01-01';

select e.*, d.* from (select * from emp where entrydate > '2006-01-01') e left join dept d on e.dept_id = d.id ;
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322604-1f3e464f-ac2c-475f-82b5-18912953b889.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260322604-1f3e464f-ac2c-475f-82b5-18912953b889.png)

# 索引

## 介绍

索引(index)：是帮助数据库高效获取数据的数据结构 。

- 简单来讲，就是使用索引可以提高查询的效率。

测试没有使用索引的查询：

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323466-e8a706c6-cce7-4463-8d87-2067be1b81b0.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323466-e8a706c6-cce7-4463-8d87-2067be1b81b0.png)

添加索引后查询：

```Plain
-- 添加索引
create index idx_sku_sn on tb_sku (sn);  #在添加索引时，也需要消耗时间

-- 查询数据（使用了索引）
select * from tb_sku where sn = '100000003145008';
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323596-fe77844d-842c-4b81-b841-d0e122452a64.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323596-fe77844d-842c-4b81-b841-d0e122452a64.png)

优点：

1. 提高数据查询的效率，降低数据库的IO成本。
2. 通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。

缺点：

1. 索引会占用存储空间。
2. 索引大大提高了查询效率，同时却也降低了insert、update、delete的效率。

## 结构

MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。

我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。

在没有了解B+Tree结构前，我们先回顾下之前所学习的树结构：

二叉查找树：左边的子节点比父节点小，右边的子节点比父节点大

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323692-4ca8b279-4b6f-4def-a6a0-093c0826ea51.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323692-4ca8b279-4b6f-4def-a6a0-093c0826ea51.png)

当我们向二叉查找树保存数据时，是按照从大到小(或从小到大)的顺序保存的，此时就会形成一个单向链表，搜索性能会打折扣。

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323788-df614148-9e82-492b-9e5b-8bcff5f1ce26.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323788-df614148-9e82-492b-9e5b-8bcff5f1ce26.png)

可以选择平衡二叉树或者是红黑树来解决上述问题。（红黑树也是一棵平衡的二叉树）

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323879-a1f85035-b383-4901-a1aa-aed4c253e617.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323879-a1f85035-b383-4901-a1aa-aed4c253e617.png)

但是在Mysql数据库中并没有使用二叉搜索数或二叉平衡数或红黑树来作为索引的结构。

思考：采用二叉搜索树或者是红黑树来作为索引的结构有什么问题？

- 答案
    
    最大的问题就是在数据量大的情况下，树的层级比较深，会影响检索速度。因为不管是二叉搜索数还是红黑数，一个节点下面只能有两个子节点。此时在数据量大的情况下，就会造成数的高度比较高，树的高度一旦高了，检索速度就会降低。
    

说明：如果数据结构是红黑树，那么查询1000万条数据，根据计算树的高度大概是23左右，这样确实比之前的方式快了很多，但是如果高并发访问，那么一个用户有可能需要23次磁盘IO，那么100万用户，那么会造成效率极其低下。所以为了减少红黑树的高度，那么就得增加树的宽度，就是不再像红黑树一样每个节点只能保存一个数据，可以引入另外一种数据结构，一个节点可以保存多个数据，这样宽度就会增加从而降低树的高度。这种数据结构例如BTree就满足。

下面我们来看看B+Tree(多路平衡搜索树)结构中如何避免这个问题：

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323989-74ad7af7-8ce6-438d-855f-e5aabadf8df9.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260323989-74ad7af7-8ce6-438d-855f-e5aabadf8df9.png)

B+Tree结构：

- 每一个节点，可以存储多个key（有n个key，就有n个指针）
- 节点分为：叶子节点、非叶子节点
- 叶子节点，就是最后一层子节点，所有的数据都存储在叶子节点上
- 非叶子节点，不是树结构最下面的节点，用于索引数据，存储的的是：key+指针
- 为了提高范围查询效率，叶子节点形成了一个双向链表，便于数据的排序及区间范围查询

**拓展：**

非叶子节点都是由key+指针域组成的，一个key占8字节，一个指针占6字节，而一个节点总共容量是16KB，那么可以计算出一个节点可以存储的元素个数：16*1024字节 / (8+6)=1170个元素。

- 查看mysql索引节点大小：show global status like 'innodb_page_size'; -- 节点大小：16384

当根节点中可以存储1170个元素，那么根据每个元素的地址值又会找到下面的子节点，每个子节点也会存储1170个元素，那么第二层即第二次IO的时候就会找到数据大概是：1170*1170=135W。也就是说B+Tree数据结构中只需要经历两次磁盘IO就可以找到135W条数据。

对于第二层每个元素有指针，那么会找到第三层，第三层由key+数据组成，假设key+数据总大小是1KB，而每个节点一共能存储16KB，所以一个第三层一个节点大概可以存储16个元素(即16条记录)。那么结合第二层每个元素通过指针域找到第三层的节点，第二层一共是135W个元素，那么第三层总元素大小就是：135W*16结果就是2000W+的元素个数。

结合上述分析B+Tree有如下优点：

- 千万条数据，B+Tree可以控制在小于等于3的高度
- 所有的数据都存储在叶子节点上，并且底层已经实现了按照索引进行排序，还可以支持范围查询，叶子节点是一个双向链表，支持从小到大或者从大到小查找

## 语法

**创建索引**

```Plain
create  [ unique ]  index 索引名 on  表名 (字段名,... ) ;
```

案例：为tb_emp表的name字段建立一个索引

```Plain
create index idx_emp_name on tb_emp(name);
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260324083-34cbdfed-0907-4e71-876a-15a87f47f4d2.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260324083-34cbdfed-0907-4e71-876a-15a87f47f4d2.png)

在创建表时，如果添加了主键和唯一约束，就会默认创建：主键索引、唯一约束

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260324175-cbedfbb8-8336-4d01-b54f-6abef4a58e81.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260324175-cbedfbb8-8336-4d01-b54f-6abef4a58e81.png)

**查看索引**

```Plain
show  index  from  表名;
```

案例：查询 tb_emp 表的索引信息

```Plain
show  index  from  tb_emp;
```

[![](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260324388-e1a02da7-cf4b-4465-9d64-1fc6a1598743.png)](https://cdn.nlark.com/yuque/0/2024/png/38953059/1711260324388-e1a02da7-cf4b-4465-9d64-1fc6a1598743.png)

**删除索引**

```Plain
drop  index  索引名  on  表名;
```

案例：删除 tb_emp 表中name字段的索引

```Plain
drop index idx_emp_name on tb_emp;
```

注意事项：

- 主键字段，在建表时，会自动创建主键索引
- 添加唯一约束时，数据库实际上会添加唯一索引