# **标准数据层CRUD功能**

![[/Untitled 27.png|Untitled 27.png]]

# Lombok

一个Java类库，提供了一组注解，简化POJO实体类开发

```XML
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.12</version>
    <scope>provided</scope>
</dependency>
```

@Data 注解像下面来使用，也就是用了lombok

```Java
import lombok.*;

@Data
public class User {
    private Long id;
    private String name;
    private String password;
    private Integer age;
    private String tel;
}
```

为当前实体类在编译期设置对应的get/set方法，无参/无参构造方法，toString方法，hashCode方法，equals方法等。

# 分页功能

## 定义拦截器以及相应的Bean

```Java
package com.itheima.config;

import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MyBatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mpInterceptor() {
        // 1. 定义Mp拦截器
        MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor();
        // 2. 添加具体的拦截器
        mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());


        return mpInterceptor;
    }
}
```

## 拦截器的原理

在 MyBatis Plus（以及 MyBatis）中，拦截器是一种强大的机制，允许开发者在运行时修改或增强某些关键操作。这些操作包括数据库操作（如查询、更新等）和内部流程控制。拦截器的原理基于动态代理，通常是在方法调用之前、之后或周围执行自定义逻辑。

1. 动态代理：MyBatis 使用 Java 的动态代理技术来创建接口的代理实例。拦截器可以在这些代理实例的方法调用中介入。
2. 插件机制：MyBatis 允许拦截器插入到其核心处理逻辑的关键点，如执行语句、参数处理、结果集处理等。拦截器通过实现 Interceptor 接口，并定义特定的拦截规则来实现这一点。
3. 方法拦截：当匹配的方法被调用时，拦截器的 intercept 方法会被触发，允许在方法执行前后或完全替换原方法来执行自定义逻辑。

拦截器是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行。

作用:

- 在指定的方法调用前后执行预先设定的代码
- 阻止原始方法的执行

## 拦截器执行流程

## MyBatis Plus 中的常用拦截器

MyBatis Plus 提供了一些内置的拦截器，以支持常见的场景。

1. PaginationInnerInterceptor（分页拦截器）：这是最常用的拦截器之一，用于提供物理分页功能。它可以自动处理分页的SQL语句。
2. OptimisticLockerInnerInterceptor（乐观锁拦截器）：用于实现乐观锁，通过在更新时检查版本号来确保数据一致性。
3. BlockAttackInnerInterceptor（阻击攻击拦截器）：用于防止全表更新或删除的操作。
4. PerformanceInterceptor（性能分析拦截器）：用于监控和输出SQL语句的执行性能，便于开发时调试和性能分析。
5. IllegalSQLInnerInterceptor（非法SQL拦截器）：用于防止执行非法的SQL语句。

这些拦截器可以单独使用，也可以组合使用，根据具体的业务需求和场景进行配置。

```Java
// 分页拦截器
@Test
void testGetByPage() {
    IPage page = new Page(1, 2);
    userDao.selectPage(page, null);
    System.out.println("当前页码值" + page.getCurrent());
    System.out.println("每页显示数" + page.getSize());
    System.out.println("一共多少页" + page.getPages());
    System.out.println("一共多少条数据" + page.getTotal());
    System.out.println("数据" + page.getRecords());
}
```

这样只能获取到第一页的两条数据。要获取其他页的数据，您需要调整分页器 Page 对象的页码（current）和页大小（size）。

要获取其他页的数据，需要更改这些参数。例如，如果想获取第2页的数据，设置页码为2：

```Java
IPage page = new Page(2, 2);
```

然后再次调用 userMapper.selectPage(page, null); 方法。

如果您想在运行时动态设置这些参数（比如根据用户的输入来决定获取哪一页的数据），您可以将这些参数作为方法的参数传递，然后在调用分页查询方法时使用这些参数创建 Page 对象。

以下是一个示例方法，展示如何动态获取不同页的数据：

```Java
public void getByPage(int currentPage, int pageSize) {
    IPage page = new Page(currentPage, pageSize);
    userMapper.selectPage(page, null);
    System.out.println("Current page number: " + page.getCurrent());
    System.out.println("Current page size: " + page.getSize());
    System.out.println("Total page number: " + page.getPages());
    System.out.println("Total record number: " + page.getTotal());
    System.out.println("================================================");
    System.out.println("Get the specific records: " + page.getRecords());
}
```

然后您可以根据需要调用 getByPage 方法，传递您想查看的页码和页大小。例如，获取第3页的数据，每页5条记录：

```Java
getByPage(3, 5);
```

# 开启MyBatisPlus日志

```YAML
# 开启Mp的日志，输出到控制台
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```